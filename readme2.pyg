public int maximumInvitations(int[] a) { // a: favorite
    // 统计入度，便于进行拓扑排序
    int n = a.length, ins [] = new int [n];
    for (int v : a) ins[v]++;
    boolean vis [] = new boolean [n];
    int f [] = new int [n];
    Arrays.fill(f, 1);
    Deque<Integer> q = new ArrayDeque<>();
    for (int i = 0; i < n; i++)
        if (ins[i] == 0) q.offerLast(i);
    while (!q.isEmpty()) {
        int u = q.pollFirst();
        vis[u] = true;
        int v = a[u];
        f[v] = Math.max(f[v], f[u] + 1); // 动态规划： 能够到达 v 的最长链的长度
        --ins[v];
        if (ins[v] == 0) q.offerLast(v);
    }
    // ring 表示最大的环的大小
    // total 表示所有环大小为 2 的「基环内向树」上的最长的「双向游走」路径之和
    int ring = 0, total = 0;
    for (int i = 0; i < n; i++) {
        if (!vis[i]) {
            int j = a[i];
            if (a[j] == i) { // 说明环的大小为 2
                total += f[i] + f[j]; // 局部二元环可以叠加
                vis[i] = vis[j] = true;
            } else { // 否则环的大小至少为 3，我们需要找出环
                int u = i, cnt = 0;
                do { // 至少执行一次，evaluate after execute
                    ++cnt;
                    u = a[u];
                    vis[u] = true;
                } while (u != i); // 再达到达这一点，说明转了一圈，又回到了起点
                ring = Math.max(ring, cnt); // 找出一个节点数目最多的环
            }
        }
    }
    return Math.max(ring, total);
}
