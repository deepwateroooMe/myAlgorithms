\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 我们需要使用每个字典中的单词去和S比较，看它是否是S的子序列。不过这种比较非常耗费时间，因此我们需要对S进行一下预处理。}
\PYG{c+c1}{// 首先定义一个二维数组arr[][]，其中 arr[i][j]代表距离S中第i位字符最近的j字符的位置。}
\PYG{c+c1}{// 换句话说，我们需要遍历一边字符串，记录下字符串S每一位上的字符，在它右侧距离它最近的a\PYGZhy{}z分别在哪。}
\PYG{k+kd}{public} \PYG{k+kt}{int} \PYG{n+nf}{numMatchingSubseq}\PYG{o}{(}\PYG{n}{String} \PYG{n}{s}\PYG{o}{,} \PYG{n}{String}\PYG{o}{[]} \PYG{n}{words}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n+na}{length}\PYG{o}{();}
    \PYG{k+kt}{int} \PYG{o}{[][]} \PYG{n}{arr} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int} \PYG{o}{[}\PYG{n}{n}\PYG{o}{][}\PYG{l+m+mi}{26}\PYG{o}{];} \PYG{c+c1}{// 预处理用的数组}
    \PYG{k}{for} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}=} \PYG{l+m+mi}{0}\PYG{o}{;} \PYG{n}{i}\PYG{o}{\PYGZhy{}\PYGZhy{})} \PYG{o}{\PYGZob{}}\PYG{c+c1}{// 预处理}
        \PYG{n}{arr}\PYG{o}{[}\PYG{n}{i}\PYG{o}{]} \PYG{o}{=} \PYG{n}{Arrays}\PYG{o}{.}\PYG{n+na}{copyOf}\PYG{o}{(}\PYG{n}{arr}\PYG{o}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{],} \PYG{l+m+mi}{26}\PYG{o}{);}
        \PYG{n}{arr}\PYG{o}{[}\PYG{n}{i}\PYG{o}{][}\PYG{n}{s}\PYG{o}{.}\PYG{n+na}{charAt}\PYG{o}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{)\PYGZhy{}}\PYG{l+s+sc}{\PYGZsq{}a\PYGZsq{}}\PYG{o}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{,} \PYG{n}{idxAtS} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{,} \PYG{n}{idx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{,} \PYG{n}{cur} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
    \PYG{k}{for} \PYG{o}{(}\PYG{n}{String} \PYG{n}{v} \PYG{o}{:} \PYG{n}{words}\PYG{o}{)} \PYG{o}{\PYGZob{}}        \PYG{c+c1}{// 比较每一个单词}
        \PYG{n}{idxAtS} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}                 \PYG{c+c1}{// 对应S的下标}
        \PYG{n}{idx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}                    \PYG{c+c1}{// 当前单词下标}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{v}\PYG{o}{.}\PYG{n+na}{charAt}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{==} \PYG{n}{s}\PYG{o}{.}\PYG{n+na}{charAt}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{))} \PYG{o}{\PYGZob{}} \PYG{c+c1}{// 如果当前单词首字符等于S首字符}
            \PYG{n}{idx} \PYG{o}{++;}                 \PYG{c+c1}{// 当前单词下标加一}
            \PYG{k}{if} \PYG{o}{(}\PYG{n}{v}\PYG{o}{.}\PYG{n+na}{length}\PYG{o}{()} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{o}{)} \PYG{n}{res}\PYG{o}{++;}      \PYG{c+c1}{// 如果当前单词长度只有1，说明当前单词已经遍历结束，结果加一}
        \PYG{o}{\PYGZcb{}}
        \PYG{k}{while} \PYG{o}{(}\PYG{n}{idx} \PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{o}{.}\PYG{n+na}{length}\PYG{o}{())} \PYG{o}{\PYGZob{}}            \PYG{c+c1}{// 继续比较单词接下来的字符，在S中是否存在}
            \PYG{n}{cur} \PYG{o}{=} \PYG{n}{v}\PYG{o}{.}\PYG{n+na}{charAt}\PYG{o}{(}\PYG{n}{idx}\PYG{o}{)} \PYG{o}{\PYGZhy{}} \PYG{l+s+sc}{\PYGZsq{}a\PYGZsq{}}\PYG{o}{;}
            \PYG{k}{if} \PYG{o}{(}\PYG{n}{arr}\PYG{o}{[}\PYG{n}{idxAtS}\PYG{o}{][}\PYG{n}{cur}\PYG{o}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{k}{break}\PYG{o}{;} \PYG{c+c1}{// 如果indexAtS之后不存在c，当前单词不合法}
            \PYG{n}{idxAtS} \PYG{o}{=} \PYG{n}{arr}\PYG{o}{[}\PYG{n}{idxAtS}\PYG{o}{][}\PYG{n}{cur}\PYG{o}{];} \PYG{c+c1}{// 将indexAtS更新为c在S中的位置}
            \PYG{k}{if} \PYG{o}{(++}\PYG{n}{idx} \PYG{o}{==} \PYG{n}{v}\PYG{o}{.}\PYG{n+na}{length}\PYG{o}{())} \PYG{n}{res}\PYG{o}{++;}     \PYG{c+c1}{// index加一, 如果index为单词最后一位，代表单词中所有字符均在S中找到}
        \PYG{o}{\PYGZcb{}}
    \PYG{o}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{res}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}
