\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{n}{TreeNode} \PYG{n+nf}{canMerge}\PYG{o}{(}\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{n}{trees}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{final} \PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n}{trees}\PYG{o}{.}\PYG{n+na}{size}\PYG{o}{();}
    \PYG{k+kd}{final} \PYG{n}{Map}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{,} \PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{n}{roots} \PYG{o}{=} \PYG{k}{new} \PYG{n}{HashMap}\PYG{o}{\PYGZlt{}\PYGZgt{}(}\PYG{n}{size}\PYG{o}{);}
    \PYG{k}{for} \PYG{o}{(}\PYG{k+kd}{final} \PYG{n}{TreeNode} \PYG{n}{node} \PYG{o}{:} \PYG{n}{trees}\PYG{o}{)}
        \PYG{n}{roots}\PYG{o}{.}\PYG{n+na}{put}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{val}\PYG{o}{,} \PYG{n}{node}\PYG{o}{);}
    \PYG{k}{for} \PYG{o}{(}\PYG{k+kd}{final} \PYG{n}{TreeNode} \PYG{n}{node} \PYG{o}{:} \PYG{n}{trees}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{roots}\PYG{o}{.}\PYG{n+na}{containsKey}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{val}\PYG{o}{))} \PYG{o}{\PYGZob{}} \PYG{c+c1}{// 这里判断：是因为接下来buildTree会将可以合并的子树键值对删除并回收利用建大树了}
            \PYG{k+kd}{final} \PYG{n}{TreeNode} \PYG{n}{root} \PYG{o}{=} \PYG{n}{buildTree}\PYG{o}{(}\PYG{n}{roots}\PYG{o}{,} \PYG{n}{node}\PYG{o}{);}
            \PYG{n}{roots}\PYG{o}{.}\PYG{n+na}{put}\PYG{o}{(}\PYG{n}{root}\PYG{o}{.}\PYG{n+na}{val}\PYG{o}{,} \PYG{n}{root}\PYG{o}{);}    \PYG{c+c1}{// update root node}
        \PYG{o}{\PYGZcb{}}
    \PYG{o}{\PYGZcb{}}
    \PYG{k}{if} \PYG{o}{(}\PYG{n}{roots}\PYG{o}{.}\PYG{n+na}{size}\PYG{o}{()} \PYG{o}{!=} \PYG{l+m+mi}{1}\PYG{o}{)} \PYG{k}{return} \PYG{k+kc}{null}\PYG{o}{;}   \PYG{c+c1}{// 无法合并所有的子树}
    \PYG{k+kd}{final} \PYG{n}{TreeNode} \PYG{n}{root} \PYG{o}{=} \PYG{n}{roots}\PYG{o}{.}\PYG{n+na}{values}\PYG{o}{().}\PYG{n+na}{iterator}\PYG{o}{().}\PYG{n+na}{next}\PYG{o}{();} \PYG{c+c1}{// 只有这一颗树根}
    \PYG{k}{return} \PYG{n}{isValid}\PYG{o}{(}\PYG{n}{root}\PYG{o}{,} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{MIN\PYGZus{}VALUE}\PYG{o}{,} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{MAX\PYGZus{}VALUE}\PYG{o}{)} \PYG{o}{?} \PYG{n}{root} \PYG{o}{:} \PYG{k+kc}{null}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{private} \PYG{n}{TreeNode} \PYG{n+nf}{buildTree}\PYG{o}{(}\PYG{n}{Map}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{,} \PYG{n}{TreeNode}\PYG{o}{\PYGZgt{}} \PYG{n}{roots}\PYG{o}{,} \PYG{n}{TreeNode} \PYG{n}{node}\PYG{o}{)} \PYG{o}{\PYGZob{}} \PYG{c+c1}{// 用recursion把所有需要/可以合并的子树建成一棵完整大树，方法很传神}
    \PYG{k+kd}{final} \PYG{n}{TreeNode} \PYG{n}{next} \PYG{o}{=} \PYG{n}{roots}\PYG{o}{.}\PYG{n+na}{remove}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{val}\PYG{o}{);} \PYG{c+c1}{// map.remove()返回值: 如果存在key, 则删除并返回value；如果不存在则返回null}
    \PYG{k}{if} \PYG{o}{(}\PYG{n}{next} \PYG{o}{!=} \PYG{k+kc}{null}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{next}\PYG{o}{.}\PYG{n+na}{left} \PYG{o}{!=} \PYG{k+kc}{null}\PYG{o}{)} \PYG{n}{node}\PYG{o}{.}\PYG{n+na}{left} \PYG{o}{=} \PYG{n}{buildTree}\PYG{o}{(}\PYG{n}{roots}\PYG{o}{,} \PYG{n}{next}\PYG{o}{.}\PYG{n+na}{left}\PYG{o}{);}
        \PYG{k}{if} \PYG{o}{(}\PYG{n}{next}\PYG{o}{.}\PYG{n+na}{right} \PYG{o}{!=} \PYG{k+kc}{null}\PYG{o}{)} \PYG{n}{node}\PYG{o}{.}\PYG{n+na}{right} \PYG{o}{=} \PYG{n}{buildTree}\PYG{o}{(}\PYG{n}{roots}\PYG{o}{,} \PYG{n}{next}\PYG{o}{.}\PYG{n+na}{right}\PYG{o}{);}
    \PYG{o}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{node}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\PYG{k+kd}{private} \PYG{k+kt}{boolean} \PYG{n+nf}{isValid}\PYG{o}{(}\PYG{n}{TreeNode} \PYG{n}{node}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{min}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{max}\PYG{o}{)} \PYG{o}{\PYGZob{}} \PYG{c+c1}{// 这些个递归写得很传功力，要活学活用到出神入化。。。。。。}
    \PYG{k}{if} \PYG{o}{(}\PYG{n}{node} \PYG{o}{==} \PYG{k+kc}{null}\PYG{o}{)} \PYG{k}{return} \PYG{k+kc}{true}\PYG{o}{;}
    \PYG{k+kd}{final} \PYG{k+kt}{int} \PYG{n}{value} \PYG{o}{=} \PYG{n}{node}\PYG{o}{.}\PYG{n+na}{val}\PYG{o}{;}
    \PYG{k}{if} \PYG{o}{(}\PYG{n}{value} \PYG{o}{\PYGZlt{}=} \PYG{n}{min} \PYG{o}{||} \PYG{n}{value} \PYG{o}{\PYGZgt{}=} \PYG{n}{max}\PYG{o}{)} \PYG{k}{return} \PYG{k+kc}{false}\PYG{o}{;}
    \PYG{k}{return} \PYG{n}{isValid}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{left}\PYG{o}{,} \PYG{n}{min}\PYG{o}{,} \PYG{n}{value}\PYG{o}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{isValid}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{right}\PYG{o}{,} \PYG{n}{value}\PYG{o}{,} \PYG{n}{max}\PYG{o}{);}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}
