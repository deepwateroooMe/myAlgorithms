\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{\PYGZgt{}} \PYG{n+nf}{fallingSquares}\PYG{o}{(}\PYG{k+kt}{int}\PYG{o}{[][]} \PYG{n}{p}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{\PYGZgt{}} \PYG{n}{ans} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ArrayList}\PYG{o}{\PYGZlt{}\PYGZgt{}();}
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n+na}{length}\PYG{o}{,} \PYG{n}{cur} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
    \PYG{k+kt}{int} \PYG{o}{[]} \PYG{n}{hi} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int} \PYG{o}{[}\PYG{n}{n}\PYG{o}{];}
    \PYG{k}{for} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{o}{;} \PYG{n}{i}\PYG{o}{++)} \PYG{o}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{len} \PYG{o}{=} \PYG{n}{p}\PYG{o}{[}\PYG{n}{i}\PYG{o}{][}\PYG{l+m+mi}{1}\PYG{o}{],} \PYG{n}{l} \PYG{o}{=} \PYG{n}{p}\PYG{o}{[}\PYG{n}{i}\PYG{o}{][}\PYG{l+m+mi}{0}\PYG{o}{],} \PYG{n}{r} \PYG{o}{=} \PYG{n}{l} \PYG{o}{+} \PYG{n}{len}\PYG{o}{;}
        \PYG{n}{hi}\PYG{o}{[}\PYG{n}{i}\PYG{o}{]} \PYG{o}{+=} \PYG{n}{len}\PYG{o}{;}
        \PYG{k}{for} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{o}{;} \PYG{n}{j}\PYG{o}{++)} \PYG{o}{\PYGZob{}} \PYG{c+c1}{// 采用brute force的思想，对于每个一个下落的方块，我们都去看和后面将要落下的方块有没有重叠}
            \PYG{k+kt}{int} \PYG{n}{ll} \PYG{o}{=} \PYG{n}{p}\PYG{o}{[}\PYG{n}{j}\PYG{o}{][}\PYG{l+m+mi}{0}\PYG{o}{],} \PYG{n}{rr} \PYG{o}{=} \PYG{n}{ll} \PYG{o}{+} \PYG{n}{p}\PYG{o}{[}\PYG{n}{j}\PYG{o}{][}\PYG{l+m+mi}{1}\PYG{o}{];} \PYG{c+c1}{// 有的话，和后面将要落下的方块的位置相比较，取二者中较大值为后面要落下的方块位置高度heights[j]}
            \PYG{c+c1}{// [[6,1],[9,2],[2,4]] 因为不能保证是从左往下延x轴顺序掉落，所以加上l \PYGZlt{} rr 也狠重要 确保不管左右边有交叠}
            \PYG{k}{if} \PYG{o}{(}\PYG{n}{ll} \PYG{o}{\PYGZlt{}} \PYG{n}{r} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{l} \PYG{o}{\PYGZlt{}} \PYG{n}{rr}\PYG{o}{)} \PYG{c+c1}{// 判读两个方块是否重叠的方法是如果方块2的左边界小于方块1的右边界，并且方块2点右边界大于方块1点左边界}
                \PYG{n}{hi}\PYG{o}{[}\PYG{n}{j}\PYG{o}{]} \PYG{o}{=} \PYG{n}{Math}\PYG{o}{.}\PYG{n+na}{max}\PYG{o}{(}\PYG{n}{hi}\PYG{o}{[}\PYG{n}{j}\PYG{o}{],} \PYG{n}{hi}\PYG{o}{[}\PYG{n}{i}\PYG{o}{]);} \PYG{c+c1}{// 这里提前检查是否重叠，是为后来的更新打下base,再接下来遍历i时直接累加就可以了}
        \PYG{o}{\PYGZcb{}}
    \PYG{o}{\PYGZcb{}}
    \PYG{k}{for} \PYG{o}{(}\PYG{k+kt}{int} \PYG{n}{v} \PYG{o}{:} \PYG{n}{hi}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{cur} \PYG{o}{=} \PYG{n}{Math}\PYG{o}{.}\PYG{n+na}{max}\PYG{o}{(}\PYG{n}{cur}\PYG{o}{,} \PYG{n}{v}\PYG{o}{);}
        \PYG{n}{ans}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{cur}\PYG{o}{);}
    \PYG{o}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{ans}\PYG{o}{;}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}
