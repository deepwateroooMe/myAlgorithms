#+latex_class: book
#+author: deepwaterooo

* Segment Tree与Binary Index Tree 线段树与树状数组 
- *【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】*
- 【要解决的问题：】快速区间查找：O（ logN）线段树主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。
- 【其它操作效率】对应于树状数组，线段树进行更新（update）的操作为O(logn)，进行区间查询（range query）的操作也为O(logn)。
- 【缺点：空间占用大】而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。
- 【与树状数组的区别：】与树状数组不同的是，线段树不止可以适用于【区间求和的查询】，也可以进行【区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值的查询】。
- 【分类】：就目前的理解，暂分为两类，一类求和的，一类求最大最小值、或是位操作值（|^&）等等。权值线段树是属于哪里的？
- *【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】*

** 求和Sum的线段树
*** 327. Count of Range Sum - Hard *重点* 这几个题要好好再理解消化几遍
Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.

Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.
**** 【方法一】: 树状数组
     
[[./pic/segmentTree_20230414_114943.png]]
#+BEGIN_SRC java
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
class BIT {
    int [] f; // 明数组：长度【1,n】下，各下标（或其映射）【0,1】出现与否
    int n;
    public BIT(int n) {
        this.n = n;
        f = new int [n+1]; // 下标：从1 开始，【1,N】因为2^0=1
    }
    int lowBit(int x) {
        return x & -x;
    }
    void update(int i, int v) { // 【自底向上】：把 f[i] 及其、所有层级向上的、父节点、都全部更新
        while (i <= n) {
            f[i] += v; 
            i += lowBit(i);
        }
    }
    int query(int i) { // 【TODO】：这个过程，还有点儿糊涂。。。
        int ans = 0;
        while (i > 0) {
            ans += f[i];
            i = i - lowBit(i); // 【自顶向下】：从树的、某根节点，【自顶向下】，遍历到【最底层、某特定叶子节点】
        }
        return ans;
    }
 }
// 题解思路：
// 我们从左到右扫描前缀和数组。
// 每遇到一个数 preSum[j]，我们就在线段树中查询区间 [preSum[j]−upper,preSum[j]−lower] 内的整数数量，
// 随后，将 preSum[j] 插入到线段树当中。
public int countRangeSum(int [] a, int lo, int hi) { 
    int n = a.length, ans = 0;
    long [] f = new long [n+1]; // preSum 数组：机关： f[0]=0 【客观存在】！！
    for (int i = 1; i <= n; i++) 
        f[i] = f[i-1] + (long)a[i-1];
    System.out.println(Arrays.toString(f));
    // 对【离散化数据】【集中】处理：
    Set<Long> s = new TreeSet<>(); // 排序：单调升序。去重。。。
    for (long v : f) { // preSum 数组：机关： f[0]=0 【客观存在】！！
        s.add(v);
        s.add(v-hi);
        s.add(v-lo);
    }
    int idx = 0; // idx: 对【离散化数据】【集中】处理, 映射关系、存字典，标记下标、记号
    Map<Long, Integer> m = new HashMap<>();
    for (long v : s)
        m.put(v, idx++);
    // BIT 方法：查询方法，与【线段树】相比，稍微不同
    BIT bit = new BIT(m.size());
    for (long v : f) {
        int l = m.get(v-hi), r = m.get(v-lo); // 计算：左右端点值、对应的下标 idx  
// 数：【BIT 树状数组】中，此【l,r】区间的元素总个数
        ans += bit.query(r+1) - bit.query(l);
        // 添加：【当前下标 i 的前缀和 v】
        bit.update(m.get(v)+1, 1); // 将 bit 中【m.get(v)+1】下标的元素，更新出现为 1. 有重复元素，会怎么样呢？？？【TODO】：想一想
    }
    return ans;
}
#+END_SRC

[[./pic/segmentTree_20230414_115003.png]]
**** 【方法二】线段树 + 离散化数据的连续化处理 
     
[[./pic/segmentTree_20230414_110820.png]]
#+BEGIN_SRC java
class SegNode {
    int lo, hi, cnt; // lo, hi: 数据集中后，对应的下标索引
    SegNode l, r;    // left right children
    public SegNode(int lo, int hi) {
        this.lo = lo; this.hi = hi;
        cnt = 0;
        l = null; r = null;
    }
}
// 这个方法，是怎么计个数的？这里，还没填充数据，仅只分配了【尽可能、短长度】的【集中处理】了的数据的个数
SegNode build(int lo, int hi) { 
    SegNode f = new SegNode(lo, hi);
    if (lo == hi)
        return f;
    int m = (lo + hi) / 2;
    f.l = build(lo, m);
    f.r = build(m+1, hi);
    return f;
}
void insert(SegNode f, int v) { // 真正添加，才开始计数
    f.cnt++; // 【自顶向下】的、所有、父节点：个数增加
    if (f.lo == f.hi) return ; // 叶子节点
    int m = (f.lo + f.hi) / 2;
    if (v <= m)
        insert(f.l, v);
    else
        insert(f.r, v);
}
int count(SegNode f, int l, int r) {
    if (r < f.lo || f.hi < l)   // 破烂【BUG：】方向写反了。。
        return 0;
    if (l <= f.lo && f.hi <= r) // 即： f[lo,hi] 是，想要查询区间【l,r】的子集
        return f.cnt;
    return count(f.l, l, r) + count(f.r, l, r);
}
// 题解思路：
// 我们从左到右扫描前缀和数组。
// 每遇到一个数 preSum[j]，我们就在线段树中查询区间 [preSum[j]−upper,preSum[j]−lower] 内的整数数量，
// 随后，将 preSum[j] 插入到线段树当中。
public int countRangeSum(int [] a, int lo, int hi) { 
    int n = a.length, ans = 0;
    long [] f = new long [n+1]; // preSum 数组：机关： f[0]=0 【客观存在】！！
    for (int i = 1; i <= n; i++) 
        f[i] = f[i-1] + (long)a[i-1];
    System.out.println(Arrays.toString(f));
    // 对【离散化数据】【集中】处理：
    Set<Long> s = new TreeSet<>(); // 排序：单调升序
    for (long v : f) { // preSum 数组：机关： f[0]=0 【客观存在】！！
        s.add(v);
        s.add(v-hi);
        s.add(v-lo);
    }
    int idx = 0; // idx: 对【离散化数据】【集中】处理, 映射关系、存字典，标记下标、记号
    Map<Long, Integer> m = new HashMap<>();
    for (long v : s)
        m.put(v, idx++);
    SegNode root = build(0, m.size()-1); // 闭区间：【0, m.size()-1】所有下标，全包括了
    for (long v : f) {
        int l = m.get(v-hi), r = m.get(v-lo); // 计算：左右端点值、对应的下标 idx  
        ans += count(root, l, r);             // 数：【线段树】中，此【l,r】区间的元素个数
        // 添加：【当前下标 i 的前缀和 v】
        insert(root, m.get(v));
    }
    return ans;
}
#+END_SRC
- 复杂度分析
  - 时间复杂度：O(NlogN)。使用哈希离散化之后，线段树维护的区间大小为 O(N)，故其深度、单次查询或插入的时间复杂度均为 O(logN)。而离散化本身的复杂度也为 O(NlogN)。
  - 空间复杂度：O(N)。线段树的深度为 O(N)，而第 i 层拥有的节点数量为 2^(i−1)，故线段树总的节点数量为 2^O(logN)=O(N)。
- 线段树：方法的复杂度分析 
  
[[./pic/segmentTree_20230414_110931.png]]
**** 解题思路与分析: 动态增加节点的线段树
- 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
     
[[./pic/segmentTree_20230414_113119.png]]
#+BEGIN_SRC java
// 亲爱的表哥的活宝妹，把这个【动态添加节点】终于写出来了，可是感觉、这种写法【不经典】不够好，希望有个【经典的、典型、模块】可以【时时、处处、想用就能、套用】！！！
public class SegNode {
    long li, ri; // 节点：懒惰标记的【区间两端点】
    int rr;      // 重复数: 以【当前节点】为【根节点】子树的、树大小 size 
    SegNode l, r;
    public SegNode(long li, long ri) {
        this.li = li; this.ri = ri;
        rr = 0;
        l = r = null;
    }
}
public int count(SegNode r, long li, long ri) {
    if (r == null) return 0;
    if (ri < r.li || r.ri < li)   // 查询的『值域』：完全在，本线段树，管辖区、之外，没有交集
        return 0;
    if (li <= r.li && r.ri <= ri) // 查询的『值域』：完全包含、本线段树，管辖区，返回全部个数
        return r.rr;
    // if (r.li == r.ri) // 这个分支：可以完全被、上个分支、覆盖住、完全包含
    //     return r.rr; // 是个数大小，也是【叶子节点的、同值、重复个数】
    // long m = r.li + (r.ri - r.li) / 2;
    // return count(r.l, li, m) + count(r.r, m+1, ri);
    return count(r.l, li, ri) + count(r.r, li, ri);
}
public void insert(SegNode r, long v) {
    r.rr++; // 【自顶向下】：层级添加，数树大小 size 
    if (r.li == r.ri) // r.li = r.ri = v 这个，是确定的吗？到叶子节点，回归调用的终止条件
        return ;
    // 【动态添加节点、线段树】：因为实时动态，与【懒惰添加？对吗？】，可以不必【离散数据压缩】，
    // 仅只【极尽缩小】线段树的【区间跨度长短】，压缩空间占用、提升插入、与查询效率
    // 【最狭窄、管辖区值域】：
    //   它，不只是个标记记号！大小无所谓、宽狭无所谓？？？堆溢出、内存空间溢出。。。试试看。。。
    //   添加任何节点过程中，一路上、各树各子树的【根节点】，和插入的【叶子节点】，都会【二分大小】，需要一一开辟空间建立节点
    // 所以，只有，【最狭窄、管辖区值域】，才是【最节省空间】，也是【查询】时最高效的！！
    long m = r.li + (r.ri - r.li) / 2;
    if (v <= m) {
        if (r.l == null) // 提前建立好：指定【管辖区】的【左子节点】
            r.l = new SegNode(r.li, m); // <<<<<<<<<<<<<<<<<<<< 
        insert(r.l, v);
    } else {
        if (r.r == null) // 提前建立好：指定【管辖区】的【右子节点】
            r.r = new SegNode(m+1, r.ri); // <<<<<<<<<<<<<<<<<<<< 
        insert(r.r, v);
    }
}
public int countRangeSum(int [] a, int lo, int hi) { 
    int n = a.length, ans = 0;
    long [] f = new long [n+1]; // preSum 数组：机关： f[0]=0 【客观存在】！！
    for (int i = 1; i <= n; i++) 
        f[i] = f[i-1] + (long)a[i-1];
    // 【动态添加节点、线段树】：因为实时动态，与【懒惰添加？对吗？】，可以不必【离散数据压缩】，
    // 仅只【极尽缩小】线段树的【区间跨度长短】，压缩空间占用、提升插入、与查询效率
    // 【最狭窄、管辖区值域】：
    //   它，不只是个标记记号！大小无所谓、宽狭无所谓？？？堆溢出、内存空间溢出。。。试试看。。。
    //   添加任何节点过程中，一路上、各树各子树的【根节点】，和插入的【叶子节点】，都会【二分大小】，需要一一开辟空间建立节点
    // 所以，只有，【最狭窄、管辖区值域】，才是【最节省空间】，也是【查询】时最高效的！！
    long ll = Long.MAX_VALUE, rr = Long.MIN_VALUE;
    for (long v : f) {
        ll = Math.min((long)Math.min(ll, v), (long)Math.min(v-lo, v-hi));
        rr = Math.max((long)Math.max(rr, v), (long)Math.max(v-lo, v-hi));
    }
    SegNode root = new SegNode(ll, rr); // 管辖区间：【ll,rr】
    for (long v : f) {
        System.out.println("\n v: " + v);
        long vv = count(root, v-hi, v-lo); 
        ans += vv;
        System.out.println("vv: " + vv + " " + "ans: " + ans);
        insert(root, v);
    }
    return ans;
}
#+END_SRC
- 复杂度分析：

[[./pic/segmentTree_20230414_113141.png]]
**** 解题思路与分析: 平衡二叉搜索树

[[./pic/segmentTree_20230414_142718.png]]

#+BEGIN_SRC java
// 【方法五：平衡二叉搜索树】
// 【TODO】：【-1,1】0,0 还有个什么狗屁破烂 seed 自平衡、结果不稳定的问题？改天再写，现在找不出这个【BUG：】了
public class BT { // BT: BalancedTree
private class Node {
    long v, sd; // 值、种子
    int rr, s;  // 重复、大小
      Node l, r;  // 左右子节点
      Node (long v, long sd) {
          this.v = v; this.sd = sd;
            rr = 1; s = 1;
            l = r = null;
        }
        //   this         r <== root
        //  /    \      /    \
        // l      r   this   r.r(root.r)
        //           /    \
        //          l     r.l(root.l)
        Node leftRotate() { 
            int prevSize = size; // 以 this 为根节点的树：大小 
            // 当前节点 this 【左旋转】后的、作为【新根节点的、左子节点】后，其【左中右】节点的、【左子根节点】节点、总数目 
            int size = (l == null ? 0 : l.s) + (r.l == null ? 0 : r.l.s) + rr;
            Node root = r;
            this.r = r.l;
            root.l = this;
            this.s = size;     // 旋转后，作为【根左节点】的子树根，子树的新大小
            root.s = prevSize; // 不管谁是【根节点】，树的总大小不变
            return root;
        }
        //       this         l <== root
        //      /    \      /    \
        //     l      r   l.l    this
        //   /    \             /    \
        // l.l    l.r         l.r     r
        Node rightRotate() {
            int prevSize = size; // 这些大小，这里，傻傻拎不清楚。。。
            // 当前节点 this 的、旋转后【左中右】总数目 
            int size = (r == null ? 0 : r.s) + (l.r == null ? 0 : l.r.s) + rr;
            Node root = l;
            this.l = root.r;
            // this.l = l.r; // 【写错了】？？？
            root.r = this;
            this.s = size;
            root.s = prevSize;
            return root;
        }
    }
    private Node root;
    private int size;
    private Random rand;
    public BT() {
        root = null;
        size = 0;
        rand = new Random();
    }
    public long getSize() { // <<<<<<<<<<<<<<<<<<<< long
        return size;
    }
    public void insert(long v) {
        ++size;
        root = insert(root, v);
    }
    // 这么看，这两三个函数，也并不难呀。。昨天晚上、快入睡前的亲爱的表哥的活宝妹，脑袋上锈了。。
    public long lowerBound(long v) { // 【自平衡树 treap】中查找：最小的，【大于等于 v 的值】。递归函数 
        Node r = root;
        long ans = Long.MAX_VALUE; // 【初始化】：找最小可能值，初始化为，类型 long 最大
        while (r != null) {
            if (r.v == v) // >= v: 最小可能值 v, 直接返回
                return v;
            if (r.v < v)
                r = r.r;
            else { // v < r.v
                ans = r.v;
                r = r.l;
            }
        }
        return ans;
    }
    public long upperBound(long v) { // 【自平衡树 treap】中查找：最小，【大于 v 的值】 
        Node r = root;
        long ans = Long.MAX_VALUE;
        while (r != null) {
            if (r.v <= v)
                r = r.r;
            else { // v < r.v
                ans = r.v;
                r = r.l;
            }
        }
        return ans;
    }
    public int [] rank(long v) { // 为什么：它要返回2 个、计数？结果，也只用到 r[0] 而已，可能仿某些库函数的定义
        Node r = root;
        int ans = 0;
        while (r != null) {
            if (v < r.v)
                r = r.l;
            else { // r.v <= v  
                // int ans = (r.l == null ? 0 : r.l.s) + r.rr; // 【写错了】：答案不对！！
                ans += (r.l == null ? 0 : r.l.s) + r.rr; // while(){} 递归、向【右子节点】遍历时，答案累加
                if (v == r.v)
                    return new int [] {ans - r.rr + 1, ans}; // 【v 在平衡树中、最小值排序】
                // r.v < v
                r = r.r; // 向右遍历
            }
        }
        // r == null  
        return new int [] {Integer.MIN_VALUE, Integer.MAX_VALUE}; // 不知道，为什么、需要、返回这些极值。。
    }
    private Node insert(Node r, long v) { // 这个方法，应该写得是对的！！
        if (r == null) {
            r = new Node(v, rand.nextInt(131427));
            // r = new Node(v, rand.nextInt()); // 也可以，不限定随机生成数的大小范围
            // 上面： r.s=1 是缺省自添加的
            return r;
        }
        r.s++;  // 【自顶向下】：自根节点，向叶子节点、路径上的、每个节点，都自增。叶子节点自动处理了，可以不用管它们
        // 维护【平衡二叉树的、自平衡】：当作一个【sd最大堆】来写。。是用 sd 来维护【自平衡】的
        if (v < r.v) {
            r.l = insert(r.l, v);
            if (r.l.sd > r.sd)
                r.rightRotate();
        } else if (r.v < v) {
            r.r = insert(r.r, v);
            if (r.r.sd > r.sd)
                r.leftRotate();
        } else // r.v == v
            r.rr++;
        return r;
    }
}
// 题解思路：
// 我们从左到右扫描前缀和数组。
// 每遇到一个数 preSum[j]，我们就在线段树中查询区间 [preSum[j]−upper,preSum[j]−lower] 内的整数数量，
// 随后，将 preSum[j] 插入到线段树当中。
public int countRangeSum(int [] a, int lo, int hi) { 
    int n = a.length, ans = 0;
    long [] f = new long [n+1]; // preSum 数组：机关： f[0]=0 【客观存在】！！
    for (int i = 1; i <= n; i++) 
        f[i] = f[i-1] + (long)a[i-1];
    BT treap = new BT();
    for (long v : f) {
        long numLeft = treap.lowerBound(v - hi); // 【平衡树中】：最小 >= (v-hi) 的、最小数值
        // 最小数值：树中最小排行
        int rankLeft = (numLeft == Long.MAX_VALUE ? (int)treap.getSize()+1 : treap.rank(numLeft)[0]);
        long numRight = treap.upperBound(v - lo); // 【平衡树中】：最小 > (v-lo) 的、最小数值
        // 最小数值：最小树中、排行
        int rankRight = (numRight == Long.MAX_VALUE ? (int)treap.getSize() : treap.rank(numRight)[0]-1);
        ans += rankRight - rankLeft + 1;
        treap.insert(v);
    }
    return ans;
}
#+END_SRC
- 复杂度分析
  - 时间复杂度：O(NlogN)。
  - 空间复杂度：O(N)。
- 这里简单介绍一下Treap 这个数据结构，因为最易编程，被广泛使用，应该掌握。 
  
[[./pic/segmentTree_20230414_145439.png]]
- 维护平衡的原因：修正值 
  - 为什么平衡:我们发现，BST 会遇到不平衡的原因是因为有序的数据会使查找的路径退化成链，而随机的数据使 BST 退化的概率是非常小的。在 Treap 中，修正值的引入恰恰是使树的结构不仅仅取决于节点的值，还取决于修正值的值。然而修正值的值是随机生成的，出现有序的随机序列是小概率事件，所以 Treap 的结构是趋向于随机平衡的。 

**** 解题思路与分析: 分治法，自底向上的解决问题
     
[[./pic/segmentTree_20230414_095339.png]]
- 下面是最原始的归并排序的解法与写法
     #+BEGIN_SRC java
// 【最基本的数据结构的解法】：归并排序。整个过程是一个自底向上，不断求值与归并的过程
public int countRangeSum(int[] a, int lo, int hi) {
    int n = a.length;
    long [] s = new long [n+1]; // 用来求和 prefixSum
    for (int i = 0; i < n; i++) s[i+1] = s[i] + a[i]; // 不一定是：升序排列 
    return countRangeSumRecursive(s, lo, hi, 0, n);
}
int countRangeSumRecursive(long [] sum, int lo, int hi, int l, int r) { // l: 左下标， r: 右下标
    if (l == r) return 0;
    int m = (l + r) / 2;
    // 【首先，递归，分别解决左右半部分的问题】：分别解决了左右部分之后，左右部分分别是有序排列的片段
    int n1 = countRangeSumRecursive(sum, lo, hi, l, m);
    int n2 = countRangeSumRecursive(sum, lo, hi, m+1, r);
    int ans = n1 + n2;
    // 【再来解决归并相关】
    // 首先统计下标对的数量
    int i = l, left = m+1, right = m+1;
    while (i <= m) {
        while (left <= r && sum[left] - sum[i] < lo) left++; // 左边界右移，直到达标【 lo, 。。。
        right = left; // 可要可不要，要了可以少遍历上面的过程。。。
        while (right <= r && sum[right] - sum[i] <= hi) right++; // 右边界右移，直到不达标越界。。。 hi-1 】 hi...
        ans += right - left;
        i++;
    }
    // 随后合并两个排序数组
    long [] sorted = new long [r - l + 1];
    int x = l, y = m+1, z = 0; //x,y,z: 分别为左右两个片段的遍历下标，以及合并数组的遍历下标
    while (x <= m || y <= r) 
        if (x > m) sorted[z++] = sum[y++];
        else if (y > r) sorted[z++] = sum[x++];
        else if (sum[x] < sum[y]) sorted[z++] = sum[x++];
        else sorted[z++] = sum[y++];
    // 再把这个排序好的数组，更新同步到累积和数组里去
    for (int j = 0; j < sorted.length; j++) 
        sum[l+j] = sorted[j];
    return ans;
}
#+END_SRC
- 复杂度分析为： 
  
[[./pic/segmentTree_20230414_095227.png]]
- 下面是一个代码更为简洁的写法，排序的步骤本地用语言自带的排序法
#+BEGIN_SRC java
public int countRangeSum(int[] a, int lower, int upper) { // 这个merge sort的思维很奇特: 二分，O(NlogN)
    long [] sum = new long[a.length+1];
    for (int i = 0; i < a.length; i++)
        sum[i+1] = sum[i] + a[i];
    return mergeAnalyse(sum, 0, a.length+1, lower, upper);
}
int mergeAnalyse(long [] a, int l, int r, int lo, int hi) { // l, r: 寻找【l, r）范围内和为【lower, upper】的片段的个数
    if (r - l <= 1) return 0;
    int m = l + (r - l) / 2;
    // int mid = l + (r - l) / 2;
    // int m = mid, n = mid, ans = 0;
    int ans = mergeAnalyse(a, l, m, lo, hi) + mergeAnalyse(a, m, r, lo, hi);
    int x = m, y = m;
    for (int i = l; i < m; i++) { // 遍历[l, r)的半段长度： pivot 右移，滑动窗口，寻找合法窗口 // 通过遍历寻找当前范围中符合要求的个数，
        while (x < r && a[x] - a[i] < lo) x++; // 左端点右移，直到找到合法（sum >= lo）的解：m合法
        y = x; // 可要可不要。。。
        while (y < r && a[y] - a[i] <= hi) y++; // 右端点右移，直到右端点右移至不再合法（sum > hi）, n 不合法 
        ans += y - x; // 对于[l, r)范围内的当前i来说，满足要求的总个数为 n - m
    }
    Arrays.sort(a, l, r); // 将 【l, r）片段排序，本地排序
    return ans;
}
#+END_SRC
*** 2407. Longest Increasing Subsequence II: 【线段树】：【贴出来方便自己查询，解题印象深刻】活宝妹就是一定要嫁给亲爱的表哥！！！
You are given an integer array nums and an integer k.

Find the longest subsequence of nums that meets the following requirements:

The subsequence is strictly increasing and
The difference between adjacent elements in the subsequence is at most k.
Return the length of the longest subsequence that meets the requirements.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
- 添加这个题目，主要是昨天晚上写的时候，感觉对于开闭区间，下标等，似乎还没有理解透彻。这个题算是比较简单，自己基本上会写的题，再总结一下。
  
[[./pic/segmentTree_20230507_082737.png]]
**** 线段树的标准简洁写法：
#+BEGIN_SRC java
public int lengthOfLIS(int[] a, int k) {  // 动规：＋线段树来找前 f【i】【v-k】范围内的最大值
    int n = a.length, m = Arrays.stream(a).max().getAsInt();
    t = new int [4 * m]; // 线段树？下标是从 1 开始的吗？这里感觉取不到最大值【m】
    for (int v : a)
        if (v == 1) update(1, 1, m, 1, 1); // 更新单点：【v, res】成 t[1] ＝ 1
        else {
            int res = 1 + query(1, 1, m, Math.max(1, v-k), v-1); // 查询区间：【v-k, v-1】
            update(1, 1, m, v, res); // 更新单点：【v, res】成 t[v] ＝ res
       }
    return t[1];
}
int [] t; // 线段树：最大值线段树，下标从1 开始的标准写法
void update(int u, int l, int r, int i, int v) { // 更新下标为 i 元素的值为 v, 从 u 节点开始遍历
    if (l == r) {
        t[u] = v;
        return ;
    }
    int m = l + (r - l) / 2;
    if (i <= m) update(u << 1, l, m, i, v);
    else update(u << 1 | 1, m+1, r, i, v); // 【左右节点的下标：】 U 《 1 | 1 
    t[u] = Math.max(t[u << 1], t[u << 1 | 1]); // 根节点最大值：取左右节点的最大值 
}
// 查询【L,R】范围内的最大值，线段树的跨越区间为【l,r】. L 和 R 在整个递归过程中均不变，将其大写，视作常量
int query(int u, int l, int r, int L, int R) { // 返回区间 [L,R] 内的最大值
    if (L <= l && r <= R) return t[u]; // 整个线段树，处于查询区间内，返回根节点最大值 
    int m = l + (r - l) / 2, leftMax = 0, rightMax = 0;
    if (L <= m)   leftMax = query(u << 1, l, m, L, R);
    if (m+1 <= R) rightMax = query(u << 1 | 1, m+1, r, L, R);
    return Math.max(leftMax, rightMax);
}
#+END_SRC
**** 线段树的【奇葩版本的】写法：
#+BEGIN_SRC java
public int lengthOfLIS(int[] a, int k) {  // 动规：＋线段树来找前 f【i】【v-k】范围内的最大值【这个题仍然成了学习题】
    int n = a.length, m = Arrays.stream(a).max().getAsInt()+1, ans = 1;
    t = new int [4 * m]; // 不是说，线段树？下标是从 1 开始的吗？最大值 m 元素在哪里 
    int [][] f = new int [n][m]; // 第二维表达的是以当前数 a[i] 为结尾的最长合法子序列长度，所以取最值
    for (int i = 0; i < n; i++) { // 注意【0】下标更新线段树。。。
        int v = a[i];
        f[i][v] = 1;
        // 这里要找：前所有 i 个数【0,i-1】中，以【v-k,v-1】结尾的最大值，最大长度，
// 这里我是在想要遍历，总复杂度为【O(N^2)】，线段树可以做到【O(NlogN)】线段树中的第一维就给消除掉，只累加更新【0,maxVal+1】范围内的最大值
        // for (int j = Math.max(0, v - k); j < v; j++) // 因为线段树区间求最大值：这里就不用遍历，一次【 O(logN)】查询就可以了
            // f[i][v] = Math.max(f[i][v], f[i-1][j] + 1); // 【分不清：哪个 i?】
        f[i][v] = Math.max(f[i][v], getMax(0, 0, m-1, v-k, v-1, t) + 1); // 查询线段树【v-k,v-1】区间最大值：下标1 开始，左闭右闭区间
        // f[i][v] = Math.max(f[i][v], getMax(0, 0, n-1, v-k, v-1, t) + 1); // 查询线段树【v-k,v-1】区间最大值：下标1 开始，左闭右闭区间
        update(0, 0, m-1, v, f[i][v], t); // 更新线段树单点元素： v 下标值为 f[i][v]
        // update(0, 0, n-1, i, f[i][v], t); // 更新线段树单点元素： v 下标值为 f[i][v]
        // ans = Math.max(ans, f[i][v]);
    }
    return t[0];
}
int [] t; // 【奇葩线段树】：下标从 0 开始的
void update(int u, int l, int r, int idx, int v, int [] t) { // 我这里参考别人的奇葩写法，写得自己稀里糊涂的。。。重写一遍
    if (l == r) {
        t[u] = v;
        return ;
    }
    int m = l + (r - l) / 2;
    if (idx <= m) update(u << 1 | 1, l, m, idx, v, t);
    else update((u << 1) + 2, m+1, r, idx, v, t);
    t[u] = Math.max(t[u << 1 | 1], t[(u << 1) + 2]); // 最大值线段树：根节点最大值，取左右子节点最大值 
}
int getMax(int u, int l, int r, int L, int R, int [] t) { // 【 l,r】：现存线段树的有效区间跨度；【L,R】：查询区间跨度
    if (R < l || r < L) return 0;
    if (L <= l && r <= R) return t[u];
    int m = l + (r - l) / 2;
    int ll = getMax(u << 1 | 1, l, m, L, R, t);
    int rr = getMax((u << 1) + 2, m+1, r, L, R, t);
    return Math.max(ll, rr);
}
#+END_SRC
*** 1157. Online Majority Element In Subarray - Hard
Design a data structure that efficiently finds the majority element of a given subarray.

The majority element of a subarray is an element that occurs threshold times or more in the subarray.

Implementing the MajorityChecker class:

MajorityChecker(int[] arr) Initializes the instance of the class with the given array arr.
int query(int left, int right, int threshold) returns the element in the subarray arr[left...right] that occurs at least threshold times, or -1 if no such element exists.

- https://www.cnblogs.com/slowbirdoflsh/p/11381565.html 思路比较清晰
  
[[./pic/1157.png]]

#+BEGIN_SRC java
Map<Integer, List<Integer>> idx; // idx 存储数组出现元素种类 以及该元素下标索引
Node root; // 线段树的根节点
int key = 0, cnt = 0; // key 所查找的区域众数; count 所查找的区域众数出现次数, 
public MajorityChecker(int[] a) {
    idx = new HashMap<>(); // idx 存储数组出现元素种类 以及该元素下标索引
    for (int i = 0; i < a.length; i++)
        idx.computeIfAbsent(a[i], z -> new ArrayList<>()).add(i);
    root = buildTree(a, 0, a.length-1);
}
public int query(int left, int right, int threshold) {
    key = 0; cnt = 0; // 初始化 所查询众数key 及辅助判断的计数cnt
    searchTree(root, left, right); // 查询线段树
    // 如果查询区域没有众数 即key没被更改; 或者,
    // 所查询出来的众数 在原数组中根本没有超出阈值的能力
    if (key == 0 || idx.get(key).size() < threshold) return -1;
    // 上确界 排序数组中 第一个大于right的下标
    int r = upper_bound(idx.get(key), right);
    // 下确界 排序数组中 第一个大于等于left的下标
    int l = lower_bound(idx.get(key), left);
    cnt = r - l;
    return cnt >= threshold ? key : -1;
}
int upper_bound(List<Integer> list, int v) { // 排序数组中 第一个大于tar的下标
    int l = 0, r = list.size();
    while (l < r) {
        int mid = l + (r - l) / 2;
        if (list.get(mid) <= v) l = mid + 1;
        else r = mid;
    }
    return l;
}
int lower_bound(List<Integer> list, int v) { // 排序数组中 第一个大于等于tar的下标
    int l = 0, r = list.size();
    while (l < r) {
        int mid = l + (r - l) / 2;
        if (list.get(mid) < v) l = mid+1;
        else r = mid;
    }
    return l;
}
void searchTree(Node root, int l, int r) {
    if (root == null || l > r) return ;
    if (root.l > r || root.r < l) return ;
    if (root.l >= l && root.r <= r) { // 当查询边界被节点边界覆盖，该节点就是查询区域
        if (key == root.v) cnt += root.cnt;
        else if (cnt <= root.cnt) {
            key = root.v;
            cnt = root.cnt - cnt;
        } else cnt = cnt - root.cnt;
        return ;
    }
    int mid = (root.l + root.r) / 2; // 这两个查询条件再好好想想 ！！！！！！！！！！！！！！！
    if (l <= mid)   // root.l <= l <= mid 左节点也可以是查询区域
        searchTree(root.left, l, r);
    if (r >= mid+1) // mid+1 <= r <= root.r 右节点也可以是查询区域
        searchTree(root.right, l, r);
}
Node buildTree(int [] a, int l, int r) {
    if (l > r) return null;
    Node root = new Node(l, r); // 初始一个线段树的根节点
    if (l == r) { // 叶子节点  
        root.v = a[l];
        root.cnt = 1;
        return root;
    }
    int mid = (l + r) / 2;
    root.left = buildTree(a, l, mid);
    root.right = buildTree(a, mid+1, r);
    makeRoot(root); // 整合父节点
    return root;
}
void makeRoot(Node r) { // 整合父节点
    if (r == null) return ;
    if (r.left != null) { // 如果该节点有左子节点 该节点的值"先"等于左子节点
        r.v = r.left.v;
        r.cnt = r.left.cnt;
    }
    if (r.right != null) { // 如果该节点还有右子节点 融合父节点和子节点
        if (r.v == r.right.v)
            r.cnt = r.cnt + r.right.cnt;
        else {
            if (r.cnt >= r.right.cnt)
                r.cnt = r.cnt - r.right.cnt;
            else {
                r.v = r.right.v;
                r.cnt = r.right.cnt - r.cnt;
            }
        }
    }
}
class Node {
    int l, r, v, cnt;
    Node left, right;
    public Node(int l, int r) {
        this.l = l; this.r = r;
        v = 0; cnt = 0;
        left = null; right = null;
    }
}
#+END_SRC
*** 1825. Finding MK Average - Hard
You are given two integers, m and k, and a stream of integers. You are tasked to implement a data structure that calculates the MKAverage for the stream.

The MKAverage can be calculated using these steps:

If the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.
Remove the smallest k elements and the largest k elements from the container.
Calculate the average value for the rest of the elements rounded down to the nearest integer.
Implement the MKAverage class:

MKAverage(int m, int k) Initializes the MKAverage object with an empty stream and the two integers m and k.
void addElement(int num) Inserts a new element num into the stream.
int calculateMKAverage() Calculates and returns the MKAverage for the current stream rounded down to the nearest integer.
#+BEGIN_SRC java
// 根据题意需要找到前k大的数，又需要求区间和，就自然想到线段树.写起来较不容易出错。
// 维护2个线段树数组，一个记录数的个数，一个记录区间值，
// 注意一般线段树中[s，e]指固定的区间，这里类似线段数求第k小的数，所以[s,e]指第s小的值到第e小的值的区间。
    Deque<Integer> q = new ArrayDeque<>(); // 始终维护m个数
    int [] cnt;  // 每个元素出现的次数
    long [] sum; // 累积和
    int m, k, n = 100000, N = n * 4 + 1; // 线段树所占用的空间为数组的四倍大小
    public MKAverage(int m, int k) {
        cnt = new int [N];
        sum = new long [N];
        this.m = m;
        this.k = k;
    }
    public void addElement(int num) {
        if (q.size() == m) {
            int v = q.pollFirst();
            insert(1, 0, n, v, -1); // 当删除掉一个元素的时候，需要更新线段树中的和
        }
        insert(1, 0, n, num, 1);
        q.offerLast(num);
    }
    public int calculateMKAverage() {
        if (q.size() < m) return -1;
        int bgn = k + 1, end = m - k; // idx: 1 - based
        return (int)(query(1, 0, n, bgn, end) / (m - 2 * k));
    }
    void insert(int idx, int l, int r, int v, long d) { // d: 
        cnt[idx] += d;
        sum[idx] += d * v;
        if (l == r) return ;
        int m = l + (r - l) / 2;
        if (v <= m)
            insert(idx << 1, l, m, v, d);       // 向左子树查询
        else insert(idx << 1 | 1, m+1, r, v, d);// 向右子树查询
    }
    long query(int idx, int l, int r, int bgn, int end) { // 线段中第 bgn 个到第 end 个
        if (l == r) { // 起始和结束最多出现2次此情况 ?
            int c = end - bgn + 1;
            return (long)c * l; //
        } else if (cnt[idx] == end - bgn + 1)
            return sum[idx];
        else {
            int m = l + (r - l) / 2;
            int cl = cnt[idx << 1];     // left child cnt
            // int cr = cnt[idx << 1 | 1];     // left child cnt
            if (cl >= end) // 搜索 左 子树
                return query(idx << 1, l, m, bgn, end); 
            else if (cl >= bgn) // 搜索 左 右 子树
                return query(idx << 1, l, m, bgn, cl) + query(idx << 1 | 1, m+1, r, 1, end - cl);
            else // cl < bgn, 搜索 右 子树
                return query(idx << 1 | 1, m+1, r, bgn - cl, end - cl);
        }
    }
#+END_SRC
**** 解题思路与分析: 三个TreeMap, 自定义TreeMap
     #+BEGIN_SRC java
    CusTreeMap [] ms;
    Deque<Integer> q;
    int m, k, n;
    public MKAverage(int m, int k) {
        this.m = m;
        this.k = k;
        q = new ArrayDeque<>();
        if (m - 2 * k > 0) {
            n = 3;
            ms = new CusTreeMap[n];
            ms[1] = new CusTreeMap(m - 2 * k);
        } else {
            n = 2;
            ms = new CusTreeMap[n];
        }
        ms[0] = new CusTreeMap(k);
        ms[n-1] = new CusTreeMap(k);
    }
    // 删除num，结果总是使mapList的小、中、大三个treemap依次填充。（先保证最小的treeMap填充、再保证中间的treeMap填充、最后是最大的填充）
    private void removeElement(int num) {
        boolean removed = false;
        for (int i = 0; i < n; i++) {
            if (!removed)
                removed = ms[i].remove(num);
            else { // 将后现一两个图中的最小元素向前一个图中挪动一个数值
                Integer minK = ms[i].pollFirst();
                if (minK == null) break;
                ms[i-1].add(minK);
            }
        }
    }
    public void addElement(int num) {
        if (q.size() == m) {
            int v = q.pollFirst();
            removeElement(v);
        }
        q.offerLast(num);
        Integer vtoAdd = num;
        for (int i = 0; i < n && vtoAdd != null; i++) 
            vtoAdd = ms[i].add(vtoAdd); // 记得这里返回的是： 如果图中已有k个元素，扔出来的最大键
    }
    public int calculateMKAverage() {
        if (q.size() < m || n < 3) return -1;
        return ms[1].avg();
    }
    class CusTreeMap {
        TreeMap<Integer, Integer> m;
        final int capacity;
        int size, sum;
        public CusTreeMap(int capacity) {
            m = new TreeMap<>();
            this.capacity = capacity;
        }
        public boolean remove(int key) {
            if (m.containsKey(key)) {
                m.put(key, m.get(key)-1);
                if (m.get(key) == 0) m.remove(key);
                sum -= key;
                size--;
                return true;
            }
            return false;
        }
        public Integer pollFirst() { // return key
            if (m.size() > 0) {
                int k = m.firstKey();
                // m.remove(k); // BUG: 你也不能用原始的TreeMap.remove()，因为它会移走所有的重复（如果这个元素存在重复的话）
                remove(k); // !!!
                return k;  // 这里没有自动更新 和 
                // return m.firstKey(); // BUG: 这里并没有真正移走这个元素，只是返回了第个元素的键
            }
            return null;
        }
        public Integer add(int key) { // 返回的是删除掉元素的键
            m.put(key, m.getOrDefault(key, 0) + 1); // 这里新填入的元素是否是最后一个元素，关系不大
            size++;
            sum += key;
            if (size > capacity) {
                int last = m.lastKey();
                m.put(last, m.get(last)-1);
                if (m.get(last) == 0) m.remove(last);
                sum -= last;
                size--;
                return last;
            }
            return null;
        }
        public int avg() {
            return sum / size;
        }
    }
     #+END_SRC
**** 解题思路与分析: 树状数组
- 数状数组的解法: 另外第一次看到别人 二分+树状数组也能求前k大的值。
#+BEGIN_SRC java
// We can have a queue to maintain m elements
// Use two Fenwick tree, 1 for count and 1 for prefix sum
// Do 2 times binary search for the first k elements and the last k elements by using the count from our first fenwick tree
// We can get the sum by subtrating the sum of first k elements and sum of last k element by using our second fenwick tree
Queue<Integer> q = new LinkedList<>();
FenWick fone, ftwo;
int [] cnt = new int [100010];
long sum = 0;
int m,k;
public MKAverage(int m, int k) {
    this.m = m;
    this.k = k;
    long A [] = new long [100010];
    long B [] = new long [100010];
    fone = new FenWick(A);
    ftwo = new FenWick(B);
}
public void addElement(int num) {
    q.add(num);
    sum += num;
    fone.update(num, 1);
    ftwo.update(num, num);
    cnt[num]++;
}
public int calculateMKAverage() {
    if (q.size() < m) return -1;
    while (q.size() > m) {
        int cur = q.poll();
        cnt[cur]--;
        sum -= cur;
        fone.update(cur, -1);
        ftwo.update(cur, -cur);
    }
    // binary search for the first k (there may be duplicated)
    int l = 0, r = cnt.length-1;
    int i = -1, j = -1; // pos1, pos2 
    while (l <= r) { // 二分查找总计数
        int m = (r + l) / 2;
        long count = fone.sumRange(0, m);
        if (count >= k) {
            i = m;
            r = m -1;
        } else l = m+1;
    }
    // binary search for the last k (there may be duplicated)
    l = 0;
    r = cnt.length-1;
    while (l <= r) {
        int m = l + (r-l)/2;
        long count = fone.sumRange(m, cnt.length-1);
        if (count >= k) {
            j = m;
            l = m + 1;
        } else r = m-1;
    }
    long sum1 = ftwo.sumRange(0,  i);
    long sum2 = ftwo.sumRange(j, cnt.length-1);
    long cnt1 = fone.sumRange(0, i);
    long cnt2 = fone.sumRange(j, cnt.length-1);
    if (cnt1 > k)
        sum1 -= i*(cnt1-k);
    if (cnt2 > k)
        sum2 -= j*(cnt2-k);
    long remain = sum - sum1 - sum2; // 总和， 减去两边最小最大各K个数的和
    return (int)(remain / (m-2*k));
}
class FenWick {
    long tree []; //1-index based
    long A [];
    long arr[];
    public FenWick(long [] A) {
        this.A = A;
        arr = new long [A.length];
        tree = new long [A.length + 1];
    }
    public void update(int i, int v) {
        arr[i] += v;
        i++;
        while (i < tree.length) {
            tree[i] += v;
            i += (i & -i); // 这是的原理细节再回去复习一下
        }
    }
    public long sumRange(int i, int j) {
        return pre(j+1)-pre(i);
    }
    public long pre(int i) {
        long sum = 0;
        while (i > 0) {
            sum += tree[i];
            i -= (i & -i);
        }
        return sum;
    }
}
#+END_SRC
- 其它比较有兴趣以的BST二叉树的解法，改天补起来
*** 315. Count of Smaller Numbers After Self - Hard
You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].
**** 解题思路与分析: 二分查找的插入排序
     #+BEGIN_SRC java
public List<Integer> countSmaller(int[] a) { // O(NlogN) 插入排序
    int n = a.length;
    List<Integer> ans = new ArrayList<>();
    List<Integer> list = new ArrayList<>(); // 新建一个list，用于排序
    int [] tmp = new int [n]; // 为了提高效率，新建一个数组型的返回结果
    for (int i = n-1; i >= 0; i--) {
        int v = a[i];       // 将当前数字插入到新建list中, 使用二分查找找到插入位置
        int l = 0, r = list.size()-1; // l: left; r: right 从排好序的list中二分查找正确的插入位置
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (v <= list.get(m)) r = m-1;
            else l = m + 1;
         }
        list.add(l, v); // 将当前数字插入到相应位置，保证list升序排列
        tmp[i] = l; // 当前位置前所有数字均小于当前数字，将个数加入返回结果
    }
    for (Integer v : tmp) ans.add(v);
    return ans;
}
     #+END_SRC
**** 解题思路与分析: 数状数组
- 官方题解： https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-s-7/
     #+BEGIN_SRC java
private int[] c;
private int[] a; // 离散化、去重复 后的数组
public List<Integer> countSmaller(int[] nums) {
    List<Integer> ans = new ArrayList<Integer>(); 
    discretization(nums);
    init(nums.length + 5);
    for (int i = nums.length - 1; i >= 0; --i) {
        int id = getId(nums[i]);
        ans.add(query(id - 1));
        update(id);
    }
    Collections.reverse(ans);
    return ans;
}
private void init(int length) {
    c = new int[length];
    Arrays.fill(c, 0);
}
private int lowBit(int x) {
    return x & (-x);
}
private void update(int pos) {
    while (pos < c.length) {
        c[pos] += 1;
        pos += lowBit(pos);
    }
}
private int query(int pos) {
    int ret = 0;
    while (pos > 0) {
        ret += c[pos];
        pos -= lowBit(pos);
    }
    return ret;
}
private void discretization(int[] nums) { // 离散化、去重复 ？
    Set<Integer> set = new HashSet<Integer>(Arrays.stream(nums).boxed().collect(Collectors.toList()));
    int size = set.size();
    a = new int[size];
    int index = 0;
    for (int num : set) a[index++] = num;
    Arrays.sort(a);
}
private int getId(int x) {
    return Arrays.binarySearch(a, x) + 1; // 
}
     #+END_SRC
**** 解题思路与分析: 归并排序 todo 补上

*** 699. Falling Squares - Hard
There are several squares being dropped onto the X-axis of a 2D plane.

You are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.

Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.

After each square is dropped, you must record the height of the current tallest stack of squares.

Return an integer array ans where ans[i] represents the height described above after dropping the ith square.
**** 解题思路与分析: O(N^2) 本能土办法
方块的大小不是固定的，有可能很大，但是不管方块再大，只要有一点点部分搭在其他方块上面，整个方块都会在上面，并不会掉下来，让我们求每落下一个方块后的最大高度。我们知道返回的是每落下一个方块后当前场景中的最大高度，那么返回的数组的长度就应该和落下方块的个数相同。所以我们可以建立一个heights数组，其中heights[i]表示第i块方块落下后所在的高度，那么第i块方块落下后场景的最大高度就是[0, i]区间内的最大值。那么我们在求出heights数组后，只要不停返回[0, i]区间内的最大值即可。继续来看，这道题的难点就是方块重叠的情况，我们先来想，如果各个方块不重叠，那么heights[i]的高度就是每个方块自身的高度。一旦重叠了，就得在已有的基础上再加上自身的高度。那么我们可以采用brute force的思想，对于每个一个下落的方块，我们都去看和后面将要落下的方块有没有重叠，有的话，和后面将要落下的方块的位置相比较，取二者中较大值为后面要落下的方块位置高度heights[j]。判读两个方块是否重叠的方法是如果方块2的左边界小于方块1的右边界，并且方块2点右边界大于方块1点左边界。就拿题目中的例子1来举例吧，第一个下落的方块的范围是[1, 3]，长度为2，则heights[0]=2，然后我们看其和第二个方块[2, 5]是否重叠，发现是重叠的，则heights[1]更新为2，再看第三个方块[6, 7]，不重叠，不更新。然后第二个方块落下，此时累加高度，则heights[1]=5，再看第三个方块，不重叠，不更新。然后第三个方块落下, heights[2]=1。此时我们heights数组更新好了，然后我们开始从头遍历，维护一个当前最大值curMax，每次将[0, i]中最大值加入结果res即可，
#+BEGIN_SRC java
public List<Integer> fallingSquares(int[][] a) {
    List<Integer> ans = new ArrayList<>();
    int n = a.length, max = 0;
    int [] hi = new int [n]; // 表示第 i 块方块落下后所在的高度
    for (int i = 0; i < n; i++) {
        int h = a[i][1], l = a[i][0], r = a[i][0] + h;
        hi[i] += h;
        for (int j = i+1; j < n; j++) {
            int ll = a[j][0], rr = ll + a[j][1];
            // [[6,1],[9,2],[2,4]] 因为不能保证是从左往下延x轴顺序掉落，所以加上l < rr 也狠重要 确保不管左右边有交叠
            if (ll < r && rr > l) // 保证j在i的右边，并且有重叠区域
                hi[j] = Math.max(hi[j], hi[i]);
        }
        max = Math.max(max, hi[i]);
        ans.add(max);
    }
    return ans;
}
#+END_SRC
**** 解题思路与分析： 线段树 + 离散化

想象x xx轴是地面，如果某个方块掉落的过程中遇到了之前的某个方块（擦边而过不算），则该方块会叠到上面。现在给定一个长n nn数组A AA，A [ i ] A[i]A[i]存了第i ii个掉落的方块的信息，其中A [ i ] [ 0 ] A[i][0]A[i][0]表示它的左下角的x xx坐标，A [ i ] [ 1 ] A[i][1]A[i][1]表示它的边长。要求返回一个长n nn数组B BB，使得B [ i ] B[i]B[i]表示在A [ i ] A[i]A[i]掉落之后，当前所有方块的最高点的y yy坐标。

思路是线段树 + 离散化。可以将x xx坐标离散化，这样可以节省存储空间（离散化的过程其实就是将一个数组d dd排序后去重，然后将每个数映射到它的下标。这样在线段树建树的时候，就只需维护[ 0 , l d − 1 ] [0,l_d-1][0,l_d−1]这个区间的信息就行了，这会极大减少线段树的空间消耗，也从而会减少要做的操作的时间消耗）。具体来说，给定一个将要下落的方块，比如该方块的左端点的x xx坐标和右端点的x xx坐标分别是a aa和b bb，边长是c cc，那么我们需要实现两个操作，第一是查询( a , b ) (a,b)(a,b)里的最大值M MM（注意这里查询的是开区间( a , b ) (a,b)(a,b)的最大值，因为下落的方块擦着另一个方块的边的话，是不会叠上去的），另一个是将[ a , b ] [a,b][a,b]里所有值都变成M + c M+cM+c。本质上是要求一个数据结构可以查询区间最大值，以及将区间修改为某一值，这可以用线段树 + 懒标记来做到。在离散化之后，为了使得区间( a , b ) (a,b)(a,b)非空（注意这里a aa和b bb都是离散化之后的值，此时( a , b ) = [ a + 1 , b − 1 ] (a,b)=[a+1,b-1](a,b)=[a+1,b−1]），我们可以在离散化的时候将方块的中点也加入一起做离散化，但是这会导致中点变成非整数，这里将原坐标乘以2 22就行了。

[[./pic/699.png]]

#+BEGIN_SRC java
public List<Integer> fallingSquares(int[][] a) { // 需要对数据进行离散化处理，离散化的目的是为了线段树处理起来方便；离散的是x轴的横坐标
    List<Integer> x = new ArrayList<>();
    for (int [] v : a) {
        int i = v[0], j = i + v[1];
        x.add(i * 2);
        x.add(j * 2);
        x.add(i + j);
    }
    x = getUniques(x);
    MaxSeg maxSeg = new MaxSeg(x.size());
    List<Integer> ans = new ArrayList<>();
    for (int [] v : a) {
        int i = v[0], j = i + v[1];
        i = getIdxInList(i * 2, x);
        j = getIdxInList(j * 2, x);
        int h = maxSeg.query(1, i+1, j-1);
        maxSeg.update(1, i, j, h + v[1]);
        ans.add(maxSeg.query());
    }
    return ans;
}
int getIdxInList(int v, List<Integer> list) { // 找到 x 在离散化之后的值是多少，其实就是求 xs 里 x 的下标，可以二分来找到
    int l = 0, r = list.size()-1;
    while (l < r) {
        int m = l + (r - l) / 2;
        if (list.get(m) >= v) r = m;
        else l = m + 1;
    }
    return l;
}
List<Integer> getUniques(List<Integer> l) {
    l.sort(Integer::compareTo);
    int j = 0; // 返回结果链表的下标 idx
    for (int i = 0; i < l.size(); i++) {
        if (i == 0 || l.get(j-1) != l.get(i))
            l.set(j++, l.get(i));
    }
    return l.subList(0, j);
}
class MaxSeg {   // 实现一下带懒标记的线段树 : 这棵树好强大
    class Node { // v 是 [l, r] 区间的最大值， lazy 是懒标记
        int l, r, v, lazy;
        public Node(int l, int r) {
            this.l = l;
            this.r = r;
        }
    }
    Node [] tree;
    public MaxSeg(int n) {
        tree = new Node[n << 2]; // n * 2 * 2
        buildTree(1, 0, n-1);    // 下标从 1 开始 自顶向下
    }
    void buildTree(int i, int l, int r) {
        tree[i] = new Node(l, r);
        if (l == r) return;
        int m = l + r >> 1; // (l + r) / 2
        buildTree(i << 1, l, m);
        buildTree(i << 1 | 1, m+1, r);
    }
    void pushUp(int i) { // 自底向上：自左、右叶子节点向顶更新最大值，取左右节点的最大值
        tree[i].v = Math.max(tree[i << 1].v, tree[i << 1 | 1].v);
    }
    void pushDown(int i) { // 懒标记向底、叶子方向推进一层
        int c = tree[i].lazy;
        if (c != 0) { // 打有懒标记
            tree[i].lazy = 0;
            tree[i << 1].v = tree[i << 1 | 1].v = c;
            tree[i << 1].lazy = tree[i << 1 | 1].lazy = c;
        }
    }
    void update(int i, int l, int r, int c) {   // 自顶向下传递懒标记，再自底向上更新父节点的值：取左右子节点的最大值
        if (l <= tree[i].l && tree[i].r <= r) { // 任务不需要下发，可以用懒标记懒住
            tree[i].v = tree[i].lazy = c; // 这里 tree[i].v = tree[i].lazy = c : c 是想要更新到的新值v, 用它来更新懒标记和v值
            return ;
        }
        pushDown(i);  // 任务不得不下发，则先下发给两个孩子
        int m = tree[i].l + tree[i].r >> 1;
        if (l <= m) update(i << 1, l, r, c);  // 回归调用，下传更新至左右子节点
        if (m + 1 <= r) update(i << 1 | 1, l, r, c);
        pushUp(i);  // 孩子完成了任务，再修改自己的值
    }
    int query(int i, int l, int r) {
        if (l <= tree[i].l && r >= tree[i].r) return tree[i].v;
        pushDown(i);
        int ans = 0, m = tree[i].l + tree[i].r >> 1;
        if (l <= m) ans = Math.max(ans, query(i << 1, l, r));
        if (m + 1 <= r) ans = Math.max(ans, query(i << 1 | 1, l, r));
        return ans;
    }
    int query() {
        return tree[1].v;
    }
}
#+END_SRC
**** 解题思路与分析: 超简洁版的线段树，效率奇高
- http://www.noobyard.com/article/p-sxwzvpgp-nz.html
- 去找一下原文件中的优化步骤
     #+BEGIN_SRC java
private class Node { // 描述方块以及高度
    int l, r, h, maxR;
    Node left, right;
    public Node(int l, int r, int h, int maxR) {
        this.l = l;
        this.r = r;
        this.h = h;
        this.maxR = maxR;
        this.left = null;
        this.right = null;
    }
}
public List<Integer> fallingSquares(int[][] positions) {
    List<Integer> res = new ArrayList<>(); // 建立返回值
    Node root = null; // 根节点，默认为零
    int maxH = 0; // 目前最高的高度
    for (int[] position : positions) {
        int l = position[0]; // 左横坐标
        int r = position[0] + position[1]; // 右横坐标
        int e = position[1]; // 边长
        int curH = query(root, l, r); // 目前区间的最高的高度
        root = insert(root, l, r, curH + e);
        maxH = Math.max(maxH, curH + e);
        res.add(maxH);
    }
    return res;
}
private Node insert(Node root, int l, int r, int h) {
    if (root == null) return new Node(l, r, h, r);
    if (l <= root.l)
        root.left = insert(root.left, l, r, h);
    else
        root.right = insert(root.right, l, r, h);
    root.maxR = Math.max(r, root.maxR); // 最终目标是仅仅须要根节点更新 maxR
    return root; // 返回根节点
}
private int query(Node root, int l, int r) {
    // 新节点的左边界大于等于目前的maxR的话，直接获得0，不须要遍历了
    if (root == null || l >= root.maxR) return 0; 
    int curH = 0; // 高度
    if (!(r <= root.l || root.r <= l)) // 是否跟这个节点相交
        curH = root.h;
    // 剪枝
    curH = Math.max(curH, query(root.left, l, r));
    if (r > root.l)
        curH = Math.max(curH, query(root.right, l, r));
    return curH;
}
     #+END_SRC
*** 1483. Kth Ancestor of a Tree Node - Hard 倍增法 binary lifting
 You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.

The kth ancestor of a tree node is the kth node in the path from that node to the root node.

Implement the TreeAncestor class:

TreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.
int getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.
**** 解题思路与分析: 倍增 binary lifting
     
     [[./pic/1483.png]]

- 预处理时间复杂度O(nlogn)，每次询问时间O(logn)，空间O(nlogn)。

     #+BEGIN_SRC java
    private int [][] p;
    private int log;
    public TreeAncestor(int n, int[] parent) {
        log = (int) (Math.log(n - 1) / Math.log(2)) + 1;
        p = new int[n][log];
        for (int i = 0; i < parent.length; i++) // 初始化p数组
            p[i][0] = parent[i];
        for (int i = 1; i < log; i++) // 按公式递推p数组
            for (int j = 0; j < n; j++) 
                if (p[j][i-1] != -1) 
                    p[j][i] = p[p[j][i-1]][i-1];
                else p[j][i] = -1;
    }
    public int getKthAncestor(int node, int k) {
        int pow = 0;
        while (k > 0) {
            if (pow >= log || node == -1) return -1;
            if ((k & 1) == 1) 
                node = p[node][pow];
            k >>= 1;
            pow++;
        }
        return node;
    }
     #+END_SRC
**** 解题思路与分析
     #+BEGIN_SRC java
    Map<Integer, List<Integer>> adj;
    int [][] par;
    public TreeAncestor(int n, int[] parent) {
        par = new int [n][30]; // 30 , 16: 不能证它是一棵很平衡的二叉树
        adj = new HashMap<>();
        for (int i = 0; i < n; i++) {
            Arrays.fill(par[i], -1);
            adj.put(i, new ArrayList<>());
        }
        for (int i = 0; i < parent.length; i++) 
            if (parent[i] != -1) {
                adj.get(parent[i]).add(i); // 自顶向下： 父 --》子节点
                par[i][0] = parent[i];     // 每个子节点的第一个父节点（2^0 = 1），即为父节点 // 自底向上： 子节点： 2^0父节点、 2^1节点、 2^2节点
            }
        dfs(0);
    }
    public int getKthAncestor(int node, int k) {
        for (int i = 0; k > 0; i++, k >>= 1) // k /= 2
            if ((k & 1) == 1) {
                node = par[node][i];
                if (node < 0) return -1;
            }
        return node;
    }
    private void dfs(int idx) { // 自顶向下：从父节点遍历子节点
        for (int i = 1; par[idx][i-1] >= 0; i++) // 穷追塑源：一直找到整棵树的根节点： 0
            par[idx][i] = par[par[idx][i-1]][i-1]; // 这里多想想
        for (int next : adj.get(idx)) 
            dfs(next);
    }
     #+END_SRC
*** 236 二叉树的最近公共祖先

*** 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits - Hard BIT树状数组 
You are given a string num representing the digits of a very large integer and an integer k. You are allowed to swap any two adjacent digits of the integer at most k times.

Return the minimum integer you can obtain also as a string.
**** 解题思路与分析
     #+BEGIN_SRC java
public String minInteger(String t, int k) {
    int n = t.length();
    t = " " + t;
    char [] s = t.toCharArray();
    ArrayDeque<Integer> [] q = new ArrayDeque [10];
    for (int i = 1; i <= n; i++) {
        int j = s[i] - '0';
        if (q[j] == null) q[j] = new ArrayDeque<>();
        q[j].offerLast(i);
    }
    BIT bit = new BIT(n);
    StringBuilder sb = new StringBuilder();
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < 10; j++) { // 从小数值往大数值遍历
            if (q[j] == null || q[j].isEmpty()) continue;
            int top = q[j].peekFirst(), pos = top + bit.sum(top); // pos是最优解的位置，最优解的位置是原来的位置加上偏移量
            if (pos - i <= k) {
                k -= pos - i;
                sb.append(j);
                q[j].pollFirst();
                bit.add(1, 1); // 更新[1, t)这段的值每个加1，即向右偏移1位.为什么要 从1开始更新：假装每次都移动到最前端，方便计算 ?
                bit.add(top, -1);
                break;
            }
        }
    }
    return sb.toString();
}
class BIT { // 开一个树状数组类，维护每个位置的字符的向右的偏移量 ? 向左偏移量
    private int n;
    private int [] a;
    public BIT(int n) {
        this.n = n;
        this.a = new int [n+1];
    }
    public void add(int idx, int v) { // 只有发生偏移，才移动某段区间的值
        while (idx <= n) {
            a[idx] += v;
            idx += lowbit(idx);
        }
    }
    public int sum(int idx) { // 得到以 i 为下标1-based的所有子、叶子节点的和， 也就是[1, idx]的和，1-based
        int ans = 0;
        while (idx > 0) {
            ans += a[idx];
            idx -= lowbit(idx);
        }
        return ans;
    }
    int lowbit(int x) {
        return x & -x;
    }
}
     #+END_SRC

** 求最大最小值、位操作值的线段树 
- *【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】*
** 3187 Peaks in Array 
A peak in an array arr is an element that is greater than its previous and next element in arr.

You are given an integer array nums and a 2D integer array queries.

You have to process queries of two types:

queries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].

queries[i] = [2, indexi, vali], change nums[indexi] to vali.

Return an array answer containing the results of the queries of the first type in order.

Notes: The first and the last element of an array or a subarray cannot be a peak. 
*** 【解法一: 最笨BIT】：亲爱的表哥的活宝妹，一个晚上的【笨折腾】：改一晚上一个破烂题目的所有【BUG】，现在，把BIT 基础，爬清楚了吗？！！！
#+BEGIN_SRC java
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 亲爱的表哥的活宝妹，笨宝妹，怎么去想这个破烂题目呢？？？看来，亲爱的表哥的笨宝妹，哪怕笨办法，还是能够试着解解破烂题目滴。。。
// 亲爱的表哥的活宝妹，知道，这个破烂题目，虽然刚【抄过答案不久】，可是还是彻底忘记了，只要借助 test case 来帮助分析了。。。
public class BIT {
    // 亲爱的表哥的活宝妹，还没能、自己分析出：为什么，需要 2 个、破烂BIT 树状数组？？
    // 本题：【实时更新】，2 种操作，更新有效1, 和或，擦除存在，更改为 0
    int [] f;
    int n;
    public BIT(int n) {
        this.n = n;
        // f: 标记【1,N-1】下标元素，【0/1】是否为 peak
        f = new int [n]; // 这里长度 N 就足够了，插值只在【1,N-2】+1

    }
    // 添加、删除：元素。主要，先考虑：如果是 -1
    public void add(int i, int op) {  // 【单点更新】：相当于 insert|update(int i, int v)
        while (i < n) {
            f[i] += op;
            i += lowBit(i);
        }
    }
    public int query(int i) { // 求【1,i】区间和
        int r = 0;
        while (i > 0) {
            r += f[i];
            i -= lowBit(i);
        }
        return r;
    }
    int lowBit(int x) {
        return x & -x;
    }
}        
public List<Integer> countOfPeaks(int[] a, int[][] qs) {
    int m = qs.length, n = a.length;
    Set<Integer> s = new HashSet<>(); // 为什么：需要这个？【纪录备案】：为后续、准备一个参照
    BIT t = new BIT(n);
    // 数据预处理：遍历一次数组, 在不作任何下标值的更改时，填充初始数据. 算是【静态、离线、数据】？
    for (int i = 1; i < n-1; i++)  // 遍历：【1,n-2】
        if (a[i-1] < a[i] && a[i] > a[i+1]) {
            t.add(i+1, 1);
            s.add(i);
        }
    List<Integer> li = new ArrayList<>();
    for (int [] q : qs) {
        if (q[0] == 1) { // 简单查询：闭区间【l,r】的【区间和】
            int l = q[1], r = q[2];  // 开区间（l,r）
            if (l + 2 > r) li.add(0);
            else li.add(t.query(r) - t.query(l+1));
            continue;
        }
        // queries[i] = [2, index_i, val_i]
        int i = q[1], v = q[2];
        // if (v == a[i] || i == n-1) continue; // 无效修改。【写错了】：前趋效应，当 i==n-1 会对 i=n-2 造成影响
        if (v == a[i]) continue; // 无效修改
        // 一段分析：对后续 i+1 节点的影响 
        int op = 0;
        // if (i == 0) { // 它，仅只对、后序，有影响：笨宝妹，有影响，是要分析的。。
        if ((i == 0 && n > 1 || i < n-2) && (s.contains(i+1) && v >= a[i+1] || !s.contains(i+1) && v < a[i+1] && a[i+1] > a[i+2]))
            if (s.contains(i+1)) {
                op--;
                s.remove(i+1);
            } else {
                op++;
                s.add(i+1);
            }
        if (op != 0) 
            t.add(i+2, op);
        if (i == 0) {
            a[i] = v;
            System.out.println(Arrays.toString(a));
            continue;
        }
        // 分析：【单点更新】的效果效应：它不仅仅只对 i 产生效应，还可能会对 i-1 产生效应。。。
        // 先，分析对 i-1 的【改变效应】: 当前下标的值变大使 i-1 失效为0, 或，当前下标的值变小使 i-1 有效为 1
        op = 0;
        if (i > 1 && (s.contains(i-1) && a[i-1] <= v || !s.contains(i-1) && a[i-2] < a[i-1] && a[i-1] > v))
            if (s.contains(i-1)) {
                op--;
                s.remove(i-1);
            } else {
                op++;
                s.add(i-1);
            }
        if (op != 0) 
            t.add(i, op);
        // 再，分析，对当将下标 i 的影响
        if (i == n-1) {
            a[i] = v;
            System.out.println(Arrays.toString(a));
            continue;
        }
        // 分析：对当前节点 i 的效应
        op = 0;
        if (s.contains(i) && (a[i-1] >= v || v <= a[i+1])) {
            s.remove(i);
            op--; // -1
        } else if (i < n-1 && !s.contains(i) && a[i-1] < v && v > a[i+1]) {
            s.add(i);
            op++; // 1
        }
        if (op != 0) { // 对 i 有效应
            t.add(i+1, op);
        }
        a[i] = v;
    }
    return li;
}
#+END_SRC
*** 【解法二：区间加区间和 BIT】：明天，接着写这个
- *【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】*
- 亲爱的表哥的活宝妹，记错了，【区间加区间和 BIT】，可能不是这个题目，还是疲【破烂题解】修改掉了它自己的答案？去翻
    #+BEGIN_SRC java
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 亲爱的表哥的活宝妹，半点儿也想不起来：当初2 个BIT 数组的思路了。。。看提示，看完提示，再去想：怎么解？。。提示讲得不清楚，还得去看题解的分析。。。
// 亲爱的表哥的活宝妹的脑袋，【好疯呀】。。。亲爱的表哥的活宝妹，记错题目了？
// 亲爱的表哥的活宝妹，明明记得：前不久，有一个使用【2 个BIT】来解的题目，居然不是这一个？【TODO】，既然不是这个题目，就去、一定把那个题目找出来。。。
// 亲爱的表哥的活宝妹，觉得，是这个【破烂题解】，把它的【破烂题解】给修改了？现在这个【破烂题解】的思路，【无限简单】，轻轻松松写完。。。
// 【TODO】：既然，亲爱的表哥的活宝妹，感觉像是记错了，既然不是这个题目，就去、一定把那个题目找出来。。。
class Bit {
    int [] f; // 【0/1】单点值：标记，一个下标序号的【存在与否】或说有效性
    int n;
    public Bit(int n) { // 实际插入值范围：【1,n-2】＋1【不是永远要＋1!!】==> 【2,n-1】。维度够用
        this.n = n;
        f = new int [n];
    }
    // 【单点修改】：【自底向上】，效果累加到、各后续父节点
    void update(int i, int v) {
        for (; i < n; i += lowBit(i))
            f[i] += v;
    }
    // 【区间和】：【1,i】区间和. 【自顶向下】：自最顶最右单点或小区间，累加其前段小区间，去求和累加区间和
    int preSum(int i) { 
        int r = 0;
        while (i > 0) {
            r += f[i];
            // 下面两行，效果等价：
            // i -= lowBit(i);
            i &= (i-1); // i = (i & (i-1));
        }
        return r;
    }
    // 【区间，求：和、积、异或值】等
    int query(int l, int r) { // 求区间【l,r】的和
        if (l > r) return 0; // 这个条件要：当平移左右端点时，可能发生 l>r
        return preSum(r) - preSum(l-1);
    }
    int lowBit(int x) { // 【破烂位操作】：不知道它回字的几样写法。。
        return x & -x;
    }
}
public List<Integer> countOfPeaks(int[] a, int[][] qs) {
    int n = a.length;
    Bit f = new Bit(n); // 实际插入值范围：【1,n-2】＋1==> 【2,n-1】
    Set<Integer> s = new HashSet<>(); // 【 bit 树状数组】中：有效点集
    // 【BIT 树状数组】数据预处理：填充初始数据
    for (int i = 1; i < n-1; i++) 
        if (a[i-1] < a[i] && a[i] > a[i+1]) {
            // 当【BIT 树状数组】里的下标，有效范围，落在【1,n-1】，就不需要，再永远＋1 了呀。。。
            f.update(i, 1); // <<<<<<<<<<<<<<<<<<<< i+1: 笨宝妹，这里，为什么永远 +1？
// 下面：不曾【纪录备案】：添加过的【下标集合】Set<Integer> s, 后面就又【暴力了 2 遍】！！
            s.add(i);
        }
    // 【在线解题】：实时动态更新数组、实时动态、维护BiT 树状数组
    List<Integer> li = new ArrayList<>();
    for (int [] q : qs) {
        if (q[0] == 1) {
            // 答案要求：开区间（q[1],q[2]），不包括2 个端点
            // 即：     闭区间【q[1]+1,q[2]-1】，
            // 对应【树状数组】的下标为：【q[1]+2, q[2]】；不加1 的话是，如上如下
            li.add(f.query(q[1]+1, q[2]-1));
            continue;
        }
        int i = q[1], v = q[2];
        if (a[i] == v) continue;
        // 【实时更新】：a[i], 仅只影响【i-1,i,i+1】三个点，且在【1,n-2】范围内
        int l = Math.max(1, i-1), r = Math.min(n-2, i+1); // 界定范围
        // 先，消除——完全擦除，之前【预处理】时，可能最多存在的3 个点
        for (int j = l; j <= r; j++) 
            if (s.contains(j)) {
                s.remove(j);
                f.update(j, -1); 
            }
        // 再：更新数据
        a[i] = v;
        // 再：更新，题解数据结构，对数据变更的维护
        for (int j = l; j <= r; j++)
            if (a[j-1] < a[j] && a[j] > a[j+1])
                if (!s.contains(j)) {
                    f.update(j, 1);
                    s.add(j);
                }
    }
    return li;
}
#+END_SRC

* BIT树状数组
- *【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】*
- 加个典型题目 
