import com.ListNode;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.*;
import java.util.stream.*;
import java.util.stream.Collectors;
import java.util.HashSet;
import java.util.Set;
import static java.util.stream.Collectors.toMap;

public class cmp {
    public static class Solution {
		// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】

		// // 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// // 这个题目狠简单：就是从右往左，在 m 条 m 个有序链表里，从尾往前移
		// public long maxSpending(int[][] a) {
		// 	int m = a.length, n = a[0].length;
		// 	int [] r = new int [m];
		// 	Arrays.fill(r, n-1);
		// 	System.out.println(Arrays.toString(r));
		// 	Queue<Integer> q = new PriorityQueue<>((x, y)->a[x][r[x]] - a[y][r[y]]);
		// 	for (int i = 0; i < m; i++)
		// 		q.offer(i);
		// 	long ans = 0; int t = 1;
		// 	for (int i = 0; i < m*n; i++) {
		// 		System.out.println("\n i: " + i);
		// 		int j = q.poll(); // m 行的下标
		// 		// System.out.println("j: " + j);
		// 		// System.out.println("a[j][r[j]]: " + a[j][r[j]]);
		// 		ans += (long)a[j][r[j]] * t;
		// 		t++;
		// 		r[j]--;
		// 		if (r[j] >= 0)
		// 			q.offer(j); // 这里，应该会触发优先队列重新排序
		// 	}
		// 	return ans;
		// }

		// // 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// public int distributeCandies(int n, int k) {// k: limit: 排列组合题，讨厌这个题目，不写这个了。。
		// 	int [][] f = new int [3][k+1];
		// 	int [][] r = new int [3][k+1]; // 先前的累积和
		// 	for (int j = 0; j <= Math.min(n, k); j++) {
		// 		f[0][j] = j;
		// 		r[0][j] = j;
        //     }
		// 	for (int i = 1; i < 3; i++) {
		// 		System.out.println("i: " + i);
		// 		// System.out.println("Math.min(n-r[i-1][j], k): " + Math.min(n-r[i-1][j], k));
		// 		for (int j = 0; j <= Math.min(n-r[i-1][j], k); j++) {
		// 			f[i][j] = j;
		// 			r[i][j] = r[i-1][j] + j;
		// 		}
		// 	}
		// 	int ans = 0;
		// 	for (int i = 0; i <= k; i++)
		// 		ans += f[i][0] * f[i][1] * f[i][2];
		// 	return ans;
		// }
// 早上懒得写上面的题

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int maximumStrongPairXor(int[] a) {
		// 	int n = a.length, r = 0;
		// 	for (int i = 0; i < n; i++)
		// 		for (int j = 0; j < n; j++)
		// 			if (Math.abs(a[i] - a[j]) <= Math.min(a[i], a[j]))
		// 				r = Math.max(r, a[i] ^ a[j]);
		// 	return r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public List<String> findHighAccessEmployees(List<List<String>> lli) {
		// 	List<String> r = new ArrayList<>();			
		// 	Map<String, List<String>> m = new HashMap<>();
		// 	for (List<String>  l : lli) 
		// 		m.computeIfAbsent(l.get(0), z -> new ArrayList<>()).add(l.get(1));
		// 	for (Map.Entry<String, List<String>> en : m.entrySet()) {
		// 		String k = en.getKey();
		// 		List<String> v = en.getValue();
		// 		if (v.size() < 3) continue;
		// 		Collections.sort(v);
		// 		boolean valid = false;
		// 		for (int j = 1; j+1 < v.size(); j++) {
		// 			if (valid(v.get(j-1), v.get(j)) && valid(v.get(j), v.get(j+1)) && valid(v.get(j-1), v.get(j+1))) {
		// 				valid = true;
		// 				break;
		// 			}
		// 		}
		// 		if (valid) r.add(k);
		// 	}
		// 	return r;
		// } // 感觉，写这种乱题目，是浪费亲爱的表哥的活宝妹的生命！！
		// boolean valid(String s, String t) {
		// 	int ha = Integer.parseInt(s.substring(0,2)), hb = Integer.parseInt(t.substring(0,2));
		// 	int x = ha * 60 + Integer.parseInt(s.substring(2));
		// 	int y = hb * 60 + Integer.parseInt(t.substring(2));
		// 	return y - x < 60 && (ha != 23 || hb != 00);
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int minOperations(int[] a, int[] b) {
		// 	int m = a.length, n = b.length;
		// }

// 		// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		public int maximumStrongPairXor(int[] a) { // 二分查找，O(NlogN)
// 			int n = a.length;
// 			for (int v : a) {
// 				for (int j = 0; j < 20; j++) 
// 					if (((v >> j) & 1) == 1)
// 						m.computeIfAbsent(j, z -> new HashSet<>()).add(v);
// 			int l = 1, r = (int)(Math.pow(2, 20)-1), max = 0;
// 			for (int v : a) s.add(v);
// 			while (l <= r) {
// 				int m = l + (r - l) / 2;
// 				if (valid(m, a)) {
// 					max = Math.max(max, m);
// 					l = m+1;
// 				} else r = m-1;
// 			}
// 			return max;
// 		}
// 		Set<Integer> s = new HashSet<>();
// 		Map<Integer, Set<Integer>> m = new HashMap<>(); // 记每个位，存在的数，还是多 
// 		// 这个方法，要写得巧一点儿：就是遍历 v 的所有的数位, 那么这个题目就成了，选课I II 题型。。可是亲爱的表哥的活宝妹，忘记细节了。。
// 		// 选课题是：一个学期最多选几个学分，20 个数位里，哪些组合，出有效存在数，如何巧妙遍历等
// // 这个方法太复杂了，今天晚上不想写这个了：前面某个两根梯子支撑什么的题型，亲爱的表哥的活宝妹，要怎么才能写出那么所有数位的所有可能的数值？？
// 		boolean valid(int v, int [] a) { // 先把前面的题目，至少得解决一个掉，再想这个相对难一点儿的
// 			for (int i = 0; i < 20; i++) { // 这么遍历的规模还是太大了，感觉。。
// 				if (((v >> i) & 1) == 1) {
// 					for (int j : m.get(i)) {
// 						if ()
// 					}
// 				}
// 			}
// 			// for (int i = v; i >= 0; i = (i & (i-1))) { // 没有考虑，可能存在相同位的情况: 所以还要考虑，所有补位（20-bitCnt）位中，所有可能情况，两数同时存在的情况。。
// 			// 	if (s.contains(i) && s.contains(v ^ i) && Math.abs(v-(v^i)) <= Math.min(v, v^i)) return true;
// 			// 	for (int j = 0; j < 20; j++) {
// 			// 		if (r[j] > 0) continue;
// 			// 	}
// 			return false;
// 		}

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int findMinimumOperations(String s, String t, String o) {
		// 	if (s.length() == 1 && t.length() == 1 && o.length() == 1 && s.charAt(0) == t.charAt(0) && t.charAt(0) == o.charAt(0)) return 0;
		// 	if (!s.substring(0,1).equals(t.substring(0, 1)) || !t.substring(0, 1).equals(o.substring(0, 1))) return -1;
		// 	int m = s.length(), n = t.length(), x = o.length();
		// 	int i = 0, min = Math.min(m, Math.min(n, x));
		// 	while (i < min) {
		// 		if (s.charAt(i) != t.charAt(i) || t.charAt(i) != o.charAt(i)) break;
		// 		i++;
		// 	}
		// 	return s.length() - i + t.length() -i + o.length()-i;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 从右往左遍历，是个暴力死计算题。。。
		// public long minimumSteps(String t) {
		// 	int n = t.length(); char [] s = t.toCharArray();
		// 	ArrayDeque<Integer> q = new ArrayDeque<>(); // 升序排列
		// 	int i = n-1;
		// 	long r = 0;
		// 	while (i > -1 && s[i] == '1') i--;
		// 	if (i < 0) return 0;
		// 	while (i > -1) {
		// 		// 这里，认为， s[i]=0
		// 		while (i > -1 && s[i]-'0' == 0) {
		// 			q.offerFirst(i); // 从头，从左边添加
		// 			i--;
		// 		}
		// 		if (i < 0) return r;
		// 		if (s[i] == '1' && !q.isEmpty()) {
		// 			r += (long)(q.pollLast() - i);
		// 			q.offerFirst(i);
		// 		}
		// 		i--;
		// 	}
		// 	return r;
		// }

// 		// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		// 这个题目狠简单，感觉暴力遍历所有可能性都是可以的? n=[0,50]
// 		// 找两个数的 most-significant 位的下标
// 		static final int mod = (int)1e9 + 7; 
// 		public int maximumXorProduct(long a, long b, int idx) {
// 			int m = 64 - Long.numberOfLeadingZeros(a), n = 64 - Long.numberOfLeadingZeros(b);
// 			System.out.println("m: " + m);
// 			System.out.println("n: " + n);
// 			int [] r = new int [50];
// 			long base = 0l, mask = 0l; // mask 不能要
// 			for (int i = 49; i >= 0; i--) {// fd
// 				if (((a >> i) & 1) == 1 && ((b >> i) & 1) == 1)
// 					// r[i] = 1;
// 					mask |= (1 << i);
// 				else if (((a >> i) & 1) + ((b >> i) & 1) == 1) // 两个数这个位上不同
// 					r[i] = 1;
// 				// else if (idx > i) // 这个位上可以有1: 但是这不一定是最优解，它还需要把 ab 聚合收敛，以便乘积最大
// 				else if (idx > i && (i >= Math.max(m, n) || ((a >> i) & 1) == 0 && ((b >> i) & 1) == 0)) // 这个位上可以有1: 但是这不一定是最优解，它还需要把 ab 聚合收敛，以便乘积最大
// 					base += (long)(1 << i);
// 			}
// 			int o = Arrays.stream(r).sum();// 想把它收敛一下，遍历所有（1<o）种可能性，可是会超时。。
// // 感觉，这里最差情况 o=50, 除非是暴力，再从右往左数多少个位强制为1, 亲爱的表哥的活宝妹，这会儿想不出来了，改天再写
// 			return (int)((base ^ a) * (base ^ b) % mod);
// 		}

// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		public List<Integer> findWordsContaining(String[] words, char x) {
// 			List<Integer> l = new ArrayList<>();
// 			for (int i = 0; i < words.length; i++) 
// 				if (words[i].indexOf(x) != -1)
// 					l.add(i);
// 			return l;
// 		}

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int minimumCoins(int[] a) { // 这不是，【记忆化深搜】吗？
		// 	n = a.length; this.a = a; 
		// 	f = new Integer [n][n];
		// 	return dfs(0, -1);
		// }
		// Integer [][] f; int [] a;
		// int n;
		// int dfs(int i, int j) { // j: previous Paid idx
		// 	if (i >= n) return 0;
		// 	if (j > -1 && f[i][j] != null) return f[i][j];
		// 	int r = Integer.MAX_VALUE;
		// 	r = a[i] + dfs(i+1, i);// pay for ith item
		// 	if (j == -1 || i > j + j + 1) { // have to pay for this item
		// 		if (j > -1) f[i][j] = r;
		// 		return r;
		// 	}
		// 	for (int k = i; k <= j + j + 1 && k < n; k++) 
		// 		r = Math.min(r, Math.min(dfs(i+1, j), a[i] + dfs(i+1, i)));
		// 	if (j > -1) f[i][j] = r;
		// 	return r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 有点儿像【区间型动规】，可是感觉没有思路。先滚回去写那个烦死人不偿命的。。		
		// public int findMaximumLength(int[] nums) {
		// }
		
		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 这是个，什么把二维数组上的最大区间和，转化为一维最大区间和，之类的题型。。
		// public int maximizeSquareHoleArea(int n, int m, int[] a, int[] b) {
		// 	int x = a.length, y = b.length, ans = 0;
		// 	int [] r = new int [x+2], c = new int [y+2];
		// 	r[0] = 1; r[x+1] = n+2;
		// 	c[0] = 1; c[y+1] = m+2;
		// 	// // 这个死题狠怪异，倒序排列，要求先去除后面的。。可是题目没有说清楚。所以题目比较坑人。。。
		// 	// Arrays.sort(a); Arrays.sort(b);
		// 	for (int i = 0; i < a.length; i++) r[i+1] = a[i]; // 复制过去
		// 	for (int i = 0; i < b.length; i++) c[i+1] = b[i];
		// 	System.out.println(Arrays.toString(r));
		// 	System.out.println(Arrays.toString(c));
		// 	// 遍历：一个维度上的。对这个维度上的每个可能取值，遍历另一维度上的所有可能性
		// 	TreeMap<Integer, Integer> t = new TreeMap<>();
		// 	t.put(r[0], 0);
		// 	int one = 0;
		// 	for (int i = 1; i < x+2; i++) {
		// 		for (Map.Entry<Integer, Integer> en : t.entrySet()) {
		// 			int k = en.getKey(), v = en.getValue();
		// 			one = r[i] - k;
		// 			if (one < 0) continue;
		// 			System.out.println("\n one: " + one);
		// 			if (one * one > ans) { // 在比先前的解，可能会优的前提下，才检查有效性. 横边一定有效，只检查竖边
		// 				// 同样的方式遍历竖边，是否存在一组可能的和为 one 边长的
		// 				if (valid(one, c)) {// 找到的第一个有效值，一定当前下标 i下，最优
		// 					ans = one * one;
		// 					System.out.println("ans: " + ans);
		// 					found = true;
		// 					break;
		// 				}
		// 			}
		// 		}
		// 		t.put(r[i], i); // 把当前横边点加进去
		// 	}
		// 	return ans;
		// }
		// boolean valid(int v, int [] r) {
		// 	int n = r.length;
		// 	Map<Integer, Integer> m = new HashMap<>();
		// 	m.put(r[0], 0);
		// 	for (int i = 1; i < n; i++) {
		// 		if (m.containsKey(r[i] - v)) return true;
		// 		m.put(r[i], i);
		// 	}
		// 	return false;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 亲爱的表哥的活宝妹，讨厌这个恶心死人不偿命的题目。。。这个思路不太对，讨厌今天的恶心死人不偿命的题目，今天晚上的跳过不写了
		// public boolean areSimilar(int[][] a, int k) {
		// 	int m = a.length, n = a[0].length;
		// 	k = k % n; this.k = k; 
		// 	if (n == 1 || k == 0) return true;
		// 	if (n % k != 0 && k != 1) return false;
		// 	o = n / k;
		// 	for (int i = 0; i < m; i++)
		// 		if (!kEleSubs(a[i])) return false;
		// 	return true;
		// }
		// int k, o;
		// boolean kEleSubs(int [] a) {
		// 	for (int i = 0; i < k; i++) {
		// 		int v = a[i];
		// 		for (int j = 1; j < o; j++)
		// 			if (a[i + k * j] != a[i]) return false;
		// 	}
		// 	return true;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int beautifulSubstrings(String t, int k) {
		// 	int n = t.length(); char [] s = t.toCharArray();
		// 	List<Integer> l = new ArrayList<>();
		// 	Set<Character> s = new HashSet<>(List.Of('a', 'e', 'i', 'o', 'u'));
		// 	for (int i = 0; i < n; i++)
		// 		if (s.contains(s[i])) l.add(i);
		// 	// 然后就是扫这个链条。今天的题目太恶心人了，不想写了
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public List<Integer> findPeaks(int[] a) {
		// 	int n = a.length;
		// 	List<Integer> r = new ArrayList<>();
		// 	for (int i = 1; i < n-1; i++) 
		// 		if (a[i] > a[i-1] && a[i] > a[i+1])
		// 			r.add(i);
		// 	return r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 看懂这个题目的提示思路了，可是还是不知道排序后，怎么算出各种和。。。
		// public int minimumAddedCoins(int[] a, int k) {
		// 	n = a.length; this.a = a; this.k = k; 
		// 	Arrays.sort(a);
		// }
		// int [] a;
		// int n, k;
		// int binarySearch(int v) {// 有重复
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 不喜欢最后一题，不是程序员的题目。。亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int numberOfSequence(int n, int[] sick) {
		// }

// 		// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		public int countCompleteSubstrings(String t, int v) {
// 			int n = t.length(); char [] s = t.toCharArray();
// 			int ans = 0, j = 0; // j: left i: right
// 			Map<Character, Integer> m = new HashMap<>(); // 统计频率
// 			int dif;
// 			Queue<int []> q = new PriorityQueue<>((x, y) -> y[0] - x[0]); // 最大堆 [dif, idx]
// 			boolean valid = true;
// 			for (int k = 1; k <= 26 && k * v <= n; k++) { // 26 种可能的片段长度
// 				q.clear();
// 				m.clear();
// 				j = 0;
// 				for (int i = 0; i < n; i++) { // 亲爱的表哥的活宝妹，快要忘记，【滑动窗口】题型，是怎么滑的了。。。
// 					if (i > 0) {// dif:
// 						dif = Math.abs(s[i] - s[i-1]);
// 						while (!q.isEmpty() && q.peek()[1] <= i - v * k) q.poll();// 扔出所有不合法——非本窗口的最大值 
// 						q.offer(new int [] {dif, i});
// 					}
// 					m.put(s[i], m.getOrDefault(s[i], 0) + 1);
// 					if (i - j > v * k -1) {
// 						m.put(s[j], m.get(s[j])-1);
// 						if (m.get(s[j]) == 0)
// 							m.remove(s[j]);
// 						++j;
// 					}
// 					if (i - j == v * k-1 && m.size() == k) {
// 						valid = true;
// 						for (int val : m.values()) // 这也是一个循环呀。。。昨天晚上就没想明白，大肉肥油蒙了脑袋。。。
// 							if (val != v) {
// 								valid = false;
// 								break; // 这里仍会执行下面的 while 呀。。
// // 亲爱的表哥的活宝妹，昨天傍晚吃了三根排骨炒葫萝卜，太油腻，昨天晚上的脑袋不转，今天早上还多睡了1.5 小时... 大肉好吃，可是也会慢性杀人。。。
// 							}
// 						while (!q.isEmpty() && q.peek()[1] <= i - v * k + 1) q.poll();// 扔出所有不合法——非本窗口的最大值 
// 						if (valid && (q.isEmpty() || q.peek()[0] <= 2)) 
// 							ans++;
// 					}
// 				}
// 			}
// 			return ans;
// 		}

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int[] findIntersectionValues(int[] a, int[] b) {
		// 	int m = a.length, n = b.length;
		// 	Set<Integer> sa = new HashSet<>(Arrays.stream(a).boxed().collect(Collectors.toList()));
		// 	Set<Integer> sb = new HashSet<>(Arrays.stream(b).boxed().collect(Collectors.toList()));
		// 	int [] r = new int [2];
		// 	for (int i = 0; i < m; i++) 
		// 		if (sb.contains(a[i])) r[0]++;
		// 	for (int i = 0; i < n; i++) 
		// 		if (sa.contains(b[i])) r[1]++;
		// 	return r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int removeAlmostEqualCharacters(String t) {
		// 	int n = t.length(), r = 0; char [] s = t.toCharArray();
		// 	int [][] f = new int [n][2];
		// 	Arrays.stream(f).forEach(z -> Arrays.fill(z, n));
		// 	f[0][0] = 0;
		// 	f[0][1] = 1;
		// 	for (int i = 1; i < n; i++) {
		// 		System.out.println("\n i: " + i);
		// 		r = Math.abs(s[i] - s[i-1]); // 这里，前一个字符是，可能变化了的！！
		// 		System.out.println("r: " + r);
		// 		// f[i][0] = f[i-1][0] + (r < 2 ? 1 : 0)
		// 		if (r < 2) {
		// 			// i-1, i: 一定至少有一个要变
		// 			f[i][0] = Math.min(f[i][0], f[i-1][1]);
		// 			f[i][1] = Math.min(f[i][1], Math.min(f[i-1][0], f[i-1][1]) + 1);
		// 		} else { // >= 2
		// 			f[i][0] = Math.min(f[i-1][0], f[i-1][1]);
		// 			f[i][1] = Math.min(f[i-1][0], f[i-1][1]) + 1;
		// 		}
		// 	}
		// 	return Math.min(f[n-1][0], f[n-1][1]);
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 最短距离题。今天不写这个题型了，改天这个题型也好好，如昨天晚上写【滑动窗口】般写一遍！！亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int numberOfSets(int n, int maxDistance, int[][] roads) {}

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 不想再写这个题目了，瓣得好烦人。。。就是感觉思路是清晰透彻的，可是爱吃大肉的亲爱的表哥的活宝妹，昨天傍晚、今天中午吃了大肉，就是瓣不清楚呀。。呜呜呜。。。
		// public int maxSubarrayLength(int[] a, int k) {
		// 	int n = a.length, ans = 1, j = 0; // j: right
		// 	Map<Integer, Integer> m = new HashMap<>();
		// 	for (int i = -1; i + ans <= n; i++) { // 遍历左端点；但是右端点J ，对所有的 i 仅自左向右遍历一次. 遍历到只可能＝最长长度，就可以停止了
		// 		System.out.println("\n i: " + i);
		// 		if (i >= 0 && i <= j) // 不需要清除：就是 m 可能有 (a[i], 0) 条目
		// 			m.put(a[i], m.get(a[i]) -1);
		// 		System.out.println("j 0: " + j);
		// 		while (j < n && m.getOrDefault(a[j], 0) + 1 <= k) {
		// 			m.put(a[j], m.getOrDefault(a[j], 0) + 1);
		// 			j++;
		// 		}
		// 		System.out.println("j: " + j);
		// 		ans = Math.max(ans, j-i-(j == n ? 1 : 0));
		// 		System.out.println("ans: " + ans);
		// 		if (j < n) {
		// 			m.put(a[j], m.get(a[j])-1);
		// 			--j;
		// 		}
		// 	}
		// 	return ans;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int countTestedDevices(int[] a) {
		// 	int n = a.length, r = 0;
		// 	for (int i = 0; i < n; i++) {
		// 		if (a[i] <= 0) continue;
		// 		r++;
		// 		for (int j = i+1; j < n; j++) {
		// 			if (a[j] == 0) continue;
		// 			a[j]--;
		// 		}
		// 	}
		// 	return r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public List<Integer> getGoodIndices(int[][] arr, int target) {
		// 	int n = arr.length, i = 0;
		// 	List<Integer> l = new ArrayList<>();
		// 	for (int [] v : arr) {
		// 		int a = v[0], b = v[1], c = v[2], d = v[3];
		// 		if (fastPowModM(fastPowModM(a, b, 10), c, d) == target)
		// 			l.add(i);
		// 		i++;
		// 	}
		// 	return l;
		// }
		// int fastPowModM(int base, int p, int mod) { // x^y%m: 先前有个快速幂，这里忘记了
		// 	long r = 1l;
		// 	while (p > 0) {
		// 		if (p % 2 == 1) 
		// 			r = r * base % mod;
		// 		base = base * base % mod;
		// 		p >>= 1;
		// 	}
		// 	return (int)r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public long countSubarrays(int[] a, int k) {
		// 	int n = a.length, max = Arrays.stream(a).max().getAsInt();
		// 	List<Integer> l = new ArrayList<>();
		// 	for (int i = 0; i < n; i++) 
		// 		if (a[i] == max) l.add(i);
		// 	if (l.size() < k) return 0;
		// 	int j = 0, m = l.size();
		// 	long r = 0;
		// 	for (int i = k-1; i < m; i++) {
		// 		r += (long)((i == m-1 ? n : l.get(i+1)) - l.get(i)) * (l.get(j) == 0 ? 1 : l.get(j)+1);
		// 		j++;
		// 	}
		// 	return r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int numberOfGoodPartitions(int[] a) {
		// 	int n = a.length;
		// 	Map<Integer, int []> m = new HashMap<>();
		// 	for (int i = 0; i < n; i++) {
		// 		int [] r = new int [] {-1, -1};
		// 		if (m.containsKey(a[i]))
		// 			r = m.get(a[i]);
		// 		if (r[0] == -1) r[0] = i;
		// 		else r[1] = i;
		// 		m.put(a[i], r);
		// 	}
		// 	// System.out.println("m.size(): " + m.size());
		// 	// for (Map.Entry<Integer, int []> en : m.entrySet()) {
		// 	// 	System.out.print(en.getKey() + ": ");
		// 	// 	System.out.println(Arrays.toString(en.getValue()));
		// 	// }
		// 	// 然后，应该是个什么【动规】的思路，可是今天不想再写这些题目了，今天写得太多了。。。
		// 	return 0;
		// }
		// 	// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
}
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
    public static void main (String[] args) {
		Solution s = new Solution ();

		int [] a = new int [] {1,2,1,3};
		System.out.println(Arrays.toString(a));

		int r = s.numberOfGoodPartitions(a);
		System.out.println("r: " + r);
    }
}
// ListNode head = new ListNode(a[0]); 
// head.buildList(head, a);
// head.printList(head);
// TreeNode rr = new TreeNode(a[0]);
// rr.buildTree(rr, a);
// rr.levelPrintTree(rr);
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！