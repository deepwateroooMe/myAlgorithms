import com.ListNode;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.*;
import java.util.stream.*;
import java.util.stream.Collectors;

import java.util.HashSet;

import java.util.Set;

import static java.util.stream.Collectors.toMap;

public class cmp {
    public static class Solution {
		// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】

		// // 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// // 这个题目狠简单：就是从右往左，在 m 条 m 个有序链表里，从尾往前移
		// public long maxSpending(int[][] a) {
		// 	int m = a.length, n = a[0].length;
		// 	int [] r = new int [m];
		// 	Arrays.fill(r, n-1);
		// 	System.out.println(Arrays.toString(r));
		// 	Queue<Integer> q = new PriorityQueue<>((x, y)->a[x][r[x]] - a[y][r[y]]);
		// 	for (int i = 0; i < m; i++)
		// 		q.offer(i);
		// 	long ans = 0; int t = 1;
		// 	for (int i = 0; i < m*n; i++) {
		// 		System.out.println("\n i: " + i);
		// 		int j = q.poll(); // m 行的下标
		// 		// System.out.println("j: " + j);
		// 		// System.out.println("a[j][r[j]]: " + a[j][r[j]]);
		// 		ans += (long)a[j][r[j]] * t;
		// 		t++;
		// 		r[j]--;
		// 		if (r[j] >= 0)
		// 			q.offer(j); // 这里，应该会触发优先队列重新排序
		// 	}
		// 	return ans;
		// }

		// // 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// public int distributeCandies(int n, int k) {// k: limit: 排列组合题，讨厌这个题目，不写这个了。。
		// 	int [][] f = new int [3][k+1];
		// 	int [][] r = new int [3][k+1]; // 先前的累积和
		// 	for (int j = 0; j <= Math.min(n, k); j++) {
		// 		f[0][j] = j;
		// 		r[0][j] = j;
        //     }
		// 	for (int i = 1; i < 3; i++) {
		// 		System.out.println("i: " + i);
		// 		// System.out.println("Math.min(n-r[i-1][j], k): " + Math.min(n-r[i-1][j], k));
		// 		for (int j = 0; j <= Math.min(n-r[i-1][j], k); j++) {
		// 			f[i][j] = j;
		// 			r[i][j] = r[i-1][j] + j;
		// 		}
		// 	}
		// 	int ans = 0;
		// 	for (int i = 0; i <= k; i++)
		// 		ans += f[i][0] * f[i][1] * f[i][2];
		// 	return ans;
		// }
// 早上懒得写上面的题

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int maximumStrongPairXor(int[] a) {
		// 	int n = a.length, r = 0;
		// 	for (int i = 0; i < n; i++)
		// 		for (int j = 0; j < n; j++)
		// 			if (Math.abs(a[i] - a[j]) <= Math.min(a[i], a[j]))
		// 				r = Math.max(r, a[i] ^ a[j]);
		// 	return r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public List<String> findHighAccessEmployees(List<List<String>> lli) {
		// 	List<String> r = new ArrayList<>();			
		// 	Map<String, List<String>> m = new HashMap<>();
		// 	for (List<String>  l : lli) 
		// 		m.computeIfAbsent(l.get(0), z -> new ArrayList<>()).add(l.get(1));
		// 	for (Map.Entry<String, List<String>> en : m.entrySet()) {
		// 		String k = en.getKey();
		// 		List<String> v = en.getValue();
		// 		if (v.size() < 3) continue;
		// 		Collections.sort(v);
		// 		boolean valid = false;
		// 		for (int j = 1; j+1 < v.size(); j++) {
		// 			if (valid(v.get(j-1), v.get(j)) && valid(v.get(j), v.get(j+1)) && valid(v.get(j-1), v.get(j+1))) {
		// 				valid = true;
		// 				break;
		// 			}
		// 		}
		// 		if (valid) r.add(k);
		// 	}
		// 	return r;
		// } // 感觉，写这种乱题目，是浪费亲爱的表哥的活宝妹的生命！！
		// boolean valid(String s, String t) {
		// 	int ha = Integer.parseInt(s.substring(0,2)), hb = Integer.parseInt(t.substring(0,2));
		// 	int x = ha * 60 + Integer.parseInt(s.substring(2));
		// 	int y = hb * 60 + Integer.parseInt(t.substring(2));
		// 	return y - x < 60 && (ha != 23 || hb != 00);
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int minOperations(int[] a, int[] b) {
		// 	int m = a.length, n = b.length;
		// }

// 		// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		public int maximumStrongPairXor(int[] a) { // 二分查找，O(NlogN)
// 			int n = a.length;
// 			for (int v : a) {
// 				for (int j = 0; j < 20; j++) 
// 					if (((v >> j) & 1) == 1)
// 						m.computeIfAbsent(j, z -> new HashSet<>()).add(v);
// 			int l = 1, r = (int)(Math.pow(2, 20)-1), max = 0;
// 			for (int v : a) s.add(v);
// 			while (l <= r) {
// 				int m = l + (r - l) / 2;
// 				if (valid(m, a)) {
// 					max = Math.max(max, m);
// 					l = m+1;
// 				} else r = m-1;
// 			}
// 			return max;
// 		}
// 		Set<Integer> s = new HashSet<>();
// 		Map<Integer, Set<Integer>> m = new HashMap<>(); // 记每个位，存在的数，还是多 
// 		// 这个方法，要写得巧一点儿：就是遍历 v 的所有的数位, 那么这个题目就成了，选课I II 题型。。可是亲爱的表哥的活宝妹，忘记细节了。。
// 		// 选课题是：一个学期最多选几个学分，20 个数位里，哪些组合，出有效存在数，如何巧妙遍历等
// // 这个方法太复杂了，今天晚上不想写这个了：前面某个两根梯子支撑什么的题型，亲爱的表哥的活宝妹，要怎么才能写出那么所有数位的所有可能的数值？？
// 		boolean valid(int v, int [] a) { // 先把前面的题目，至少得解决一个掉，再想这个相对难一点儿的
// 			for (int i = 0; i < 20; i++) { // 这么遍历的规模还是太大了，感觉。。
// 				if (((v >> i) & 1) == 1) {
// 					for (int j : m.get(i)) {
// 						if ()
// 					}
// 				}
// 			}
// 			// for (int i = v; i >= 0; i = (i & (i-1))) { // 没有考虑，可能存在相同位的情况: 所以还要考虑，所有补位（20-bitCnt）位中，所有可能情况，两数同时存在的情况。。
// 			// 	if (s.contains(i) && s.contains(v ^ i) && Math.abs(v-(v^i)) <= Math.min(v, v^i)) return true;
// 			// 	for (int j = 0; j < 20; j++) {
// 			// 		if (r[j] > 0) continue;
// 			// 	}
// 			return false;
// 		}

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int findMinimumOperations(String s, String t, String o) {
		// 	if (s.length() == 1 && t.length() == 1 && o.length() == 1 && s.charAt(0) == t.charAt(0) && t.charAt(0) == o.charAt(0)) return 0;
		// 	if (!s.substring(0,1).equals(t.substring(0, 1)) || !t.substring(0, 1).equals(o.substring(0, 1))) return -1;
		// 	int m = s.length(), n = t.length(), x = o.length();
		// 	int i = 0, min = Math.min(m, Math.min(n, x));
		// 	while (i < min) {
		// 		if (s.charAt(i) != t.charAt(i) || t.charAt(i) != o.charAt(i)) break;
		// 		i++;
		// 	}
		// 	return s.length() - i + t.length() -i + o.length()-i;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 从右往左遍历，是个暴力死计算题。。。
		// public long minimumSteps(String t) {
		// 	int n = t.length(); char [] s = t.toCharArray();
		// 	ArrayDeque<Integer> q = new ArrayDeque<>(); // 升序排列
		// 	int i = n-1;
		// 	long r = 0;
		// 	while (i > -1 && s[i] == '1') i--;
		// 	if (i < 0) return 0;
		// 	while (i > -1) {
		// 		// 这里，认为， s[i]=0
		// 		while (i > -1 && s[i]-'0' == 0) {
		// 			q.offerFirst(i); // 从头，从左边添加
		// 			i--;
		// 		}
		// 		if (i < 0) return r;
		// 		if (s[i] == '1' && !q.isEmpty()) {
		// 			r += (long)(q.pollLast() - i);
		// 			q.offerFirst(i);
		// 		}
		// 		i--;
		// 	}
		// 	return r;
		// }

// 		// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		// 这个题目狠简单，感觉暴力遍历所有可能性都是可以的? n=[0,50]
// 		// 找两个数的 most-significant 位的下标
// 		static final int mod = (int)1e9 + 7; 
// 		public int maximumXorProduct(long a, long b, int idx) {
// 			int m = 64 - Long.numberOfLeadingZeros(a), n = 64 - Long.numberOfLeadingZeros(b);
// 			System.out.println("m: " + m);
// 			System.out.println("n: " + n);
// 			int [] r = new int [50];
// 			long base = 0l, mask = 0l; // mask 不能要
// 			for (int i = 49; i >= 0; i--) {// fd
// 				if (((a >> i) & 1) == 1 && ((b >> i) & 1) == 1)
// 					// r[i] = 1;
// 					mask |= (1 << i);
// 				else if (((a >> i) & 1) + ((b >> i) & 1) == 1) // 两个数这个位上不同
// 					r[i] = 1;
// 				// else if (idx > i) // 这个位上可以有1: 但是这不一定是最优解，它还需要把 ab 聚合收敛，以便乘积最大
// 				else if (idx > i && (i >= Math.max(m, n) || ((a >> i) & 1) == 0 && ((b >> i) & 1) == 0)) // 这个位上可以有1: 但是这不一定是最优解，它还需要把 ab 聚合收敛，以便乘积最大
// 					base += (long)(1 << i);
// 			}
// 			int o = Arrays.stream(r).sum();// 想把它收敛一下，遍历所有（1<o）种可能性，可是会超时。。
// // 感觉，这里最差情况 o=50, 除非是暴力，再从右往左数多少个位强制为1, 亲爱的表哥的活宝妹，这会儿想不出来了，改天再写
// 			return (int)((base ^ a) * (base ^ b) % mod);
// 		}

// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
// 		public List<Integer> findWordsContaining(String[] words, char x) {
// 			List<Integer> l = new ArrayList<>();
// 			for (int i = 0; i < words.length; i++) 
// 				if (words[i].indexOf(x) != -1)
// 					l.add(i);
// 			return l;
// 		}

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// public int minimumCoins(int[] a) { // 这不是，【记忆化深搜】吗？
		// 	n = a.length; this.a = a; 
		// 	f = new Integer [n][n];
		// 	return dfs(0, -1);
		// }
		// Integer [][] f; int [] a;
		// int n;
		// int dfs(int i, int j) { // j: previous Paid idx
		// 	if (i >= n) return 0;
		// 	if (j > -1 && f[i][j] != null) return f[i][j];
		// 	int r = Integer.MAX_VALUE;
		// 	r = a[i] + dfs(i+1, i);// pay for ith item
		// 	if (j == -1 || i > j + j + 1) { // have to pay for this item
		// 		if (j > -1) f[i][j] = r;
		// 		return r;
		// 	}
		// 	for (int k = i; k <= j + j + 1 && k < n; k++) 
		// 		r = Math.min(r, Math.min(dfs(i+1, j), a[i] + dfs(i+1, i)));
		// 	if (j > -1) f[i][j] = r;
		// 	return r;
		// }

		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 有点儿像【区间型动规】，可是感觉没有思路。先滚回去写那个烦死人不偿命的。。		
		// public int findMaximumLength(int[] nums) {
		// }
		
		// // 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		// // 这是个，什么把二维数组上的最大区间和，转化为一维最大区间和，之类的题型。。
		// public int maximizeSquareHoleArea(int n, int m, int[] a, int[] b) {
		// 	int x = a.length, y = b.length, ans = 0;
		// 	int [] r = new int [x+2], c = new int [y+2];
		// 	r[0] = 1; r[x+1] = n+2;
		// 	c[0] = 1; c[y+1] = m+2;
		// 	// // 这个死题狠怪异，倒序排列，要求先去除后面的。。可是题目没有说清楚。所以题目比较坑人。。。
		// 	// Arrays.sort(a); Arrays.sort(b);
		// 	for (int i = 0; i < a.length; i++) r[i+1] = a[i]; // 复制过去
		// 	for (int i = 0; i < b.length; i++) c[i+1] = b[i];
		// 	System.out.println(Arrays.toString(r));
		// 	System.out.println(Arrays.toString(c));
		// 	// 遍历：一个维度上的。对这个维度上的每个可能取值，遍历另一维度上的所有可能性
		// 	TreeMap<Integer, Integer> t = new TreeMap<>();
		// 	t.put(r[0], 0);
		// 	int one = 0;
		// 	for (int i = 1; i < x+2; i++) {
		// 		for (Map.Entry<Integer, Integer> en : t.entrySet()) {
		// 			int k = en.getKey(), v = en.getValue();
		// 			one = r[i] - k;
		// 			if (one < 0) continue;
		// 			System.out.println("\n one: " + one);
		// 			if (one * one > ans) { // 在比先前的解，可能会优的前提下，才检查有效性. 横边一定有效，只检查竖边
		// 				// 同样的方式遍历竖边，是否存在一组可能的和为 one 边长的
		// 				if (valid(one, c)) {// 找到的第一个有效值，一定当前下标 i下，最优
		// 					ans = one * one;
		// 					System.out.println("ans: " + ans);
		// 					found = true;
		// 					break;
		// 				}
		// 			}
		// 		}
		// 		t.put(r[i], i); // 把当前横边点加进去
		// 	}
		// 	return ans;
		// }
		// boolean valid(int v, int [] r) {
		// 	int n = r.length;
		// 	Map<Integer, Integer> m = new HashMap<>();
		// 	m.put(r[0], 0);
		// 	for (int i = 1; i < n; i++) {
		// 		if (m.containsKey(r[i] - v)) return true;
		// 		m.put(r[i], i);
		// 	}
		// 	return false;
		// }

		亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
		亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
	}
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
    public static void main (String[] args) {
        Solution s = new Solution ();
		int [] a = new int [] {3, 2};
		int [] b = new int [] {4, 2};

		int r = s.maximizeSquareHoleArea(2, 4, a, b);
		System.out.println("r: " + r);
    }
}
// ListNode head = new ListNode(a[0]); 
// head.buildList(head, a);
// head.printList(head);
// TreeNode rr = new TreeNode(a[0]);
// rr.buildTree(rr, a);
// rr.levelPrintTree(rr);
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】 
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
	// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】