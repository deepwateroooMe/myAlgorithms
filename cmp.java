import com.ListNode;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.*;
import java.util.stream.*;
import java.util.stream.Collectors;
import java.util.HashSet;
import java.util.Set;
import java.math.BigInteger;
import static java.util.stream.Collectors.toMap;

public class cmp {
    public static class Solution {

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// // 亲爱的表哥的活宝妹，现在【不再贫血？】的亲爱的表哥的活宝妹，能够把这些、先前、搞不明白的难题，这次都弄明白了。。
		// // 对照着【题解】来写，但把【每个细节】都弄懂，弄明白！！！
		// // BIT 的【两个操作】： i += i & -i 和 i &= i-1    原理，忘记了。。【TODO】：是一样的吗？
		// // BIT 的【两个操作】： i += i & -i 和 i -= i & -i 原理，忘记了。。【TODO】：
		// class BIT {
		// 	// 这里需要用到 2 个，直接使用一个数组了
		// 	private final int [][] f;
		// 	public BIT (int n) {
		// 		// 【0】: 频次计数；每个有效长度，所出现的次数
		// 		// 【1】：值与频次、乘积、累积和。
		// 		f = new int [n+1][2]; 
		// 	}
		// 	// op =  1，添加一个 size
		// 	// op = -1，移除一个 size
		// 	public void update(int size, int op) { // 包括了：添加与删除、增加与减少，两种效果的操作。这也是一种归纳。。 
		// 		for (int i = f.length-size; i < f.length; i += i & -i) {
		// 			f[i][0] += op;// 统计个数
		// 			f[i][1] += op * size; // 累积效果：片段长度大小与频率的、累积和
		// 		}
		// 	}
		// 	// 返回 >= size 的元素个数，元素和
		// 	public int[] query(int size) {
		// 		int cnt = 0, sum = 0;
		// 		for (int i = f.length-size; i > 0; i &= i-1) {
		// 			cnt += f[i][0];
		// 			sum += f[i][1];
		// 		}
		// 		return new int [] {cnt, sum};
		// 	}
		// }
		// // op =  1，【添加】一个结束位置 i
		// // op = -1，【移除】一个结束位置 i
		// void update(int i, int op) {
		// 	// 【有序集合】查询：《 i 的【前一个、结束位置】
		// 	Integer pre = ts.floor(i);
		// 	if (pre == null)
		// 		pre = ts.last();
		// 	// 【有序集合】查询：> i 的【下一个、结束位置】
		// 	Integer next = ts.ceiling(i);
		// 	if (next == null)
		// 		next = ts.first();
		// 	// 【先】：反操作，【结束位置 i】有无之前的、反操作
		// 	f.update((next - pre + n - 1) % n + 1, -op); // 移除/添加旧长度
		// 	// 【再】：【结束位置 i】相关的，两片段操作
		// 	f.update((i - pre + n) % n, op); // 添加/移除新长度
		// 	f.update((next - i + n) % n, op);// 添加/移除新长度
		// }
		// // 添加一个结束位置 i
		// void add(int i) {
		// 	if (ts.isEmpty())
		// 		f.update(n, 1); // ???
		// 	else
		// 		update(i, 1);
		// 	ts.add(i);
		// }
		// // 移除一个结束位置 i
		// void delete(int i) {
		// 	ts.remove(i); // 【删除】：要求的结束位置 i
		// 	if (ts.isEmpty()) // 撤销：先前添加过的，长度为 n 的一个片段
		// 		f.update(n, -1);
		// 	else
		// 		update(i, -1);
		// }
		// TreeSet<Integer> ts;
		// BIT f;
		// int n;
		// public List<Integer> numberOfAlternatingGroups(int [] a, int[][] qs) {
		// 	n = a.length;
		// 	ts = new TreeSet<>();
		// 	f = new BIT(n);
		// 	// 【扫数组】：纪录【结束位置】预处理等
		// 	for (int i = 0; i < n; i++)
		// 		if (a[i] == a[(i+1) % n]) // 【环形数组】：a[n-1] == a[0] 等
		// 			add(i); // 添加，一个结束位置 i
		// 	List<Integer> ans = new ArrayList<>();
		// 	for (int [] q : qs) {
		// 		if (q[0] == 1) {
		// 			if (ts.isEmpty())
		// 				ans.add(n); // 每个长为 size 的子数组都符合要求,
		// 			// 是因为【整个数组】、不存在、任何中断点，每个下标，都可以作为所要求的、任意长度片段的起点
		// 			else { // 数组中存在，中断点，【环形数组】【固定长度】的累计和
		// 				int [] res = f.query(q[1]);
		// 				ans.add(res[1] - res[0] * (q[1] - 1));
		// 			}
		// 		} else { // 要：修改数组某个下标的值。这种操作，不求答案，只有后续影响
		// 			int i = q[1];
		// 			if (a[i] == q[2]) continue; // 没有影响
		// 			int pre = (i - 1 + n) % n;
		// 			int next = (i + 1) % n;
		// 			// 修改前，先去掉结束位置
		// 			if (a[pre] == a[i])
		// 				delete(pre);
		// 			if (a[i] == a[next])
		// 				delete(i);
		// 			// 【修改 a[i] 】
		// 			a[i] ^= 1;
		// 			// 修改后，添加新的结束位置
		// 			if (a[pre] == a[i])
		// 				add(pre);
		// 			if (a[i] == a[next])
		// 				add(i);
		// 		}
		// 	}
		// 	return ans;
		// }
		// 【TODO】：亲爱的表哥的活宝妹，改天会把这个仔细 debug 出来的。。
		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 		// 亲爱的表哥的活宝妹，上次写，几乎是看着它人的源码分析，几乎照抄
// 		// 亲爱的表哥的活宝妹，【好背题目。。】今天这会儿、再自己背一遍，看能背出来吗？
// 		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 		// 亲爱的表哥的活宝妹，现在【不再贫血？】的亲爱的表哥的活宝妹，能够把这些、先前、搞不明白的难题，这次都弄明白了。。
// 		// BIT 的【两个操作】： i += i & -i 和 i &= i-1    原理，忘记了。。【TODO】：是一样的吗？
// 		// BIT 的【两个操作】： i += i & -i 和 i -= i & -i 原理，忘记了。。【TODO】：
// 		class BIT { // 主要适用：【区间】查询 queries, 求和 preSum O(logN)
// 			// 本题特例：需要2 个，用个数组. 为什么需要2 个呢？
// 			// 一个【0】：纪录，每个长度在【0,N】范围内、任何长度的、片段的【出现频率】
// 			// 一个【1】：纪录，每个长度在【0,N】范围内、【区间的【0,M】、长度计数、频率累积和？】，像是求【数组的 preSum】
// 			int [][] f; // 下标从1 开始
// 			int n;
// 			public BIT(int n) {
// 				this.n = n;
// 				f = new int [n+1][2];
// 			}
// 			// op: 如【游戏橱架里，网络异步调用、操作符】自定义不同操作，这里两种
// 			// -1: 【删除】一个长度为 i 的片段 
// 			// +1: 【添加】一个长度为 i 的片段 
// 			public void update(int i, int op) { // 添加、删除：一个长度为 i 的片段, 频次为 1
// 				// 【TODO】：【树状数组】里，当下标【1,N】视作【片段长度1-N】，怎么更新这个
// 				// 【TODO】：亲爱的表哥的活宝妹，这里一定写错了，因为，还没能【参透：树状数组，下标的遍历原理】。。。
// 				// for 。。。这里需要一个：树状数组的、极特殊【遍历】：遍历到，下标 i ，在树状数组里，被计入 partial-preSum 的每个下标节点
// 				// 【TODO】：亲爱的表哥的活宝妹，下面真像是在【背答案】：为什么倒着遍历，怎么会倒着遍历到 i 的最高1 数位？
// 				// f[i][0]: f[i] 定义为：片段长度在【0,i】范围内的、所有片段的频率累积和。亲爱的表哥的活宝妹的、这个理解，对吗？【TODO】：
// 				// 当把 f[i] 定义为【区间和】, 那么更新长度为 i 的片段，就该仅只影响【前缀和、树装数组】f[i] 的【i,N】区间的下标
// 				for (int j = i; j <= n; j += (j & -j)) {
// 				// for (int j = n; j >= i; j -= (j & -j)) {
// 					f[j][0] = f[j][0] + op * 1; // 【0】：只计数，只计频次
// 					f[j][1] = f[j][1] + op * i; // [1]: 这里像是写错了，为什么会 *i? 片段的长短，是答案的一个成分，需要累积求和
// 				}
// 				// f[i][0] = f[i][0] + op * 1; // 【0】：只计数，只计频次
// 			}
// 			// 求：片段长度在【i,N】范围内的、所有可能长度、各长度出现计数的【累积和】
// 			// 那么，这里【查询】的，就是 f[i][2] 里的【区间】【累积和】，像是【数组的 preSum】
// 			public int [] query(int i) {
// 				int totCnts = f[n][0] - f[i-1][0]; // 把它理解成了 preSum 数组，求【区间和】
// 				int ttLenFreq = f[n][1] - f[i-1][1];
// 				return new int [] {totCnts, ttLenFreq};
// 			}
// 		}
// 		TreeSet<Integer> ts; // 纪录：所有的结束点下标
// 		BIT f;
// 		int n;
// 		// void add(int i, int op) { // 【TODO】：哪里，调用这个方法了？
// 		void add(int i) { // 【TODO】：哪里，调用这个方法了？
// 			if (ts.isEmpty()) // 【初始化】：添加一个长度为N 的片段，1 次
// 				f.update(n, 1); // BIT 里先【添加哨兵】
// 			f.update(i, 1);
// 			ts.add(i); // 记下这个【结束下标】
// 		}
// 		// 【撤销 op=-1】或是【添加 op=1】：1 个长度为 i 的片段。包括 ts 与 BIT 两数据结构里的操作
// 		void update(int i, int op) {
// 			f.update(i, op);
// 			ts.remove(i);
// 			if (ts.isEmpty()) {
// 				f.update(n, 1); // 【添加一个：长度为 n 片段哨兵】
// 			}
// 		}
// 		public List<Integer> numberOfAlternatingGroups(int [] a, int[][] qs) {
// 			n = a.length;
// 			ts = new TreeSet<Integer>();
// 			f = new BIT(n);
// 			// 【预处理】数据：扫一遍数组，纪录所有【结束点】，必要的【树状数组】初始化
// 			for (int i = 0; i < n; i++) // 【环形数组】：每个下标，都需要考虑
// 				if (a[i] == a[(i+1) % n]) { // 当前数，与它后面的一个数，相同：当前下标，是一个【结束点】
// 					// 单列这个：像是【哨兵】，有个特殊【长度为N 片段的、初始化、般的添加】。
// 					// 因为【反操作时】若撤销掉最后一个结束点，该是不存在结束点的长度为 N 的片段
// 					add(i); // 添加一个【片段结束点】
// 				}
// 			System.out.println("ts.size(): " + ts.size());
// 			System.out.println(Arrays.toString(ts.toArray()));
// 			// 解答案：
// 			List<Integer> ans = new ArrayList<>();
// 			int oo = 0;
// 			for (int [] q : qs) {
// 				System.out.println("\n oo: " + oo);
// 				System.out.println(Arrays.toString(q));
// // 【求解】：长度为 q[1] 的片段总个数：所有、长度 >= q[1] 的【累积和】－【不符合、条件要求】的计数
// 				if (q[0] == 1) {
// 					int [] r = f.query(q[1]); // 2 个【树状数组】：所返回的【区间长度、累积频率】与【区间长度、累积Sum（长度×该长度频次）】
// 					ans.add(r[1] - r[0] * (q[1] - 1));
// 				} else {
// 					if (a[q[1]] == q[2]) continue; // 更原数组是一样的，无效跳过
// 					// 修改、某个下标的颜色值：它会影响【拆分一个片段为二、或是、合并二个片段为一】
// 					// 找：当前下标 q[1], 之前、和之后的、最近结束点
// 					// 【TODO】：下面，两种取值方法，原因原理？
// 					Integer pre = ts.lower(q[1]);
// 					if (pre == null) pre = ts.last();
// 					// The ceiling() method of java.util.TreeSet<E> class is used to return the least element in this set greater than or equal to the given element
// 					// Integer next = ts.higher(q[1]); // 【TODO】：感觉这里写错了，当前下标 i 的下一个结束点，是可能为 i 的
// 					Integer next = ts.ceiling(q[1]);
// 					if (next == null) next = ts.first();
// 					System.out.println("pre: " + pre);
// 					System.out.println("next: " + next);
// 					// 把【修改】定义为：在2 种可能的动态变化下，概括抽象为，【先执行，相反的操作；再执行，更新后的需要操作】
// 					// 为什么呢？因为【树状数组】是【O(logN) 前缀和数组】，以【片段长度】为下标的计量单位，合并与拆分，涉及几个不同的片段长度，务必先反操作
// 					// 区分：修改当前下标后，是【合并】还是【拆分】，2 种操作里的哪一种
// 					if (a[q[1]-1] != q[2]) { // 先前是一样的、先前是分开的2 片段，现在执行【合并操作】：合并【pre,next】片段
// 						// 【撤销】：先前分开的 2 个片段、相关
// 						update((q[1] - pre + n) % n, -1);
// 						update((next - q[1] + n) % n, -1);
// 						// 执行：【合并】成1 个片段的、更新
// 						update((next - pre + n) % n, 1);
// 					} else { // 先前不一样，是一个片段；现在【拆分】成为了2 个片段 
// 						update((next - pre + n) % n, -1);
// 						update((q[1] - pre + n) % n, 1);
// 						update((next - q[1] + n) % n, 1);
// 					}
// 				}
// 			}
// 			return ans;
// 		}

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// int [][] dirs = {{1, 0}, {0, 1}, {0, -1}, {-1, 0}};
		// public int finalPositionOfSnake(int n, List<String> l) {
		// 	Map<String, Integer> m = new HashMap<>();
		// 	m.put("DOWN", 0);
		// 	m.put("RIGHT", 1);
		// 	m.put("LEFT", 2);
		// 	m.put("UP", 3);
		// 	int r = 0;
		// 	for (int i = 0; i < l.size(); i++) {
		// 		int [] d = dirs[m.get(l.get(i))];
		// 		int x = r / n, y = r % n;
		// 		r = (x + d[0]) * n + (y + d[1]);
		// 	}
		// 	return r;
		// }

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// // 亲爱的表哥的活宝妹，感觉这个题目，狠简单，数据规模极小，感觉狠容易过才对，为什么只有几个人写过了？？？
		// // 想简单了，【动规】的维数：【下标长度N】【每个下标取值范围51】【某一个数组的前一个数。。】
		// // 亲爱的表哥的活宝妹，先写、几乎万能的【记忆化深搜】！！
		// static final int mod = (int)1e9 + 7;
		// public int countOfPairs(int[] a) {
		// 	// 亲爱的表哥的活宝妹，这个题目，是可能过的，再稍微优化一下，不必要的遍历，不做；前合法性，不自己制造不合法和后续检测
		// 	n = a.length; m = Arrays.stream(a).max().getAsInt(); this.a = a; 
		// 	f = new Long [n][m+1][m+1];
		// 	// 遍历 j: A 数组的 a[0] 取值范围
		// 	for (int i = 0; i <= a[0]; i++) 
		// 		dfs(0, i, 0);
		// 	long r = 0;
		// 	for (int i = 0; i <= a[0]; i++) 
		// 		r = (r + f[0][i][0]) % mod;
		// 	return (int)r;
		// }
		// Long [][][] f;
		// int m, n; int [] a;
		// long dfs(int i, int j, int k) { // J: i 下标的当前取值 K: i-1 下标的 A 数组取值
		// 	if (f[i][j][k] != null) return f[i][j][k];
		// 	// 检查【合法性】：当前下标 i, 是否 a[i-1] <= a[i] && b[i-1] >= b[i] ？也可以不用检查，先过滤，仅只取合法范围内的值
		// 	if (i == 0 && n > 1 && (j > a[1] || a[0]-j < 0)) return f[i][j][k] = 0l;
		// 	if (i > 0 && a[i-1] - k < a[i] - j) return f[i][j][k] = 0l;
		// 	if (i == n-1) return f[i][j][k] = 1l;
		// 	// 遍历？当前下标 i, A 数组取值为 j, A 数组 i-1 下标取值为 k 时， i+1 下标， A 数组的取值范围
		// 	long r = 0;
		// 	for (int x = j; x <= a[i+1]; x++) 
		// 		r = (r + dfs(i+1, x, j)) % mod;
		// 	return f[i][j][k] = r;
		// }

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// // 亲爱的表哥的活宝妹，今天没带本子回来，先去写别的，再回来看这个题目
		// public int countGoodNodes(int[][] egs) {
		// 	n = egs.length + 1;
		// 	g = new ArrayList [n];
		// 	Arrays.setAll(g, z -> new ArrayList<>());
		// 	for (int [] e : egs) {
		// 		int u = e[0], v = e[1];
		// 		g[u].add(v);
		// 		g[v].add(u);
		// 	}
		// 	f = new int [n];
		// 	a = new Boolean [n];
		// 	dfs(0, -1);
		// 	int ans = 0;
		// 	// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// 	// 亲爱的表哥的活宝妹，上面、这里、理解错了，不是说，所有【子树】相同大小，而是，所有的、【子树的子树】，都是合格好树！！
		// 	// 中间【隔了一代子树】！题型，像是，那个【小偷、树型偷东西】
		// 	// 【小偷、树型偷东西】：那个题型，也狠经典，可是亲爱的表哥的活宝妹，把它弄忘记了，一时想不起来，是如何隔代隔层偷东西的？
		// 	// 亲爱的表哥的活宝妹，这么简单的题目，周六傍晚没能写出来，仅只因为，那天，亲爱的表哥的活宝妹，没有带本子回住处
		// 	// 对于写错了的 test-case, 没能画出树图来分析和 debug 而已。但是亲爱的表哥的活宝妹只要想写，就一定写得出来！！
		// 	for (int i = 0; i < n; i++) 
		// 		if (a[i] != null && a[i]) ans++;
		// 	return ans;
		// }
		// List<Integer> [] g;
		// int [] f;     // total  nodes count 
		// Boolean [] a; // balanced or not 重新定义为：是否，所有的、以该根节点的、任何【子节点】为根的子树，都是合格好树
		// int n;
		// void dfs(int u, int p) {
		// 	// if (g[u].size() == 1) {  // 【写错了】：特例，0 根节点
		// 	if (g[u].size() == 1 && g[u].get(0) == p) {
		// 		f[u] = 1;
		// 		a[u] = true; // 【叶子节点】一定是全格的
		// 		return ;
		// 	}
		// 	int val = 0, cnt = 0, ttCnt = 0;
		// 	// 以【子节点】的子节点为根的、树的大小，也是严格标准
		// 	for (int v : g[u]) {
		// 		if (v == p) continue;
		// 		dfs(v, u);
		// 		if (val == 0) 
		// 			val = f[v];
		// 		else if (f[v] != val)  // 【写错了】：题目要求中间隔一代。。
		// 			a[u] = false;
		// 		ttCnt += f[v];
		// 		// if (a[v]) cnt++; // 【写错了】：这相标准，不对！！
		// 		// 重定标准：所有、子节点为根的子树，都合法的、子节点统计
		// 		// // 先定义不合法的：这里写得也不对
		// 		// if (!a[v]) a[u] = false;
		// 		// if (a[v] || f[v] == val) cnt++;
		// 		// if (a[v])
		// 		cnt++;
		// 	}
		// 	if (a[u] == null && cnt == g[u].size()-(p == -1 ? 0 : 1)) a[u] = true;
		// 	else a[u] = false;
		// 	f[u] = ttCnt + 1;
		// }

// 		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 		// 【数据规模变大了】：【N=2000,a[i]=1000,preA[i]=1000】，上个写法，一定超时！！
// 		// 【亲爱的表哥的活宝妹，今天还不能写这个题目，读不懂。。明天上午再写这个题目】
// 		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 		// 【记忆化深搜】就不用再想了，如上题解法的【记忆化深搜】也一定超时！！
// 		// 【动规】：亲爱的表哥的活宝妹，可以试写。但感觉，这个数据规模的【动规】，仅只改写【记忆化深搜】为【动规】，亲爱的表哥的活宝妹感觉，【动规】，也还会超时！！
// 		// 【动规】＋必要的【优化】：什么狗屁【树状数组】【O(logN) 级别的、区间求和】优化，用起来，或许能过, 解法为O(N*M*log(M)) 应该能过
// 		// 【动规】＋必要的【优化】：也可以从，对【原数组 A 的、数据预处理】方面考虑，优化。也就是，将每个下标 i 的【合法、取值范围】极尽可能地缩小，缩小到，不TLE
// 		// 这么看，这个题目，也仅仅只是，亲爱的表哥的活宝妹，还没能民习惯写【动规】而已。。
// 		// 习惯了写【自尾向头】的【记忆化深搜】，亲爱的表哥的活宝妹，还需要也应该适应，写【自头向尾】的【动规】！！
// 		static final int mod = (int)1e9 + 7;
// 		public int countOfPairs(int[] a) {
// 			int n = a.length, m = Arrays.stream(a).max().getAsInt();
// 			int [][] f = new int [n][m+1]; // 不再用，这个常规打开方式。。。
// 			// 【记忆化深搜】：亲爱的表哥的活宝妹，总是【自尾向头】来解决子下标的结果；
// 			// 【动规】：它们的题解，都是【自头向尾】来解决子下标的结果。。
// // The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive.
// 			Arrays.fill(f[0], 0, a[0]+1, 1); // [fromIndex_Inclusive, toIndex_Exclusive)
// 			long s = 0l; // 【每个下标、都初始化】的、每个下标的、前缀和
// 			int maxK = 0;
// 			// 遍历：下标【1,n-1】求解
// 			for (int i = 1; i < n; i++) {
// 				s = 0l;
// 				maxK = Math.min(0, a[i-1] - a[i]);
// 				for (int j = 0; j <= m; j++) {
// 					if (j + maxK < 0) f[i][j] = 0;
// 					else {
// 						s += f[i-1][j + maxK];
// 						f[i][j] = (int)(s % mod);
// 					}
// 				}
// 			}
// 			s = 0l;
// 			for (int i = 0; i <= a[n-1]; i++) 
// 				s = (s + f[n-1][i]) % mod;
// 			return (int) s;
// 		}

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// public int[] resultsArray(int[] a, int k) {
		// 	int n = a.length, j = 0;
		// 	int [] r = new int [n-k+1];
		// 	Arrays.fill(r, -1);
		// 	boolean valid = false;
		// 	for (int i = 0; i < n-k+1; i++) {
		// 		valid = true;
		// 		for (j = i+1; j < i+k; j++) {
		// 			if (j == i+1 && a[j] != a[i] + 1
		// 				|| j > i+1 && a[j] != a[j-1]+1) {
		// 				valid = false;
		// 				break;
		// 			} 
		// 		}
		// 		if (valid) r[i] = a[j-1];
		// 	}
		// 	return r;
		// }

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// public int[] resultsArray(int[] a, int k) {
		// 	int n = a.length, j = 0;
		// 	int [] f = new int [n];// counts the # of consecutive increasing length
		// 	Arrays.fill(f, 1);
		// 	for (int i = 1; i < n; i++) 
		// 		if (a[i] == a[i-1] + 1)
		// 			f[i] = f[i-1] + 1;
		// 	int [] r = new int [n-k+1];
		// 	Arrays.fill(r, -1);
		// 	for (int i = k-1; i < n; i++) 
		// 		if (f[i] >= k) r[j++] = a[i];
		// 		else j++;
		// 	return r;
		// }

		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// 【数据规模】有点儿大，如果【暴力O(10000*10000*10000)】应该会超时, 数量级在【O(N=10000*10000)】可能可以过，不超时
		// 忘记一个因素：【前状态，需要记忆】。第一个、第二个的摆放位置，需要记住。需要重新定义【记忆、数据结构】 
		// 可能需要结合【贪心思路】来只遍历、最优解可能性的部分位置
		public long maximumValueSum(int[][] a) { // TLE: 725/843 passed
			m = a.length; n = a[0].length; this.a = a; 
			// Integer [] rank = IntStream.range(0, m*n).boxed().toArray(Integer[]::new);			
			// Arrays.sort(rank, (x, y)->a[y/n][y%n] - a[x/n][x%n]); // 按值大小，降序排列
			long max = Long.MIN_VALUE;
			f = new HashMap<>();
			for (int i = 0; i < m*n; i++) {
				String [] s = new String [3];
				// s[0] = String.valueOf(rank[i]);
				// long ans = a[rank[i]/n][rank[i]%n] + dfs(rank[i]/n, rank[i] % n, s);
				s[0] = String.valueOf(i);
				long ans = a[i/n][i%n] + dfs(i/n, i % n, s);
				max = Math.max(max, ans);
				// if (ans < a[rank[0]/n][rank[0]%n]) break;
			}
			return max;
		}
		int [][] a;
		Map<String, Long> f;
		int m, n;
		long dfs(int i, int j, String [] s) {
			String key = String.valueOf(i * n + j) + "-" + s[0] + (s[1] == null ? "" : "-" + s[1] + (s[2] == null ? "" :  "-" + s[2]));
			if (f.containsKey(key)) return f.get(key);
			long r = Long.MIN_VALUE;
			Set<Integer> si = new HashSet<>(), sj = new HashSet<>();
			TreeSet<Integer> ts = new TreeSet<>();
			for (int x = 0; x < 3; x++) 
				if (s[x] != null) {
					si.add(Integer.parseInt(s[x]) / n);
					sj.add(Integer.parseInt(s[x]) % n);
					ts.add(Integer.parseInt(s[x]));
				}
			if (ts.size() == 3) return 0;
			StringBuilder sb = new StringBuilder();
			Iterator it;
			int jj = 0;
			for (int x = 0; x < m; x++) {
				if (si.contains(x)) continue;
				for (int y = 0; y < n; y++) {
					if (sj.contains(y)) continue;
					ts.add(x * n + y); // 添加【当前数】
					sb.setLength(0);
					it = ts.iterator();
					if (it.hasNext()) {
						sb.append(String.valueOf(ts.first()));
						s[0] = String.valueOf(ts.first());
						it.next();
						jj = 0;
					}
					while (it.hasNext()) { 
						int v = (int)it.next();
						sb.append("-");
						sb.append(String.valueOf(v));
						s[++jj] = String.valueOf(v);
					}
					String [] ss = new String [3];
					for (int zz = 0; zz < 3; zz++) 
						ss[zz] = s[zz];
					r = Math.max(r, (long)a[x][y] + (s[2] == null ? dfs(x, y, ss) : 0l));
					ts.remove(x * n + y); // 移除【当前数】
				}
			}
			sb.setLength(0);
			it = ts.iterator();
			if (it.hasNext()) {
				sb.append(String.valueOf(ts.first()));
				it.next();
			}			
			while (it.hasNext()) { 
				sb.append('-');
				sb.append(it.next());
			} 
			f.put(sb.toString(), r);
			return r;
		}

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// public long maximumValueSum(int[][] board) {
			
		// }
	}
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
    public static void main (String[] args) {
		Solution s = new Solution ();

		int [][] a = new int [][] {{-88,-80,40,0,-33,-32,26,-11,-18,8},{79,-65,-40,-76,31,24,34,73,-85,-53},{47,33,59,58,90,94,83,41,26,-81},{89,36,-10,63,66,-59,71,61,-56,-16},{-77,5,97,12,-74,-79,22,72,-2,0},{-30,82,-47,37,10,-58,80,-50,90,-53},{20,-47,-57,-30,-85,0,-41,84,22,29},{46,29,66,2,62,-43,82,25,24,72},{57,75,10,-85,53,-82,1,40,51,-33},{-10,-74,-95,-49,51,20,-53,-41,60,24}};

		System.out.println("a.length: " + a.length);
		for (int z = 0; z < a.length; ++z) 
			System.out.println(Arrays.toString(a[z]));

		long r = s.maximumValueSum(a);
		System.out.println("r: " + r);
    }
}
// ListNode head = new ListNode(a0]); 
// head.buildList(head, a);
// head.printList(head);
// Tree [N de rr = new [] TreeNode(a0);
// rr.buildTree(rr, a);
// rr.levelPrintTree(rr);
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】