import com.TreeNode;
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.*;
import java.util.stream.*;
import java.util.stream.Collectors;
import java.util.HashSet;
import java.util.Set;
import java.math.BigInteger;
import static java.util.stream.Collectors.toMap;
public class cmp {
    public static class Solution {

        // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public int maxSubstrings(String S) {
        //     n = S.length(); s = S.toCharArray();
        //     int [] a = new int [26]; r = new int [n];
        //     Arrays.fill(a, -1); Arrays.fill(r, -1);
        //     f = new Integer [n];
        //     for (int i = n-1; i >= 0; i--) {
        //         int j = s[i]-'a';
        //         if (a[j] == -1) {
        //             a[j] = i;
        //             continue;
        //         }
        //         r[i] = a[j];
        //         a[j] = i;
        //     }
        //     return dfs(0);
        // }
        // Integer [] f; int [] r;
        // char [] s;
        // int n;
        // int dfs(int i) {
        //     if (i == n) return 0;
        //     if (f[i] != null) return f[i];
        //     int j = i;
        //     while (j < n && r[j] != -1 && r[j] - i < 3) j = r[j];
        //     int ans = dfs(i+1);
        //     if (j < n && r[j] != -1) {
        //         ans = Math.max(ans, 1 + dfs(r[j] + 1));
        //         for (int k = i+2; k <= r[j]; k++) 
        //             ans = Math.max(ans, dfs(k));
        //     }
        //     return f[i] = ans;
        // }        

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // static final int mod = (int)1e9 + 7;
        // public int assignEdgeWeights(int[][] egs) {
        //     n = egs.length + 1;
        //     g = new ArrayList [n+1];
        //     Arrays.setAll(g, z -> new ArrayList<Integer>());
        //     for (int [] e : egs) {
        //         int u = e[0], v = e[1];
        //         g[u].add(v);
        //         g[v].add(u);
        //     }
        //     dfs(1, -1, 0);
        //     System.out.println("d: " + d);
        //     f = new Integer [d][2];
        //     return dfsMemory(0, 1);
        // }
        // List<Integer> [] g;
        // int n, d;
        // Integer [][] f;
        // int dfsMemory(int i, int j) {
        //     if (f[i][j] != null) return f[i][j];
        //     if (i == d-1) return f[i][j] = 1;
        //     return f[i][j] = 2 * dfsMemory(i+1, 1-j) % mod;
        // }        
        // void dfs(int u, int p, int h) {
        //     if (g[u].size() == 1 && g[u].get(0) == p) {
        //         d = Math.max(d, h);
        //         return ;
        //     }
        //     for (int v : g[u]) {
        //         if (v == p) continue;
        //         dfs(v, u, h+1);
        //     }
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // （无向图）变【有向图】：查找最近公共祖先，计算任意两节点间的、最短距离
        // // 【记忆化深搜】：是（自底向上）的；得写【动规】：（自顶向下），方便提取任意距离的结果
        // // 不知道哪里细节写错了，改天再写。。。
        // static final int mod = (int)1e9 + 7;
        // public int [] assignEdgeWeights(int[][] egs, int [][] qs) {
        //     n = egs.length + 1; int m = qs.length;
        //     gr = new HashSet [n+1];
        //     Arrays.setAll(gr, z -> new HashSet<Integer>());
        //     for (int [] e : egs) {
        //         int u = e[0], v = e[1];
        //         gr[u].add(v);
        //         gr[v].add(u);
        //     }
        //     // 变（无向图）为【有向图】；同步纪录【最近公共祖先】，定义是：子节点 v 的第2^j 个祖先 = 父节点 u 的第 2^j-1 级祖先的、第2^j-1 级祖先
        //     // 定义： f[v][j] = f[f[u][2]
        //     g = new int [n+1][16];
        //     d = new int [n+1];
        //     dfs(1, -1, 0);
        //     System.out.println(Arrays.toString(d));
        //     // 纪录【最近公共祖先】: 亲爱的表哥的活宝妹，好像这里哪里写错了。。
        //     g[1][0] = 1;
        //     // for (int i = 1; i <= n; i++)
        //     //     g[i][0] = i;
        //     dfsLCA(1);
        //     // 【动规】：（自顶向下）求结果
        //     int maxDepth = Arrays.stream(d).max().getAsInt();
        //     f = new Integer [maxDepth+1][2];
        //     // return dfsMemory(0, 1);
        //     f[0][0] = 1; // 2
        //     f[0][1] = 1; // 1
        //     for (int i = 1; i <= maxDepth; i++) 
        //         for (int j = 0; j < 2; j++) 
        //             f[i][j] = (f[i-1][1-j] + f[i-1][j]) % mod;
        //     int [] r = new int [m];
        //     for (int i = 0; i < m; i++) {
        //         int u = qs[i][0], v = qs[i][1], h = getShortestPath(u, v);
        //         System.out.println("u: " + u + " " + "v: " + v);
        //         System.out.println("h: " + h);
        //       r[i] = f[h][1];
        //     }
        //     return r;
        // }
        // Set<Integer> [] gr;
        // Integer [][] f;
        // int [][] g;
        // int [] d;
        // int n;
        // // 根据【最近公共祖先】求（有向图）上，任意两节点间的【最短距离】
        // int getShortestPath(int u, int v) {
        //     int p = LCA(u, v);
        //     System.out.println("p: " + p);
        //     return d[u] + d[v] - 2 * d[p];
        // }
        // int LCA(int u, int v) {
        //     // 强制 d[u] >= d[v]
        //     int tmp = u;
        //     u = (d[u] >= d[v] ? u : v);
        //     v = (u == tmp ? v : u);
        //     // 【最快节奏】地跳，将 U V 同层
        //     for (int i = 15; i >= 0; i--) 
        //         if (d[g[u][i]] >= d[v])
        //             u = g[u][i];
        //     System.out.println("LCA u: " + u + " " + "v: " + v);
        //    if (u == v) return v;
        //     // U V 同层后，共同同步往上跳，
        //     // 否则将a和b同时向上跳，直到跳到最近公共祖先下一层为止
        //     for (int k = 15; k >= 0; k--)
        //         if (g[u][k] != g[v][k]) {
        //             u = g[u][k];
        //             v = g[v][k];
        //         }
        //     return g[u][1];
        // }
        // void dfsLCA(int u) { // 自顶向下：从父节点遍历子节点
        //     for (int v : gr[u]) {
        //         for (int j = 1; g[u][j-1] > 0; j++) // 穷追塑源：一直找到整棵树的根节点：1
        //             g[v][j] = g[g[u][j-1]][j-1];
        //     }
        //     for (int v : gr[u]) 
        //         dfsLCA(v);
        // }
        // void dfs(int u, int p, int h) {
        //     d[u] = h;
        //     if (gr[u].size() == 1 && gr[u].contains(p)) {
        //         gr[u].remove(p);
        //         // d = Math.max(d, h);
        //         return ;
        //     }
        //     for (int v : gr[u]) {
        //         if (v == p) 
        //             continue;
        //         dfs(v, u, h+1);
        //     }
        //     gr[u].remove(p);
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 感觉大致思路清晰，但离解题、最后一个细节思路，还差最后一步、才算能写完整。。现在最后2 个题目都没能想透彻写完整。。
        // public String lexicographicallySmallestString(String S) {
        //     n = S.length(); s = S.toCharArray(); this.S = S; 
        //     f = new StringBuilder [n][n];
        //     return dfs(0, n-1).toString();
        // }
        // StringBuilder [][] f;
        // char [] s; String S;
        // int n;
        // // 过程中的细节，有出错，需要再写。。。
        // StringBuilder dfs(int i, int j) {
        //     System.out.println("\ni: " + i + " " + "j: " + j);
        //     if (f[i][j] != null) return f[i][j];
        //     if (i == j) {
        //         f[i][j] = new StringBuilder();
        //         f[i][j].append(s[i]); // <<<<<<<<<<<<<<<<<<<< 
        //         System.out.println("f[i][j]: " + f[i][j]);
        //         return f[i][j];
        //     }
        //     if (i+1 == j)
        //         return ((Math.abs(s[i] - s[j]) == 1
        //                 || s[i] == 'z' && s[j] == 'a'
        //                  || s[i] == 'a' && s[j] == 'z') ? new StringBuilder("") : new StringBuilder(S.substring(i, j+1)));
        //     StringBuilder r = new StringBuilder(S.substring(i, j+1)), cur = new StringBuilder("");
        //     System.out.println("\nr0: " + r);
        //     int k = i+1;
        //     if (Math.abs(s[i] - s[k]) == 1
        //         || s[i] == 'z' && s[k] == 'a'
        //         || s[i] == 'a' && s[k] == 'z') {
        //         cur = dfs(i+2, j);
        //         System.out.println("cur M: " + cur.toString());
        //         if (cur.compareTo(r) < 0)
        //             r = cur;
        //     }
        //     cur.setLength(0);
        //     cur.append(s[i]);
        //     cur.append(dfs(i+1, j));
        //     System.out.println("cur Outside: " + cur);
        //     while (cur.length() >= 2 && (Math.abs(cur.charAt(0) - cur.charAt(1)) == 1
        //                               || cur.charAt(0) == 'z' && cur.charAt(1) == 'a'
        //                               || cur.charAt(0) == 'a' && cur.charAt(1) == 'z')) {
        //         cur.deleteCharAt(1);
        //         cur.deleteCharAt(0);
        //     }
        //     System.out.println("cur Outside 2: " + cur);
        //     // 【TODO：】过程中结果，可以是大的；要最终结果，是最小的。。
        //     if (cur.compareTo(r) < 0) r = cur;
        //     System.out.println("\ni: " + i + " " + "j: " + j);
        //     System.out.println("r: " + r);
        //     return f[i][j] = r;
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 【树型动规】: 亲爱的表哥的活宝妹，这里没能想对，是【树上背包】。。因为没能想到是【背包问题】，所以就写得狠乱了。。
        // public int maxProfit(int n, int[] p, int[] nt, int[][] h, int b) {
        //     // 【有向图】：标记，上下司关系，树
        //     g = new ArrayList [n];
        //     Arrays.setAll(g, z -> new ArrayList<Integer>());
        //     for (int [] e : h) {
        //         int u = e[0], v = e[1];
        //         g[u].add(v);
        //     }
        //     // 【树型动规】：亲爱的表哥的活宝妹，先写【记忆化深搜】
        //     this.n = n; this.p = p; this.f = f; this.b = b;
        //     // 【TODO：】状态压缩：【第2 和第3 维：0/1】标记、上司与自己，买与不买；定义重复，只需要知道【上司】是否买就可以了。。
        //     f = new Integer [n][2][2][b+1]; // 【第2 和第3 维：0/1】标记、上司与自己，买与不买
        //     return Math.max(dfs(0, 0, 0, b), dfs(0, 1, 0, b));
        // }
        // List<Integer> [] g;
        // int [] p, nt; 
        // int n, b;
        // Integer [][][] f;
        // // 【自顶向下】: 好像写不出；得写（自底向上）？好像【自底向上】更好写 ==> 确实是【自底向上的、树上背包】，离解题还差相对比较关键的、【背包问题】相关的思路
        // int dfs(int i, int j, int k, int v) {
        //     if (f[i][j][k][v] != null) return f[i][j][k][v];
        //     int half = Math.floor(p[i] / 2);
        //     // 在设置前提下：【自己买不买、上司买没买、余额限定】(自己)当前，能够收获的利益。。
        //     int r = (j == 1 ? (k == 1 ? (half <= v ? nt[i] - half) : (p[i] <= v ? nt[i] - p[i] : 0)) : 0);
        //     boolean doBuy = (j == 1 && (k == 1 && half <= v || k == 0 && p[i] <= v));
        //     if (g[i].size() == 0) 
        //         return f[i][j][k][v] = r;
        //     // 【树型动规】：遍历子节点
        //     // 这里多一步的【筛选】：众多下司、总投资金额有限，哪些下司买，哪些不买？？？
        //     // 【TODO：】亲爱的表哥的活宝妹，动规的这一维、【总金额限定】在多个子节点中的分配，还没能想透彻，先写后一题目。。
        //     // 如果，把树、众多子节点按【重链排序】：如按（赢利/投资）从大到小排序。。这里的思路不清楚。。。
        //     for (int mes : g[i]) {
        //         // 不买
        //         int l = dfs(mes, 0, (j == 1 && doBuy ? 1 : 0), v - (doBuy ? (k == 1 ? half : p[i]) : 0));
        //         // 买
        //         int r = dfs(mes, 1, (j == 1 && doBuy ? 1 : 0), v - (doBuy ? (k == 1 ? half : p[i]) : 0));
        //         r += dfs(mes, )
        //             }
        //     return f[i][j][k][v] = r;
        // }
        // // 亲爱的表哥的活宝妹，参照别人的题解，重新自己再写一遍
        // // 知道是【树上背包】后，感觉解这个题目、就再也没有难度了。。。就是需要自己再手写出来一遍
        // // 【树上背包】。。因为没能想到是【背包问题】，所以就写得狠乱了。。
        // // 亲爱的表哥的活宝妹，今天晚上回住处前，需要把这个题目，想透彻、写会！！
        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public int maxProfit(int n, int[] p, int[] nt, int[][] h, int b) { // [1,n]==>[0,n-1]
        //     // 【有向图】：标记，上下司关系，树
        //     g = new ArrayList [n];
        //     Arrays.setAll(g, z -> new ArrayList<Integer>());
        //     for (int [] e : h) {
        //         int u = e[0]-1, v = e[1]-1;
        //         g[u].add(v);
        //     }
        //     // 【树型动规】：亲爱的表哥的活宝妹，先写【记忆化深搜】
        //     this.n = n; this.p = p; this.f = f; this.b = b;
        //     // f = new Integer [n][2][2][b+1]; // 【第2 和第3 维：0/1】标记、上司与自己，买与不买
        //     // return Math.max(dfs(0, 0, 0, b), dfs(0, 1, 0, b));
        //     return dfs(0);
        // }
        // List<Integer> [] g;
        // int [] p, nt; 
        // int n, b;
        // // 【TODO：】亲爱的表哥的活宝妹，感觉这里写得、抄得还是狠不透彻、、傍晚回来再弄。。
        // int dfs(int u) { // U: 树节点； i:budget 预算； j: 上司买与不买
        //     // 定义：u 的所有儿子子树 v 的最大利润总和 subF[j][k]。
        //     int [][] subF = new int [b+1][2];
        //     for (int v : g[u]) {
        //         // 【当前子节点】：买与不买的、【自底向上】返回的结果
        //         int [][] fv = dfs(v);
        //         // for (int x = 0; x <= b; x++) {
        //         for (int x = b; x >= 0; x--) {
        //             // // 【当前、子节点】：买与不买的预算
        //             // int cv = p[v] / (y + 1);
        //             // 【树上背包】：0/1 背包【当前子节点】，买与不买...
        //             // 枚举子树 v 的预算为 fy
        //             // 当作一个体积为 fy，价值为 fv[fy][k] 的物品
        //             for (int fy = 0; fy <= x; fy++) { // 【当前子节点】：买，与不买，取全局最大值
        //                 for (int y = 0; y < 2; y++) {
        //                     subF[x][y] = Math.max(subF[x - fy][y] + fv[fy][y], subF[x][y]);
        //                 }
        //             }
        //         }
        //     }
        //     // 当前【父节点 u】：
        //     int [][] f = new int [b+1][2];
        //     // 【当前、父节点】：买与不买的预算
        //     int cost = p[u] / (j + 1);
        //     for (int x = b; x >= 1; x--) 
        //         for (int y = 0; y < 2; y++) 
        //             // 【上司节点】：买，与不买，取最大值
        //             f[x][y] = Math.max(subF[x - cost][1] + nt[u] - p[u], subF[x][0]);
        //     return f[i][j];
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public boolean checkEqualPartitions(int[] f, long target) {
        //     long r = 1;
        //     for (int v : f) 
        //         r *= (long)v;
        //     if (r != target * target) return false;
        //     for (int j = 0; j < (1 << f.length); j++) {
        //         r = 1;
        //         for (int i = 0; i < f.length; i++) 
        //             if ((j & (1 << i)) > 0)
        //                 r *= (long)f[i];
        //         if (r == target * target) return true;
        //     }
        //     return false;
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 思路，应该是把【距阵问题】转化成【图】？
        // public int minMoves(String[] classroom, int energy) {
        // }
        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 数组大小N[1,50000] 感觉这个，实时更新是要用到BIT 的
        // // 但是 100,000 以内的质数，就只能查个质数 Set<Integer> s = new HashSet<>();
        // public int[] maximumCount(int[] nums, int[][] queries) {
        // }
        // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // 就是【二维数组】上的相结动规，可是细节狠繁琐，不想再找这个错误掉的细节了。。。
        public int[][] minAbsDiff(int[][] a, int k) {
            int m = a.length, n = a[0].length;
            if (k == 1) return new int [m][n];
            int [][] f = new int [m+1-k][n+1-k];
            r = new TreeMap<>();
            for (int i = 0; i < k-1; i++)
                for (int j = 0; j < k-1; j++) 
                    r.put(a[i][j], r.getOrDefault(a[i][j], 0) + 1);
            for (int i = 0; i < m+1-k; i++) {
                // 【每一新行】：前【0,k-2】下标的数字
                for (int j = 0; j < k-1; j++) 
                    r.put(a[i+k-1][j], r.getOrDefault(a[i+k-1][j], 0) + 1); 
                for (int j = 0; j <= n-k; j++) {
                    // 【清理】：前一列【j-1】，行数为【i,i+k-1】
                    if (j > 0) {
                        for (int x = i; x < i+k && x < m; x++) {
                            r.put(a[x][j-1], r.get(a[x][j-1])-1); 
                            if (r.get(a[x][j-1]) == 0) r.remove(a[x][j-1]);
                        }
                    }
                    // 新增：第【j+k-1】列，行数为【i,i+k-1】
                    for (int x = i; x < i+k && x < m; x++) 
                        r.put(a[x][j+k-1], r.getOrDefault(a[x][j+k-1], 0) + 1);
                    f[i][j] = getMinAbsDiff();
                }
                // 【每一旧行】：前【0,k-2】下标的数字
                if (i == 0) continue;
                // 清理上一行的存值 
                for (int j = n-k; j < n; j++) {
                    r.put(a[i-1][j], r.get(a[i-1][j])-1);
                    if (r.get(a[i-1][j]) == 0) r.remove(a[i-1][j]);
                }
            }
            return f;
        }
        TreeMap<Integer, Integer> r;
        int getMinAbsDiff() {
            int f = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
            for (int key : r.keySet()) {
                if (f == Integer.MIN_VALUE) {
                    f = key;
                    continue;
                }
                min = Math.min(min, Math.abs(key - f));
                f = key;
            }
            return min;
        }
}
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！ 
        public static void main (String[] args) { 
		Solution s = new Solution ();

        int [][] a = new int [][] {{20195,15337,73189,16963,-90840},{10664,-43796,-61984,13235,-33619}};
        System.out.println("a.length: " + a.length);
        for (int z = 0; z < a.length; ++z)
            System.out.println(Arrays.toString(a[z]));

        int [][] r = s.minAbsDiff(a, 2);
        System.out.println("r.length: " + r.length);
        for (int z = 0; z < r.length; ++z)
            System.out.println(Arrays.toString(r[z]));
    }
}
// ListNode head = new ListNode(a0]);  
// head.buildList(head, a);
// head.printList(head);
// TreeNode rr = new TreeNode(a[0]);
// rr.buildTree(rr, a);
// rr.levelPrintTree(rr);
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】