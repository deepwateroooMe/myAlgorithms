import com.TreeNode;
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.*;
import java.util.stream.*;
import java.util.stream.Collectors;
import java.util.HashSet;
import java.util.Set;
import java.math.BigInteger;
import static java.util.stream.Collectors.toMap;
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
public class cmp {
    // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
    public static class Solution { 
        // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 这个破烂题目，狠简单，但就是细节繁琐，遇上一个刚过去两天假日把自己胀傻的脑袋不转的活宝妹。。改了这么久才把破烂细节改过来。。。
        // public int minMirrorPairDistance(int[] a) {
        //     int n = a.length, f = Integer.MAX_VALUE;
        //     Map<Integer, List<Integer>> m = new HashMap<>();
        //     for (int i = 0; i < n; i++) 
        //         m.computeIfAbsent(a[i], z -> new ArrayList<>()).add(i);
        //     for (int i = 0; i < n; i++) {
        //         int v = a[i];
        //         int j = Integer.parseInt(new StringBuilder(String.valueOf(v)).reverse().toString());
        //         if (m.containsKey(j) && (v != j || m.get(j).size() > 1)) {
        //             List<Integer> li = m.get(j);
        //             // 【二分查找】：（有序链条）中的下标
        //             int idx = Collections.binarySearch(li, i); // java 里 binarySearch() 返回值的意义，还没理解透彻，还没写透彻
        //             int k = 0;
        //            if (idx >= 0) { // 应该只存在于 v == j 的情况里 
        //                while (idx < li.size() &&  li.get(idx) <= i) idx++;
        //                 k = idx;
        //             } else k = (idx + 1) * (-1);
        //             f = Math.min(f, li.size() > k ? Math.abs(i - li.get(k)) : Integer.MAX_VALUE);
        //         }
        //         if (f == 1) return 1;
        //     }
        //     return f == Integer.MAX_VALUE ? -1 : f;
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public int maxDistinct(String S) {
        //     int n = S.length(), r = 0; char [] s = S.toCharArray();
        //     int [] f = new int [26];
        //     for (char c : s)
        //         f[c-'a']++;
        //     for (int v : f)
        //         if (v > 0) r++;
        //     return r;
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 亲爱的表哥的活宝妹，放假两天吃喝了太多毒药，这两天有点儿冒傻，不知道哪里写错了，晚点儿再写这个
        // // 亲爱的表哥的活宝妹，不知道这里哪里细节写错了，还有最后几个测试用例没过。。。
        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public int countElements(int[] a, int k) {
        //     int n = a.length;
        //     if (k == 0) return n;
        //     Integer [] f = IntStream.range(0, n).boxed().toArray(Integer[]::new);
        //     Arrays.sort(f, (i, j)->a[i] != a[j] ? a[j] - a[i] : i - j);
        //     int p = a[f[0]], i = 1;
        //     while (i < n && a[f[i]] == p) i++;
        //     if (i == n) return 0;
        //     --k;
        //     while (k > 0 && i < n) {
        //         while (i < n && a[f[i]] == p) i++;
        //         if (i == n) return 0;
        //        p = a[f[i]];
        //        --k;
        //        i++;
        //     }
        //     if (i == n) return 0;
        //     while (i < n && a[f[i]] == p) i++;
        //     return n - i;
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 维护：【0,n-1】上（差分数组）％k 取余的余数
        // // BIT 【最大值、最小值、线段树？】 维护 【0,n-1】上（差分数组）％k 取余的余数，数量级在【0,10_000】不会超时
        // // 对每个 query, 求 [l,r] 差分数组 %k 区间的【>0 的最小、最大值 min-max】
        // // 若 min 与 max 不同，此 query 返回－1;
        // // 若 min 与 max 相同，此 query 返回？【TODO：】这里还有一点儿没想透彻。。
        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public long[] minOperations(int[] a, int k, int[][] qs) {
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public boolean completePrime(int v) {
        //     String S = String.valueOf(v);
        //     char [] s = S.toCharArray();
        //     int n = s.length, f = 0;
        //     for (int i = 0; i < n; i++) {
        //         f = f * 10 + s[i]-'0';
        //         if (!isPrime(f)) return false;
        //     }
        //     f = 0;
        //     for (int i = 1; i <= n-1; i++) {
        //         f = Integer.parseInt(S.substring(i, n));
        //         if (!isPrime(f)) return false;
        //     }
        //     return true;
        // }
        // boolean isPrime(int v) {
        //     if (v == 1) return false;
        //     for (int i = 2; i * i <= v; i++) 
        //         if (v % i == 0) return false;
        //     return true;
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public int[] minOperations(int[] a) {
        //     int n = a.length;
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 亲爱的表哥的活宝妹，觉得，这应该是【世界上最简单的动规】了吗？！！！除非笨宝妹把它写【TLE TLE TLE 超时】了。。。
        // // 这个破烂题目，感觉【动规】的思路极其简单，可是写的过程中，被亲爱的表哥的活宝妹、笨宝妹写趴了。。感觉昨天一整天昨天晚上大风带走了雨雪水湿夜间休息被世界上最贱恶的追杀谋杀杀的它们的贱鸡、贱畜牲恶吵，亲爱的表哥的活宝妹，写这个【动规】的过程中，脑袋就迷糊掉了、写不清楚了。。
        // public long maxPoints(int[] a, int[] b, int kk) {
        //     int n = a.length, k = 0;
        //     long [][] f = new long [n+1][kk > 0 ? kk+1 : n+1]; // O(NK)?O(NN)?
        //     for (int i = 0; i < n; i++) {
        //         k = Math.min(kk > 0 ? kk : n, i+1);
        //         System.out.println("" );
        //         System.out.println("i: " + i + " " + "k: " + k);
        //       // 把当前下标【i】强制为 a[] 里任务
        //         for (int j = 0; j <= k; j++) {
        //             System.out.println("j: " + j);
        //             f[i+1][j] = Math.max((j > 0 ? f[i][j-1] + (long)a[i] : f[i+1][j]), f[i][j] + (long)b[i]);
        //        // if (j < k)
        //        //          // 【TODO：】亲爱的表哥的活宝妹，亲爱的表哥的活宝妹、笨宝妹，这里忘记了：是怎么优化出、全局最优解的？？？
        //        //          f[i+1][j] = Math.max((j > 0 ? f[i][j-1] + (long)a[i] : 0), f[i][j] + (long)b[i]);
        //        //      else
        //        //      // if (j == i+1) //if (j > 0)
        //        //          // f[i+1][j] = (j > 0 ? f[i][j-1] + (long)a[i] : (long)b[i]);
        //        //          f[i+1][j] = Math.max(f[i][j] + (long)b[i], f[i][j-1] + (long)a[i]);
        //        // System.out.println("f.length: " + f.length);
        //        // for (int z = 0; z < f.length; ++z)
        //        //     System.out.println(Arrays.toString(f[z]));
        //         }
        //     }
        //    return kk > 0 ? f[n][kk] : LongStream.of(f[n]).max().getAsLong();
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public int[] sortByReflection(int[] a) {
        //     int n = a.length;
        //     Integer [] f = IntStream.range(0, n).boxed().toArray(Integer[]::new);
        //     Arrays.sort(f, new Comparator<Integer> () {
        //             @Override public int compare(Integer i, Integer j) {
        //                 int x = Integer.parseInt(removeLeadingZeroes(new StringBuilder(Integer.toBinaryString(a[i])).reverse().toString()), 2);
        //                 int y = Integer.parseInt(removeLeadingZeroes(new StringBuilder(Integer.toBinaryString(a[j])).reverse().toString()), 2);
        //                 int cmp = x - y;
        //                 if (cmp != 0) return cmp;
        //                 return a[i] - a[j];
        //             }
        //         });
        //     System.out.println(Arrays.toString(f));
        //     int [] r = new int [n];
        //     for (int i = 0; i < n; i++)
        //         r[i] = a[f[i]];
        //     System.out.println(Arrays.toString(r));
        //     return r;
        // }
        // public String removeLeadingZeroes(String num){
        //     int i=0;
        //     char charArray[] = num.toCharArray();
        //     for( ; i<= charArray.length; i++){
        //         if(charArray[i] != '0'){
        //             break;
        //         }
        //     }
        //     return (i == 0) ? num :num.substring(i);
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // public int largestPrime(int n) {
        //     if (n < 2) return 0;
        //     for (int i = n; i >= 2; i--) {
        //         if (!isPrime(i)) continue;
        //         return i;
        //     }
        //     return 0;
        // }
        // boolean isSumable(int v) {
        // }
        // boolean isPrime(int v) {
        //     for (int i = 2; i * i <= v; i++) 
        //         if (v % i == 0) return false;
        //     return true;
        // }

        // // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // // 亲爱的表哥的活宝妹，读不懂这个破烂题目... 可能会超时？？？？950/979 passed
        // public long totalScore(int hp, int[] a, int[] b) {
        //     int n = a.length, j = 0, cur = hp;
        //     long r = 0;
        //     // int [] f = new int [n+1], ff = new int [n+1]; // a[i] 前缀和
        //     // for (int i = 0; i < n; i++) {
        //     //     f[i+1] = f[i] + a[i];
        //     //     ff[i+1] = ff[i] + b[i];
        //     // }
        //     // 先，试写【暴力解法】
        //     for (int i = 0; i < n; i++) {
        //         cur = hp;
        //         j = i;
        //         while (j < n && cur > 0 && cur - a[j] >= b[j]) {
        //             r ++;
        //             cur -= a[j];
        //             j ++;
        //         }
        //     }
        //     return r;
        // }

        // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
        // 亲爱的表哥的活宝妹，感觉，这个破烂题目，像是：【树型动规】中的【换根、树型动规】？
        // 可是，【换根树型动规】的细节，感觉被亲爱的表哥的活宝妹、笨宝妹忘记光了。。。        
        public int[] maxSubgraphScore(int n, int[][] egs, int[] a) {
            this.n = n; g = new ArrayList[n]; this.a = a; 
            Arrays.setAll(g, z -> new ArrayList<Integer>());
            for (int [] e : egs) {
                int u = e[0], v = e[1];
                g[u].add(v);
                g[v].add(u);
            }
            // 纪录【整个树、不是子树！】： good － bad 节点数
            // 【TODO：】应该纪录，以【0】为根节点的树，以【i】为根节点的（子树）上， good/bad 节点数『最多/最少』的（路径 Path）上的 good/bad 节点个数
            f = new int [n]; ff = new int [n];
            fa = dep = siz = son = top = dfn = rnk = new int [n];
            // 预处理数据：数据【初始化：以 0 为根节点】当作（有向树）来遍历
            // 【TODO：】亲爱的表哥的活宝妹、笨宝妹觉得，这里应该加上【重链树剖？排序】才更方便，这里（重链）定义为 good 节点最多的子树链？
            // 【TODO：】亲爱的表哥的活宝妹，亲爱的表哥的活宝妹、笨宝妹，这里如果 good 用【重链重儿了】纪录，是否同时同步纪录 bad 用【最轻链、最轻儿子】来也纪录？
            // 【TODO：】【重链树剖？排序】
            // 【TODO：】不用去想【重链路、轻链路】，
            // 感觉这里涉及【所有子树】的参与与否，经典题型如（没有上司的舞会）？某个上司的任何下属（及其下属）都是可能参与的，
            // 所以涉及任何子树的【参与与否】的动规选择与状态转换，那就仍然是数【子树里的、good/bad 总数】最方便
            dfs(0, -1);
            // 【重链】搭建
            idx = 0;
            // dfsdfs(0, 0);
            // 【换根动规】：可能会影响【重链】，可能把一个重链拆成 2 个。。。

            // 【换根动规】：
            // 感觉这里涉及【所有子树】的参与与否，经典题型如（没有上司的舞会）？某个上司的任何下属（及其下属）都是可能参与的，
            // 所以涉及任何子树的【参与与否】的动规选择与状态转换，那就仍然是数【子树里的、good/bad 总数】最方便
            r = new int [n];
            // 【换根动规】：要考虑换树，对重链的影响
            dfsdfs(0, -1);
            return r;
        }
        List<Integer> [] g;
        int n, idx; int [] a;
        int [] r, f, ff;
        // // 求解： r[] 不按 idx[0...n-1] 序，按树遍历
        // void dfsdfs(int u, int p) {
        //     int max = f[u] - ff[u];
        //     if (son[u] != 0) {
        //         // 【根节点 u】＋【 son[u] 重链路】
        //         max = Math.max(max, f[son[u]] - ff[son[u]] + a[u] * (a[u] > 0 ? 1 : -1));
        //         // 【TODO：】，亲爱的表哥的活宝妹，亲爱的表哥的活宝妹、笨宝妹，这里，只考虑了：
        //         //     以【 u】为根节点的原树的子树，和
        //         //     以【son[u]】为根节点的重链路＋子树【根节点 u】：一条路径 path
        //         //     而没能考虑，包括：其它非【重链】Path, 和（换根前换根后）形成的【新、前父节点 u 链路 Path】
        //         // 【TODO：】感觉，这里应该存在一个、笨宝妹脑袋里冒出来的【重链路】与【轻链路】的贪心解法、或优化存在，才对。。
        //         // 亲爱的表哥的活宝妹，亲爱的表哥的活宝妹、笨宝妹，今天写不到这个破烂题目。。。改天、将来，亲爱的表哥的活宝妹、笨宝妹可能写得出来。、。。
        //         dfsdfs(son[u], ftop); // ftop: 【重链的顶端节点】
        //     }
        //     for (int v : g[u]) {
        //         if (v != son[u] && v != fa[u])
        //             dfsdfs(v, v); // 轻链：以自己为（顶端节点）
        //     }
        // }
        void dfs(int u, int p) {
            fa[u] = p;
            dep[u] = (p == -1 ? 0 : dep[p]) + 1;
            siz[u] = 1;
            
            f[u] = a[u]; // 【初始化】当前（根节点） 
            // 【0 为根节点、有向树：叶子节点】
            if (g[u].size() == 1 && g[u].get(0) == p) {
                // f[u] = a[u];      // good
                ff[u] = 1 - a[u]; // bad
                return ;
            }
            for (int v : g[u]) {
                if (v == p) continue;
                dfs(v, u);
                siz[u] += siz[v];
                // 【重链重儿子】：实时更新
                // if (siz[v] > siz[son[u]]) // 【TODO：】这个【重链】的比较标准，不对
                if (f[v] - ff[v] > f[son[u]] - ff[son[u]]) 
                    son[u] = v;
                
                f[u] += f[v];
                ff[u] += ff[v];
            }
            ff[u] += 1 - a[u];
        }        
        int [] fa, dep, siz, son, top, dfn, rnk;
        void dfsdfs(int u, int ftop) { // ftop: 【重链的顶端节点】
            top[u] = ftop;
            dfn[u] = ++idx;
            rnk[idx] = u;

            if (son[u] != 0)
                dfsdfs(son[u], ftop); // ftop: 【重链的顶端节点】
            for (int v : g[u]) {
                if (v != son[u] && v != fa[u])
                    dfsdfs(v, v); // 轻链：以自己为（顶端节点）
            }
        }
    }
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！ 
        public static void main (String[] args) { 
		Solution s = new Solution ();

        int []  a = new int []  {1, 1};
        int [] b = new int [] {1, 1};

        long r = s.totalScore(2, a, b);
        System.out.println("r: " + r);
    }
}
// ListNode head = new ListNode(a0]);  
// head.buildList(head, a);
// head.printList(head);
// TreeNode rr = new TreeNode(a[0]);
// rr.buildTree(rr, a);
// rr.levelPrintTree(rr);
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
//  【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】