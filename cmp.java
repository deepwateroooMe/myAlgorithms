import com.ListNode;

import java.util.HashMap;

import java.util.Map;

import java.util.ArrayList;

import java.util.*;

import java.util.stream.*;

import java.util.stream.Collectors;

import java.util.HashSet;

import java.util.Set;

import java.math.BigInteger;

import static java.util.stream.Collectors.toMap;

public class cmp {
    public static class Solution {

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// // 亲爱的表哥的活宝妹，现在【不再贫血？】的亲爱的表哥的活宝妹，能够把这些、先前、搞不明白的难题，这次都弄明白了。。
		// // 对照着【题解】来写，但把【每个细节】都弄懂，弄明白！！！
		// // BIT 的【两个操作】： i += i & -i 和 i &= i-1    原理，忘记了。。【TODO】：是一样的吗？
		// // BIT 的【两个操作】： i += i & -i 和 i -= i & -i 原理，忘记了。。【TODO】：
		// class BIT {
		// 	// 这里需要用到 2 个，直接使用一个数组了
		// 	private final int [][] f;
		// 	public BIT (int n) {
		// 		// 【0】: 频次计数；每个有效长度，所出现的次数
		// 		// 【1】：值与频次、乘积、累积和。
		// 		f = new int [n+1][2]; 
		// 	}
		// 	// op =  1，添加一个 size
		// 	// op = -1，移除一个 size
		// 	public void update(int size, int op) { // 包括了：添加与删除、增加与减少，两种效果的操作。这也是一种归纳。。 
		// 		for (int i = f.length-size; i < f.length; i += i & -i) {
		// 			f[i][0] += op;// 统计个数
		// 			f[i][1] += op * size; // 累积效果：片段长度大小与频率的、累积和
		// 		}
		// 	}
		// 	// 返回 >= size 的元素个数，元素和
		// 	public int[] query(int size) {
		// 		int cnt = 0, sum = 0;
		// 		for (int i = f.length-size; i > 0; i &= i-1) {
		// 			cnt += f[i][0];
		// 			sum += f[i][1];
		// 		}
		// 		return new int [] {cnt, sum};
		// 	}
		// }
		// // op =  1，【添加】一个结束位置 i
		// // op = -1，【移除】一个结束位置 i
		// void update(int i, int op) {
		// 	// 【有序集合】查询：《 i 的【前一个、结束位置】
		// 	Integer pre = ts.floor(i);
		// 	if (pre == null)
		// 		pre = ts.last();
		// 	// 【有序集合】查询：> i 的【下一个、结束位置】
		// 	Integer next = ts.ceiling(i);
		// 	if (next == null)
		// 		next = ts.first();
		// 	// 【先】：反操作，【结束位置 i】有无之前的、反操作
		// 	f.update((next - pre + n - 1) % n + 1, -op); // 移除/添加旧长度
		// 	// 【再】：【结束位置 i】相关的，两片段操作
		// 	f.update((i - pre + n) % n, op); // 添加/移除新长度
		// 	f.update((next - i + n) % n, op);// 添加/移除新长度
		// }
		// // 添加一个结束位置 i
		// void add(int i) {
		// 	if (ts.isEmpty())
		// 		f.update(n, 1); // ???
		// 	else
		// 		update(i, 1);
		// 	ts.add(i);
		// }
		// // 移除一个结束位置 i
		// void delete(int i) {
		// 	ts.remove(i); // 【删除】：要求的结束位置 i
		// 	if (ts.isEmpty()) // 撤销：先前添加过的，长度为 n 的一个片段
		// 		f.update(n, -1);
		// 	else
		// 		update(i, -1);
		// }
		// TreeSet<Integer> ts;
		// BIT f;
		// int n;
		// public List<Integer> numberOfAlternatingGroups(int [] a, int[][] qs) {
		// 	n = a.length;
		// 	ts = new TreeSet<>();
		// 	f = new BIT(n);
		// 	// 【扫数组】：纪录【结束位置】预处理等
		// 	for (int i = 0; i < n; i++)
		// 		if (a[i] == a[(i+1) % n]) // 【环形数组】：a[n-1] == a[0] 等
		// 			add(i); // 添加，一个结束位置 i
		// 	List<Integer> ans = new ArrayList<>();
		// 	for (int [] q : qs) {
		// 		if (q[0] == 1) {
		// 			if (ts.isEmpty())
		// 				ans.add(n); // 每个长为 size 的子数组都符合要求,
		// 			// 是因为【整个数组】、不存在、任何中断点，每个下标，都可以作为所要求的、任意长度片段的起点
		// 			else { // 数组中存在，中断点，【环形数组】【固定长度】的累计和
		// 				int [] res = f.query(q[1]);
		// 				ans.add(res[1] - res[0] * (q[1] - 1));
		// 			}
		// 		} else { // 要：修改数组某个下标的值。这种操作，不求答案，只有后续影响
		// 			int i = q[1];
		// 			if (a[i] == q[2]) continue; // 没有影响
		// 			int pre = (i - 1 + n) % n;
		// 			int next = (i + 1) % n;
		// 			// 修改前，先去掉结束位置
		// 			if (a[pre] == a[i])
		// 				delete(pre);
		// 			if (a[i] == a[next])
		// 				delete(i);
		// 			// 【修改 a[i] 】
		// 			a[i] ^= 1;
		// 			// 修改后，添加新的结束位置
		// 			if (a[pre] == a[i])
		// 				add(pre);
		// 			if (a[i] == a[next])
		// 				add(i);
		// 		}
		// 	}
		// 	return ans;
		// }
		// 【TODO】：亲爱的表哥的活宝妹，改天会把这个仔细 debug 出来的。。
		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 		// 亲爱的表哥的活宝妹，上次写，几乎是看着它人的源码分析，几乎照抄
// 		// 亲爱的表哥的活宝妹，【好背题目。。】今天这会儿、再自己背一遍，看能背出来吗？
// 		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 		// 亲爱的表哥的活宝妹，现在【不再贫血？】的亲爱的表哥的活宝妹，能够把这些、先前、搞不明白的难题，这次都弄明白了。。
// 		// BIT 的【两个操作】： i += i & -i 和 i &= i-1    原理，忘记了。。【TODO】：是一样的吗？
// 		// BIT 的【两个操作】： i += i & -i 和 i -= i & -i 原理，忘记了。。【TODO】：
// 		class BIT { // 主要适用：【区间】查询 queries, 求和 preSum O(logN)
// 			// 本题特例：需要2 个，用个数组. 为什么需要2 个呢？
// 			// 一个【0】：纪录，每个长度在【0,N】范围内、任何长度的、片段的【出现频率】
// 			// 一个【1】：纪录，每个长度在【0,N】范围内、【区间的【0,M】、长度计数、频率累积和？】，像是求【数组的 preSum】
// 			int [][] f; // 下标从1 开始
// 			int n;
// 			public BIT(int n) {
// 				this.n = n;
// 				f = new int [n+1][2];
// 			}
// 			// op: 如【游戏橱架里，网络异步调用、操作符】自定义不同操作，这里两种
// 			// -1: 【删除】一个长度为 i 的片段 
// 			// +1: 【添加】一个长度为 i 的片段 
// 			public void update(int i, int op) { // 添加、删除：一个长度为 i 的片段, 频次为 1
// 				// 【TODO】：【树状数组】里，当下标【1,N】视作【片段长度1-N】，怎么更新这个
// 				// 【TODO】：亲爱的表哥的活宝妹，这里一定写错了，因为，还没能【参透：树状数组，下标的遍历原理】。。。
// 				// for 。。。这里需要一个：树状数组的、极特殊【遍历】：遍历到，下标 i ，在树状数组里，被计入 partial-preSum 的每个下标节点
// 				// 【TODO】：亲爱的表哥的活宝妹，下面真像是在【背答案】：为什么倒着遍历，怎么会倒着遍历到 i 的最高1 数位？
// 				// f[i][0]: f[i] 定义为：片段长度在【0,i】范围内的、所有片段的频率累积和。亲爱的表哥的活宝妹的、这个理解，对吗？【TODO】：
// 				// 当把 f[i] 定义为【区间和】, 那么更新长度为 i 的片段，就该仅只影响【前缀和、树装数组】f[i] 的【i,N】区间的下标
// 				for (int j = i; j <= n; j += (j & -j)) {
// 				// for (int j = n; j >= i; j -= (j & -j)) {
// 					f[j][0] = f[j][0] + op * 1; // 【0】：只计数，只计频次
// 					f[j][1] = f[j][1] + op * i; // [1]: 这里像是写错了，为什么会 *i? 片段的长短，是答案的一个成分，需要累积求和
// 				}
// 				// f[i][0] = f[i][0] + op * 1; // 【0】：只计数，只计频次
// 			}
// 			// 求：片段长度在【i,N】范围内的、所有可能长度、各长度出现计数的【累积和】
// 			// 那么，这里【查询】的，就是 f[i][2] 里的【区间】【累积和】，像是【数组的 preSum】
// 			public int [] query(int i) {
// 				int totCnts = f[n][0] - f[i-1][0]; // 把它理解成了 preSum 数组，求【区间和】
// 				int ttLenFreq = f[n][1] - f[i-1][1];
// 				return new int [] {totCnts, ttLenFreq};
// 			}
// 		}
// 		TreeSet<Integer> ts; // 纪录：所有的结束点下标
// 		BIT f;
// 		int n;
// 		// void add(int i, int op) { // 【TODO】：哪里，调用这个方法了？
// 		void add(int i) { // 【TODO】：哪里，调用这个方法了？
// 			if (ts.isEmpty()) // 【初始化】：添加一个长度为N 的片段，1 次
// 				f.update(n, 1); // BIT 里先【添加哨兵】
// 			f.update(i, 1);
// 			ts.add(i); // 记下这个【结束下标】
// 		}
// 		// 【撤销 op=-1】或是【添加 op=1】：1 个长度为 i 的片段。包括 ts 与 BIT 两数据结构里的操作
// 		void update(int i, int op) {
// 			f.update(i, op);
// 			ts.remove(i);
// 			if (ts.isEmpty()) {
// 				f.update(n, 1); // 【添加一个：长度为 n 片段哨兵】
// 			}
// 		}
// 		public List<Integer> numberOfAlternatingGroups(int [] a, int[][] qs) {
// 			n = a.length;
// 			ts = new TreeSet<Integer>();
// 			f = new BIT(n);
// 			// 【预处理】数据：扫一遍数组，纪录所有【结束点】，必要的【树状数组】初始化
// 			for (int i = 0; i < n; i++) // 【环形数组】：每个下标，都需要考虑
// 				if (a[i] == a[(i+1) % n]) { // 当前数，与它后面的一个数，相同：当前下标，是一个【结束点】
// 					// 单列这个：像是【哨兵】，有个特殊【长度为N 片段的、初始化、般的添加】。
// 					// 因为【反操作时】若撤销掉最后一个结束点，该是不存在结束点的长度为 N 的片段
// 					add(i); // 添加一个【片段结束点】
// 				}
// 			System.out.println("ts.size(): " + ts.size());
// 			System.out.println(Arrays.toString(ts.toArray()));
// 			// 解答案：
// 			List<Integer> ans = new ArrayList<>();
// 			int oo = 0;
// 			for (int [] q : qs) {
// 				System.out.println("\n oo: " + oo);
// 				System.out.println(Arrays.toString(q));
// // 【求解】：长度为 q[1] 的片段总个数：所有、长度 >= q[1] 的【累积和】－【不符合、条件要求】的计数
// 				if (q[0] == 1) {
// 					int [] r = f.query(q[1]); // 2 个【树状数组】：所返回的【区间长度、累积频率】与【区间长度、累积Sum（长度×该长度频次）】
// 					ans.add(r[1] - r[0] * (q[1] - 1));
// 				} else {
// 					if (a[q[1]] == q[2]) continue; // 更原数组是一样的，无效跳过
// 					// 修改、某个下标的颜色值：它会影响【拆分一个片段为二、或是、合并二个片段为一】
// 					// 找：当前下标 q[1], 之前、和之后的、最近结束点
// 					// 【TODO】：下面，两种取值方法，原因原理？
// 					Integer pre = ts.lower(q[1]);
// 					if (pre == null) pre = ts.last();
// 					// The ceiling() method of java.util.TreeSet<E> class is used to return the least element in this set greater than or equal to the given element
// 					// Integer next = ts.higher(q[1]); // 【TODO】：感觉这里写错了，当前下标 i 的下一个结束点，是可能为 i 的
// 					Integer next = ts.ceiling(q[1]);
// 					if (next == null) next = ts.first();
// 					System.out.println("pre: " + pre);
// 					System.out.println("next: " + next);
// 					// 把【修改】定义为：在2 种可能的动态变化下，概括抽象为，【先执行，相反的操作；再执行，更新后的需要操作】
// 					// 为什么呢？因为【树状数组】是【O(logN) 前缀和数组】，以【片段长度】为下标的计量单位，合并与拆分，涉及几个不同的片段长度，务必先反操作
// 					// 区分：修改当前下标后，是【合并】还是【拆分】，2 种操作里的哪一种
// 					if (a[q[1]-1] != q[2]) { // 先前是一样的、先前是分开的2 片段，现在执行【合并操作】：合并【pre,next】片段
// 						// 【撤销】：先前分开的 2 个片段、相关
// 						update((q[1] - pre + n) % n, -1);
// 						update((next - q[1] + n) % n, -1);
// 						// 执行：【合并】成1 个片段的、更新
// 						update((next - pre + n) % n, 1);
// 					} else { // 先前不一样，是一个片段；现在【拆分】成为了2 个片段 
// 						update((next - pre + n) % n, -1);
// 						update((q[1] - pre + n) % n, 1);
// 						update((next - q[1] + n) % n, 1);
// 					}
// 				}
// 			}
// 			return ans;
// 		}

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// int [][] dirs = {{1, 0}, {0, 1}, {0, -1}, {-1, 0}};
		// public int finalPositionOfSnake(int n, List<String> l) {
		// 	Map<String, Integer> m = new HashMap<>();
		// 	m.put("DOWN", 0);
		// 	m.put("RIGHT", 1);
		// 	m.put("LEFT", 2);
		// 	m.put("UP", 3);
		// 	int r = 0;
		// 	for (int i = 0; i < l.size(); i++) {
		// 		int [] d = dirs[m.get(l.get(i))];
		// 		int x = r / n, y = r % n;
		// 		r = (x + d[0]) * n + (y + d[1]);
		// 	}
		// 	return r;
		// }

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// // 亲爱的表哥的活宝妹，感觉这个题目，狠简单，数据规模极小，感觉狠容易过才对，为什么只有几个人写过了？？？
		// // 想简单了，【动规】的维数：【下标长度N】【每个下标取值范围51】【某一个数组的前一个数。。】
		// // 亲爱的表哥的活宝妹，先写、几乎万能的【记忆化深搜】！！
		// static final int mod = (int)1e9 + 7;
		// public int countOfPairs(int[] a) {
		// 	// 亲爱的表哥的活宝妹，这个题目，是可能过的，再稍微优化一下，不必要的遍历，不做；前合法性，不自己制造不合法和后续检测
		// 	n = a.length; m = Arrays.stream(a).max().getAsInt(); this.a = a; 
		// 	f = new Long [n][m+1][m+1];
		// 	// 遍历 j: A 数组的 a[0] 取值范围
		// 	for (int i = 0; i <= a[0]; i++) 
		// 		dfs(0, i, 0);
		// 	long r = 0;
		// 	for (int i = 0; i <= a[0]; i++) 
		// 		r = (r + f[0][i][0]) % mod;
		// 	return (int)r;
		// }
		// Long [][][] f;
		// int m, n; int [] a;
		// long dfs(int i, int j, int k) { // J: i 下标的当前取值 K: i-1 下标的 A 数组取值
		// 	if (f[i][j][k] != null) return f[i][j][k];
		// 	// 检查【合法性】：当前下标 i, 是否 a[i-1] <= a[i] && b[i-1] >= b[i] ？也可以不用检查，先过滤，仅只取合法范围内的值
		// 	if (i == 0 && n > 1 && (j > a[1] || a[0]-j < 0)) return f[i][j][k] = 0l;
		// 	if (i > 0 && a[i-1] - k < a[i] - j) return f[i][j][k] = 0l;
		// 	if (i == n-1) return f[i][j][k] = 1l;
		// 	// 遍历？当前下标 i, A 数组取值为 j, A 数组 i-1 下标取值为 k 时， i+1 下标， A 数组的取值范围
		// 	long r = 0;
		// 	for (int x = j; x <= a[i+1]; x++) 
		// 		r = (r + dfs(i+1, x, j)) % mod;
		// 	return f[i][j][k] = r;
		// }

		// // 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// // 亲爱的表哥的活宝妹，今天没带本子回来，先去写别的，再回来看这个题目
		// public int countGoodNodes(int[][] egs) {
		// 	n = egs.length + 1;
		// 	g = new ArrayList [n];
		// 	Arrays.setAll(g, z -> new ArrayList<>());
		// 	for (int [] e : egs) {
		// 		int u = e[0], v = e[1];
		// 		g[u].add(v);
		// 		g[v].add(u);
		// 	}
		// 	f = new int [n];
		// 	a = new Boolean [n];
		// 	dfs(0, -1);
		// 	System.out.println(Arrays.toString(f));
		// 	System.out.println(Arrays.toString(a));
		// 	int ans = 0;
		// 	// 亲爱的表哥的活宝妹，上面、这里、理解错了，不是说，所有【子树】相同大小，而是，所有的、【子树的子树】，都是合格好树！！
		// 	// 中间【隔了一代子树】！题型，像是，那个【小偷、树型偷东西】
		// 	// 【小偷、树型偷东西】：那个题型，也狠经典，可是亲爱的表哥的活宝妹，把它弄忘记了，一时想不起来，是如何隔代隔层偷东西的？
		// 	for (int i = 0; i < n; i++) 
		// 		if (a[i] != null && a[i]) ans++;
		// 	return ans;
		// }
		// List<Integer> [] g;
		// int [] f; // nodes count 
		// Boolean [] a; // balanced or not
		// int n;
		// void dfs(int u, int p) {
		// 	// if (g[u].size() == 1 && g[u].get(0) == p) {
		// 	if (g[u].size() == 1) {
		// 		f[u] = 1;
		// 		a[u] = true;
		// 		return ;
		// 	}
		// 	int val = 0, cnt = 0, ttCnt = 0;
		// 	// int cnt = 0;
		// 	for (int v : g[u]) {
		// 		if (v == p) continue;
		// 		dfs(v, u);
		// 		if (val == 0) {
		// 			val = f[v];
		// 		} else if (f[v] != val) 
		// 			a[u] = false;
		// 		ttCnt += f[v];
		// 		// if (a[v]) cnt++; // 【写错了】：这相标准，不对！！
		// 		if (a[v] || f[v] == val) cnt++;
		// 	}
		// 	if (a[u] == null && cnt == g[u].size()-(p == -1 ? 0 : 1)) a[u] = true;
		// 	else a[u] = false;
		// 	f[u] = ttCnt + 1;
		// }

		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹，就是一定要、一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
		// 【数据规模变大了】：【N=2000,a[i]=1000,preA[i]=1000】，上个写法，一定超时！！
		// 亲爱的表哥的活宝妹，亲爱的表哥的活宝妹、木头活宝妹！！要怎么想这相题目呢？
		// 【记忆化深搜】就不用再想了，如上题解法的【记忆化深搜】也一定超时！！
		// 【动规】：亲爱的表哥的活宝妹，可以试写。但感觉，这个数据规模的【动规】，仅只改写【记忆化深搜】为【动规】，亲爱的表哥的活宝妹感觉，【动规】，也还会超时！！
		// 【动规】＋必要的【优化】：什么狗屁【树状数组】【O(logN) 级别的、区间求和】优化，用起来，或许能过, 解法为O(N*M*log(M)) 应该能过
		// 【动规】＋必要的【优化】：也可以从，对【原数组 A 的、数据预处理】方面考虑，优化。也就是，将每个下标 i 的【合法、取值范围】极尽可能地缩小，缩小到，不TLE
		static final int mod = (int)1e9 + 7;
		public int countOfPairs(int[] a) {
			// 亲爱的表哥的活宝妹，这个题目，是可能过的，再稍微优化一下，不必要的遍历，不做；前合法性，不自己制造不合法和后续检测
			int n = a.length, m = Arrays.stream(a).max().getAsInt();
			if (n == 1) return n+1;
			// long [][] f = new long [n][m+1]; // 不再用，这个常规打开方式。。。
			// 【TODO】：BIT O(logN) 级别的【区间和】，可以取余 % mod 吗？应该也可以？
			BIT [] f = new BIT [n]; // 定义，每个 BIT-f[i]: 是个长度为 m+1 的数组。。。可是，亲爱的表哥的活宝妹，上个题目，还没能吃透，没能 debug 出来。。
			// 亲爱的表哥的活宝妹，不写这个题目了，过几天再写。。亲爱的表哥的活宝妹，这次一定把这个狗屁BIT 弄懂弄透彻。。
			for (int i = 0; i <= Math.min(a[0], a[1]); i++)
				f[0][i][0] = 1;
// 遍历：下标【1,n-1】
			for (int i = 1; i < n; i++) {
				// 遍历：当前下标 i 下，所有合法 j
				for (int j = 0; j <= Math.min(a[i], b); j++) {
				}
			}
			return (int)r;
		}
	}
// 亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！
    public static void main (String[] args) {
		Solution s = new Solution ();

		int []  a = new int []  {2, 3, 2};

		int r = s.countOfPairs(a);
		System.out.println("r: " + r);
    }
}
// ListNode head = new ListNode(a0]); 
// head.buildList(head, a);
// head.printList(head);
// Tree [N de rr = new [] TreeNode(a0);
// rr.buildTree(rr, a);
// rr.levelPrintTree(rr);
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【亲爱的表哥的活宝妹，任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】
// 【爱表哥，爱生活！！！任何时候，亲爱的表哥的活宝妹就是一定要,一定会嫁给活宝妹的亲爱的表哥！！！爱表哥，爱生活！！！】