#+latex_class: book
#+title: LeetCode Summary
#+author: deepwaterooo

* LeetCode Summary - Part III

** Two Pointers and Sliding Window
*** Valid Palindrome
*** Remove Nth Node From End of List
*** Remove Element
*** Remove Duplicates from Sorted Array
*** Merge Sorted Array
*** Implement strStr()
*** 3Sum
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)

The solution set must not contain duplicate triplets.

    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
#+BEGIN_SRC java
    (-1, 0, 1)
    (-1, -1, 2)
#+END_SRC

先排序,然后二分查找,复杂度 O(n 2 log n)。

#+BEGIN_SRC java
public List<List<Integer>> threeSum0(int[] num) {
    ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();
    Arrays.sort(num);  
    List<Integer> one = new ArrayList<Integer>();
    Map<List<Integer>, Integer> hash = new HashMap<List<Integer>, Integer>();
    int sum, j, k;
    for (int i = 0; i < num.length-2; i++) {
        if (i > 0 && num[i] == num[i-1]) continue;
        j = i + 1;
        k = num.length - 1;
        while (j < k) {
            while (k > num.length - 1 && num[k] == num[k+1]) k--;
            sum = num[i] + num[j] + num[k];
            if (sum > 0) k--;
            else if (sum < 0) j++;
            else {
                one.add(num[i]);
                one.add(num[j]);
                one.add(num[k]);
                if (!hash.containsKey(one))
                    hash.put(one, 1);
                one = new ArrayList<Integer>();
                j++;
                k--;
            }
        }
    }
    for(List<Integer> key : hash.keySet()) 
        result.add(key);
    return result;
}
#+END_SRC

*** 3Sum Closest
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

先排序,然后左右夹逼,复杂度 O(n 2 )。

**** 代码 1: 

#+BEGIN_SRC java
// LeetCode, 3Sum Closest
// 先排序,然后左右夹逼,时间复杂度 O(n^2),空间复杂度 O(1)
class Solution {
public:
    int threeSumClosest(vector<int>& num, int target) {
        int result = 0;
        int min_gap = INT_MAX;
        sort(num.begin(), num.end());
        for (auto a = num.begin(); a != prev(num.end(), 2);
             a = upper_bound(a, prev(num.end(), 2), *a)) {
            auto b = next(a);
            auto c = prev(num.end());
            while (b < c) {
                const int sum = *a + *b + *c;
                const int gap = abs(sum - target);
                if (gap < min_gap) {
                    result = sum;
                    min_gap = gap;
                }
                if (sum < target) ++b;
                else
                    --c;
            }
        }
        return result;
    }
};
#+END_SRC

**** 代码 2: 
#+BEGIN_SRC java
// LeetCode, 3Sum Closest
// 先排序,然后左右夹逼
// 时间复杂度 O(n^2),空间复杂度 O(1),与代码 1 比,有常数级的优化
class Solution {
public:
    int threeSumClosest(vector<int>& num, int target) {
        int result = 0;
        int min_gap = INT_MAX;
        sort(num.begin(), num.end());
        for (auto a = num.begin(); a != prev(num.end(), 2);
             a = upper_bound(a, prev(num.end(), 2), *a)) {
            auto b = next(a);
            auto c = prev(num.end());
            while (b < c) {
                const int sum = *a + *b + *c;
                const int gap = abs(sum - target);
                if (gap < min_gap) {
                    result = sum;
                    min_gap = gap;
                }
                if (sum < target)
                    b = upper_bound(b, c, *b);
                else
                    c = prev(lower_bound(b, c, *c));
            }
        }
        return result;
    }
};
#+END_SRC
from original......

*** 4Sum
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:
Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)
The solution set must not contain duplicate quadruplets.
    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

    A solution set is:
#+BEGIN_SRC java
    (-1,  0, 0, 1)
    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
#+END_SRC

*Tags:* Array, Hash Table, Two Pointers

跟 3Sum 很类似,先排序,然后二分查找,复杂度 O(n 3 log n),会超时。

然后想到,可以先缓存两个数的和,最终复杂度 O(n 3 )。这个策略也适用于 3Sum 。

**** 二分查找: 先排序,然后二分查找,复杂度 O(n^3*logn),会超时
#+BEGIN_SRC java
vector<vector<int>> fourSum(vector<int>& num, int target) {
    vector<vector<int>> result;
    if (num.size() < 4) return result;
    sort(num.begin(), num.end());
    auto last = num.end();
    for (auto a = num.begin(); a < prev(last, 3);
         a = upper_bound(a, prev(last, 3), *a)) {
        for (auto b = next(a); b < prev(last, 2);
             b = upper_bound(b, prev(last, 2), *b)) {
            for (auto c = next(b); c < prev(last);
                 c = upper_bound(c, prev(last), *c)) {
                const int d = target - *a - *b - *c;
                if (binary_search(next(c), last, d))
                    result.push_back(vector<int> { *a, *b, *c, d });
            }
        }
    }
    return result;
}
#+END_SRC
**** map 做缓存: 先缓存两个数的和,时间复杂度 O(n^3),空间复杂度 O(n^2)
#+BEGIN_SRC java
vector<vector<int> > fourSum(vector<int> &num, int target) {
    if (num.size() < 4) return vector<vector<int> >();
    sort(num.begin(), num.end());
    map<int, vector<pair<int, int> > > cache;
    for (size_t a = 0; a < num.size(); ++a) {
        for (size_t b = a + 1; b < num.size(); ++b) {
            cache[num[a] + num[b]].push_back(pair<int, int>(a, b));
        }
    }
    set<vector<int>> result; // 去重,因为 num 里有重复元素
    for (size_t c = 2; c < num.size(); ++c) {
        for (size_t d = c + 1; d < num.size(); ++d) {
            const int key = target - num[c] - num[d];
            if (cache.find(key) != cache.end()) {
                for (size_t k = 0; k < cache[key].size(); ++k) {
                    if (c <= cache[key][k].second) continue; // 有重叠
                    result.insert(vector<int> { num[cache[key][k].first],
                                num[cache[key][k].second], num[c], num[d] });
                }
            }
        }
    }
    return vector<vector<int> >(result.begin(), result.end());
}
#+END_SRC

*** Container With Most Water
*** Remove Duplicates from Sorted Array II
*** Partition List	
*** Two Sum II - Input array is sorted
*** Linked List Cycle II
*** Longest Substring Without Repeating Characters
*** Linked List Cycle
*** Sort Colors
*** Rotate List
*** Trapping Rain Water
*** Longest Substring with At Most Two Distinct Characters
*** Substring with Concatenation of All Words	
*** Minimum Window Substring
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

For example,
#+BEGIN_SRC java
S = "ADOBECODEBANC"
T = "ABC"
Minimum window is "BANC".
#+END_SRC

Note:

If there is no such window in S that covers all characters in T, return the emtpy string "".

If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.

*Tags:* Hash Table Two Pointers String

双指针, 动态维护一个区间。尾指针不断往后扫, 当扫到有一个窗口包含了所有 T 的字符后, 
然后再收缩头指针, 直到不能再收缩为止。最后记录所有可能的情况中窗口最小的

可以利用两个指针扫描（两个指针分别为start，i），以
#+BEGIN_SRC java
S = “e b a d b a c c b”（忽略空格），T = “abc” 为例：
     0 1 2 3 4 5 6 7 8
#+END_SRC

1. 初始化 start = i = 0

2. i 逐渐往后扫描S直到窗口S[start…i]包含所有T的字符，此时i = 6（字符c的位置）

3. 缩减窗口：此时我们注意到窗口并不是最小的，需要调整 start 来缩减窗口。缩减规则为：如果S[start]不在T中 或者 S[start]在T中但是删除后窗口依然可以包含T中的所有字符，那么start = start+1， 直到不满足上述两个缩减规则。缩减后i即为窗口的起始位置，此例中从e开始窗口中要依次删掉e、b、a、d，start最后等于4 ，那么得到一个窗口大小为6-4+1 = 3

4. start = start+1(此时窗口肯定不会包含所有的T中的字符)，跳转到步骤2继续寻找下一个窗口。本例中还以找到一个窗口start = 5，i = 8，比上个窗口大，因此最终的最小窗口是S[4…6]

具体实现时，要用哈希表来映射T中字符以便在O(1)时间内判断一个字符是否在T
中，由于是字符缘故，可以用数组简单的来实现；还需要一个哈希表来记录扫描
时T中的某个字符在S中出现的次数，也可以用数组实现

**** 时间复杂度 O(n), 空间复杂度 O(1)

c++版：
#+BEGIN_SRC java
class Solution {
public:
    string minWindow(string S, string T) {
        if (S.empty()) return "";
        if (S.size() < T.size()) return "";
        const int ASCII_MAX = 256;
        int appeared_count[ASCII_MAX];
        int expected_count[ASCII_MAX];
        fill(appeared_count, appeared_count + ASCII_MAX, 0);
        fill(expected_count, expected_count + ASCII_MAX, 0);
        for (size_t i = 0; i < T.size(); i++) expected_count[T[i]]++;
        int minWidth = INT_MAX, min_start = 0; // 窗口大小,起点
        int wnd_start = 0;
        int appeared = 0; // 完整包含了一个 T
        //尾指针不断往后扫
        for (size_t wnd_end = 0; wnd_end < S.size(); wnd_end++) {
            if (expected_count[S[wnd_end]] > 0) { // this char is a part of T
                appeared_count[S[wnd_end]]++;
                if (appeared_count[S[wnd_end]] <= expected_count[S[wnd_end]])
                    appeared++;
            }
            if (appeared == T.size()) { // 完整包含了一个 T
                // 收缩头指针
                while (appeared_count[S[wnd_start]] > expected_count[S[wnd_start]]
                       || expected_count[S[wnd_start]] == 0) {
                    appeared_count[S[wnd_start]]--;
                    wnd_start++;
                }
                if (minWidth > (wnd_end - wnd_start + 1)) {
                    minWidth = wnd_end - wnd_start + 1;
                    min_start = wnd_start;
                }
            }
        }
        if (minWidth == INT_MAX) return "";
        else return S.substr(min_start, minWidth);
    }
};
#+END_SRC

Java版： need to optimize my code....
#+BEGIN_SRC java
public String minWindow(String s, String t) {
    Map<Character, Integer> hash = new HashMap<Character, Integer>();
    for (int i = 0; i < t.length(); i++) 
        if (!hash.containsKey(t.charAt(i)))
            hash.put(t.charAt(i), 1);
        else hash.put(t.charAt(i), hash.get(t.charAt(i)) + 1);
    Map<Character, Integer> fnd = new HashMap<Character, Integer>();
    int fndCnt = 0;
    int slow = 0, fast = slow, size, minl = Integer.MAX_VALUE;
    StringBuffer res = new StringBuffer("");
    char j;
    while (fast < s.length()) {
        j = s.charAt(fast);
        if (hash.containsKey(j)) {
            if (!fnd.containsKey(j)) {
                fnd.put(j, 1);
                fndCnt++;
            } else {
                if (fnd.get(j) < hash.get(j)) 
                    fndCnt++;
                fnd.put(j, fnd.get(j) + 1);  
            }
        }
        if (fndCnt == t.length()) {
            char sc = s.charAt(slow);
            while (!fnd.containsKey(sc) || fnd.get(sc) > hash.get(sc)) {
                if (fnd.containsKey(sc) && fnd.get(sc) > hash.get(sc))
                    fnd.put(sc, fnd.get(sc) - 1);
                slow++;
                sc = s.charAt(slow);
            }
            if (fast - slow + 1 < minl) {
                minl = fast - slow + 1;
                res = new StringBuffer(s.substring(slow, fast + 1));
            }
        }
        fast++;
    }
    return res.toString();
}
#+END_SRC


** Backtracing and Recursion
*** Permutation Sequence
The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3):
#+BEGIN_SRC java
"123"
"132"
"213"
"231"
"312"
"321"
#+END_SRC
Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.
*** Gray Code
The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
#+BEGIN_SRC java
00 - 0
01 - 1
11 - 3
10 - 2
#+END_SRC
Note:
- For a given n, a gray code sequence is not uniquely defined.
- For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.
- For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.

格雷码 (Gray Code) 的定义请参考 wikipedia http://en.wikipedia.org/wiki/Gray_code。

自然二进制码转换为格雷码:g 0 = b 0 , g i = b i ⊕ b i−1

保留自然二进制码的最高位作为格雷码的最高位,格雷码次高位为二进制码的高位与次高位异或,其余各位与次高位的求法类似。例如,将自然二进制码 1001,转换为格雷码的过程是:保留最高位;然后将第 1 位的 1 和第 2 位的 0 异或,得到 1,作为格雷码的第 2 位;将第 2 位的 0 和第 3 位的 0 异或,得到 0,作为格雷码的第 3 位;将第 3 位的 0 和第 4 位的 1 异或,得到 1,作为格雷码的第 4 位,最终,格雷码为 1101。

格雷码转换为自然二进制码:b 0 = g 0 , b i = g i ⊕ b i−1

保留格雷码的最高位作为自然二进制码的最高位,次高位为自然二进制高位与格雷码次高位异或,其余各位与次高位的求法类似。例如,将格雷码 1000 转换为自然二进制码的过程是:保留最高位 1,作为自然二进制码的最高位;然后将自然二进制码的第 1 位 1 和格雷码的第 2 位 0 异或,得到1,作为自然二进制码的第 2 位;将自然二进制码的第 2 位 1 和格雷码的第 3 位 0 异或,得到 1,作为自然二进制码的第 3 位;将自然二进制码的第 3 位 1 和格雷码的第 4 位 0 异或,得到 1,作为自然二进制码的第 4 位,最终,自然二进制码为 1111。

格雷码有数学公式,整数 n 的格雷码是 n ⊕ (n/2)。

这题要求生成 n 比特的所有格雷码。

最简单的方法,利用数学公式,对从 0 ∼ 2 n − 1 的所有整数,转化为格雷码。

n 比特的格雷码,可以递归地从 n − 1 比特的格雷码生成。如图 §2-5所示。

#+CAPTION: Gray Code
[[./pic/grayCode.png]]

#+CAPTION: Gray Code 2
[[./pic/grayCode2.png]]

*** Word Break II
Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.

Return all such possible sentences.

For example, given
#+BEGIN_SRC java
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].

A solution is ["cats and dog", "cat sand dog"].
#+END_SRC
*Tags:* Dynamic Programming Backtracking
*** other Covered
- Subsets
  [[Subsets]]
- Subsets II
  [[Subsets II]]
- Combinationas
  [[Combinationas]]
- Letter Combinationas of Phone Number
  [[Letter Combinationas of Phone Number]]
- Permutation
  [[Permutation]]
- Permutation II
  [[Permutation II]]
- Palindrome Partitioning 
  [[Palindrome Partitioning ]]
- Restore IP Addresses
  [[Restore IP Addresses]]
- N-Queens 
  [[N-Queens]]
- N-Queens II
  [[N-Queens II]]
- Combination Sum
  [[Combination Sum]]
- Combination Sum II
  [[Combination Sum II]]
- Generate Parentheses
  [[Generate Parentheses]]
- Sudoku Solver
  [[Sudoku Solver]]
- Word Search
  [[Word Search]]
- Word Ladder II
  [[Word Ladder II]]
- Regular Expression Matching
  [[Regular Expression Matching]]
- Wild Card Matching
  [[Wild Card Matching]]


** Bit Manipulation
*** Majority Element
    Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
    
    You may assume that the array is non-empty and the majority element always exist in the array.
    
    Credits:
    
    Special thanks to @ts for adding this problem and creating all test cases.
    
    *Tags:* Divide and Conquer, Array, Bit Manipulation

*** Subsets: Bit Manipulation
Given a set of distinct integers, S, return all possible subsets.

Note:
- Elements in a subset must be in non-descending order.
- The solution set must not contain duplicate subsets.
For example,
If S = [1,2,3], a solution is:
#+BEGIN_SRC java
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
#+END_SRC
*Tags:* Array Backtracking, Bit Manipulation
*** Single Number
    Given an array of integers, every element appears twice except for one. Find that single one.
    
    Note:
    
    Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
    
    *Tags:* Hash Table, Bit Manipulation

*** Single Number II
    Given an array of integers, every element appears three times except for one. Find that single one.

    Note:
    
    Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?


** 图 Graphics
*** Clone Graph
   Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
   
   OJ's undirected graph serialization:

   Nodes are labeled uniquely.
   
   We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.

   As an example, consider the serialized graph {0,1,2#1,2#2,2}.
   
   The graph has a total of three nodes, and therefore contains three parts as separated by #.
   
   1. First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
   2. Second node is labeled as 1. Connect node 1 to node 2.
   3. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.

Visually, the graph looks like the following:
[[./pic/clonegraph.jpg]]

**** 分析： 广度优先遍历或深度优先遍历都可以
**** DFS： 时间复杂度O(n), 空间复杂度O(n)
#+BEGIN_SRC java 
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    UndirectedGraphNode res = new UndirectedGraphNode(node.label);  // result head
    if (node.neighbors == null || node.neighbors.size() == 0) return res;

    Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
    Queue<UndirectedGraphNode> q = new LinkedList<UndirectedGraphNode>();
    q.add(node);                      // added first node, need add its all Neighbors as well
    map.put(node, res);

    List<UndirectedGraphNode> curNbr = new ArrayList<UndirectedGraphNode>();
    UndirectedGraphNode curr = null;
    while (!q.isEmpty()) {
        curr = q.poll();
        curNbr = curr.neighbors;                   // ori
        for (UndirectedGraphNode aNbr : curNbr) {  // for build connection among copies
            if (!map.containsKey(aNbr)) {
                UndirectedGraphNode acpNbr = new UndirectedGraphNode(aNbr.label);
                map.put(aNbr, acpNbr);
                map.get(curr).neighbors.add(acpNbr);
                q.add(aNbr);
            } else
                map.get(curr).neighbors.add(map.get(aNbr));                        
        }
    }
    return res;
}
#+END_SRC 
**** BFS：
*** Check whether the graph is bigraph
**** Topological Sort
Topological sorting for Directed Acyclic Graph (DAG) is a linear
ordering of vertices such that for every directed edge uv, vertex u
comes before v in the ordering. Topological Sorting for a graph is not
possible if the graph is not a DAG.

For example, a topological sorting of the following graph is “5 4 2 3
1 0″. There can be more than one topological sorting for a graph. For
example, another topological sorting of the following graph is “4 5 2
3 1 0″. The first vertex in topological sorting is always a vertex
with in-degree as 0 (a vertex with no in-coming edges).
#+CAPTION: Topological Sorting
[[./pic/topologicalSorting.png]]
**** Topological Sorting vs Depth First Traversal (DFS):
In DFS, we print a vertex and then recursively call DFS for its adjacent vertices. In topological sorting, we need to print a vertex before its adjacent vertices. For example, in the given graph, the vertex ‘5’ should be printed before vertex ‘0’, but unlike DFS, the vertex ‘4’ should also be printed before vertex ‘0’. So Topological sorting is different from DFS. For example, a DFS of the above graph is “5 2 3 1 0 4″, but it is not a topological sorting.
**** Algorithm to find Topological Sorting:
We recommend to first see implementation of DFS here. We can modify DFS to find Topological Sorting of a graph. In DFS, we start from a vertex, we first print it and then recursively call DFS for its adjacent vertices. In topological sorting, we use a temporary stack. We don’t print the vertex immediately, we first recursively call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of stack. Note that a vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on) are already in stack.
*** other Covered
- Word Ladder [[Word Ladder]]
- Word Ladder II
[[Word Ladder II]]


** Data Structure
*** Two Sum III
Design and implement a TwoSum class. It should support the following operations: add and find.
- add - Add the number to an internal data structure.
- find - Find if there exists any pair of numbers which sum is equal to the value.
For example,
#+BEGIN_SRC java
add(1); add(3); add(5);
find(4) -> true
find(7) -> false
#+END_SRC
*Tags:* Hash Table, Data Structure
#+BEGIN_SRC java

#+END_SRC

*** Min Stack
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
- push(x) -- Push element x onto stack.
- pop() -- Removes the element on top of the stack.
- top() -- Get the top element.
- getMin() -- Retrieve the minimum element in the stack.
 *Tags:* Stack Data Structure
#+BEGIN_SRC java
public static class MinStack {
    Stack<Integer> stack = new Stack<Integer>();
    Stack<Integer> minStack = new Stack<Integer>();
    public void push(int x) {
        stack.push(x);
        if (minStack.isEmpty() || x <= minStack.peek()) {
            minStack.push(x);
        }
    }

    public void pop() { // java boxing & unboxing, container, object specific methods
        if (stack.peek().intValue() == minStack.peek().intValue()) 
            minStack.pop();
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        if (!minStack.isEmpty()) return minStack.peek();
        else return -1;
    }
}
#+END_SRC
*** LRU Cache
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.
- get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
- set(key, value) - Set or insert the value if the key is not already
  present. When the cache reached its capacity, it should invalidate
  the least recently used item before inserting a new item.
#+BEGIN_SRC java
public static class LRUCache {
    public class Node {
        int key;
        int value;
        Node prev;
        Node next;
        public Node(int x, int y){
            key = x;
            value = y;
        }
    }

    private HashMap<Integer, Node> hash;
    private int cap;
    private int number;
    Node head;
    Node tail;
    public LRUCache(int capacity) {
        cap = capacity;
        number = 0;
        head = new Node(-1, -1);
        head.prev = null;
        head.next = null;
        tail = head;
        hash = new HashMap<Integer, Node>(capacity); // so I can restrict a size !!
    }
    
    public int get(int key) {
        Node res = hash.get(new Integer(key)); // don't understand here
        if (res != null) {
            refresh(res);   // update usage frequence
            return res.value;
        } else return -1;
        /*
          if (hash.containsKey(key)) {
          //Node res = hash.get(new Integer(key)); // don't understand here
          Node res = hash.get(key);
          refresh(res);   // update usage frequence
          return res.value;
          } else {
          return -1;
          }
        */
    }

    // so still, must maintain a doubly-linked list to order usage frequency
    public  void refresh(Node tmp) {
        if (tmp == head.next) return; // it's head already
            
        Node temp = head.next;  // head node in the hash
        Node prevNode = tmp.prev;
        Node nextNode = tmp.next;
        // set to be most recently used~~ move the tmp node to be head.next, connections
        head.next = tmp;  
        tmp.prev = head;
        tmp.next = temp;
        temp.prev = tmp;
        prevNode.next = nextNode;
        if (nextNode != null) 
            nextNode.prev = prevNode;
        else tail = prevNode;   // remember tail as well 
    }

    public void set(int key, int value) {
        Node res = hash.get(new Integer(key));
        if (res != null) {
            refresh(res);
            res.value = value;
        } else {
            //if (!hash.containsKey(key)) { // another way of detecting existing
            Node prevNode = new Node(key, value); 
            Node temp;
            if (number == cap) { // remove tail;
                temp = tail.prev;
                hash.remove(tail.key);      // remember to remove from hash too !!!
                if (temp != null) {
                    temp.next = null;
                }
                tail.prev = null;
                tail = temp;
                number--;
            }
            // add to tail first
            tail.next = prevNode;
            prevNode.prev = tail;
            tail = prevNode;
            refresh(prevNode);
            hash.put(key, prevNode); 
            number++;  // count node numbers
        }
    }
}
#+END_SRC


** 细节实现题
*** Pascal's Triangle
Given numRows, generate the first numRows of Pascal's triangle.

For example, given numRows = 5,
Return
#+BEGIN_SRC java
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
#+END_SRC

本题可以用队列,计算下一行时,给上一行左右各加一个 0,然后下一行的每个元素,就等于
左上角和右上角之和。

另一种思路,下一行第一个元素和最后一个元素赋值为 1,中间的每个元素,等于上一行的左
上角和右上角元素之和。

**** 从左到右: 时间复杂度 O(n^2), 空间复杂度 O(n)
#+BEGIN_SRC java
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (numRows == 0) return res;
    res.add(new ArrayList<Integer>(Arrays.asList(1)));
    for (int i = 2; i <= numRows; i++) {
        List<Integer> curr = new ArrayList<Integer>(i); // 本行
        for (int j = 0; j < i; j++) 
            curr.add(j, 1);
        List<Integer> prev = res.get(i - 2);           // 上一行
        for (int j = 1; j < i - 1; j++) 
            curr.set(j, prev.get(j - 1) + prev.get(j));//左上角和右上角之和
        res.add(curr);
    }
    return res;
}
#+END_SRC

**** 从右到左: 时间复杂度 O(n^2), 空间复杂度 O(n)

#+BEGIN_SRC java
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    List<Integer> arr = new ArrayList<Integer>();
    for (int i = 1; i <= numRows; i++) {
        for (int j = i - 2; j > 0; j--) {
            arr.set(j, arr.get(j - 1) + arr.get(j));
        }
        arr.add(1);
        res.add(new ArrayList<Integer>(arr));
    }
    return res;
}
#+END_SRC

*** Pascal's Triangle II
Given an index k, return the kth row of the Pascal's triangle.

For example, given k = 3,

Return [1,3,3,1].

Note:
Could you optimize your algorithm to use only O(k) extra space?

滚动数组。

#+BEGIN_SRC java
public List<Integer> getRow(int rowIndex) {
    List<Integer> arr = new ArrayList<Integer>();
    for (int i = 0; i <= rowIndex ; i++) 
        for (int j = i - 1; j > 0; j--) 
            arr.set(j, arr.get(j - 1) + arr.get(j));
    arr.add(1);
    return arr;
}
#+END_SRC

*** Two Sum
Given an array of integers, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.
#+BEGIN_SRC java
Input: numbers = {2, 7, 11, 15}, target = 9
Output: index1 = 1, index2 = 2
#+END_SRC

*Tags:* Array Hash Table

方法 1:暴力,复杂度 O(n 2 ),会超时

方法 2:hash。用一个哈希表,存储每个数对应的下标,复杂度 O(n)

**** hash。用一个哈希表,存储每个数对应的下标,复杂度 O(n)

#+BEGIN_SRC java
public int[] twoSum(int[] numbers, int target) {
    int [] result = new int[2];
    Map<Integer, Integer> hash = new HashMap<Integer, Integer>();
    for (int i = 0; i < numbers.length; i++) {
        if (!hash.containsKey(numbers[i]))
            hash.put(numbers[i], i+1);
        else if (numbers[i] * 2 == target && hash.containsKey(numbers[i])) {
            result[0] = hash.get(numbers[i]) <= i + 1 ? hash.get(numbers[i]) : i+1;
            result[1] = hash.get(numbers[i]) <= i + 1 ? i+1 : hash.get(numbers[i]);
            return result;
        }
    }
    int two;
    for(int i : numbers) {
        two = target - i;
        if (hash.containsKey(two)) {
            if (two != i) {
                result[0] = hash.get(i) <= hash.get(two) ? hash.get(i) : hash.get(two);
                result[1] = hash.get(i) <= hash.get(two) ? hash.get(two) : hash.get(i);
                return result;
            } 
        }
    }
    return result;
}
#+END_SRC

自已写的繁琐版的代码， 改天再看有没有优化吧。。。

*** Two Sum II - Input array is sorted
*** Insert Interval
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:

Given intervals [1, 3], [6, 9],  insert and merge [2, 5] in as [1, 5], [6, 9].

Example 2:

Given [1, 2], [3, 5], [6, 7], [8, 10], [12, 16],  insert and merge [4, 9] in as [1, 2], [3, 10], [12, 16].

This is because the new interval [4, 9] overlaps with [3, 5], [6, 7], [8, 10].

#+BEGIN_SRC java
public class Interval {
    int start;
    int end;
    Interval() {
        start = 0;
        end = 0;
    }
    Interval(int s, int e) {
        start = s;
        end = e;
    }
}
#+END_SRC

**** 时间复杂度 O(n), 空间复杂度 O(1)

c++版：
#+BEGIN_SRC java
class Solution {
public:
    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {
        vector<Interval>::iterator it = intervals.begin();
        while (it != intervals.end()) {
            if (newInterval.end < it->start) {
                intervals.insert(it, newInterval);
                return intervals;
            } else if (newInterval.start > it->end) {
                it++;
                continue;
            } else {
                newInterval.start = min(newInterval.start, it->start);
                newInterval.end = max(newInterval.end, it->end);
                it = intervals.erase(it);
            }
        }
        intervals.insert(intervals.end(), newInterval);
        return intervals;
    }
};
#+END_SRC

Java版：
#+BEGIN_SRC java
public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
    intervals.add(newInterval);
    Collections.sort(intervals, new Comparator<Interval>(){
            @Override
                public int compare(Interval a, Interval b) {
                return Integer.compare(a.start, b.start);
            }
        });
    for (int i = 0; i < intervals.size() - 1; i++) {
        int j = i + 1;
        if (intervals.get(i).end < intervals.get(j).start)
            continue;
        else if (intervals.get(i).end >= intervals.get(j).start
                 && intervals.get(i).end < intervals.get(j).end) {
            intervals.get(i).end = intervals.get(j).end;
            intervals.remove(intervals.get(j));
            --i;
        } else {
            intervals.remove(intervals.get(j));
            --i;
        }
    }
    return intervals;
}
#+END_SRC

*** Merge Intervals
Given a collection of intervals, merge all overlapping intervals.

For example,

Given [1, 3], [2, 6], [8, 10], [15, 18], 

return [1, 6], [8, 10], [15, 18].

复用一下 Insert Intervals 的解法即可, 创建一个新的 interval 集合, 然后每次从旧的里面取一个
interval 出来, 然后插入到新的集合中。

c++版：

#+BEGIN_SRC java
// LeetCode, Merge Interval
// 复用一下 Insert Intervals 的解法即可
// 时间复杂度 O(n1+n2+...), 空间复杂度 O(1)
class Solution {
public:
    vector<Interval> merge(vector<Interval> &intervals) {
        vector<Interval> result;
        for (int i = 0; i < intervals.size(); i++) {
            insert(result, intervals[i]);
        }
        return result;
    }
private:
    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {
        vector<Interval>::iterator it = intervals.begin();
        while (it != intervals.end()) {
            if (newInterval.end < it->start) {
                intervals.insert(it, newInterval);
                return intervals;
            } else if (newInterval.start > it->end) {
                it++;
                continue;
            } else {
                newInterval.start = min(newInterval.start, it->start);
                newInterval.end = max(newInterval.end, it->end);
                it = intervals.erase(it);
            }
        }
        intervals.insert(intervals.end(), newInterval);
        return intervals;
    }
};
#+END_SRC

#+BEGIN_SRC java
public List<Interval> merge(List<Interval> intervals) {
    Collections.sort(intervals, new Comparator<Interval>(){
            @Override
                public int compare(Interval a, Interval b) {
                return Integer.compare(a.start, b.start);
            }
        });
    for (int i = 0; i < intervals.size() - 1; i++) {
        int j = i + 1;
        if (intervals.get(i).end < intervals.get(j).start)
            continue;
        else if (intervals.get(i).end >= intervals.get(j).start
                 && intervals.get(i).end < intervals.get(j).end) {
            intervals.get(i).end = intervals.get(j).end;
            intervals.remove(intervals.get(j));
            --i;
        } else {
            intervals.remove(intervals.get(j));
            --i;
        }
    }
    return intervals;
}
#+END_SRC

*** Spiral Matrix
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

For example,
Given the following matrix:
#+BEGIN_SRC java
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
#+END_SRC

You should return [1, 2, 3, 6, 9, 8, 7, 4, 5].

模拟。时间复杂度 O(n^2), 空间复杂度 O(1)

c++版：
#+BEGIN_SRC java
vector<int> spiralOrder(vector<vector<int> >& matrix) {
    vector<int> result;
    if (matrix.empty()) return result;
    int beginX = 0, endX = matrix[0].size() - 1;
    int beginY = 0, endY = matrix.size() - 1;
    while (true) {
        // From left to right
        for (int j = beginX; j <= endX; ++j) result.push_back(matrix[beginY][j]);
        if (++beginY > endY) break;

        // From top to bottom
        for (int i = beginY; i <= endY; ++i) result.push_back(matrix[i][endX]);
        if (beginX > --endX) break;

        // From right to left
        for (int j = endX; j >= beginX; --j) result.push_back(matrix[endY][j]);
        if (beginY > --endY) break;

        // From bottom to top
        for (int i = endY; i >= beginY; --i) result.push_back(matrix[i][beginX]);
        if (++beginX > endX) break;
    }
    return result;
}
#+END_SRC
#+BEGIN_SRC java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> res = new ArrayList<Integer>();
    if (matrix == null || matrix.length == 0) return res;
    int size = matrix.length * matrix[0].length;
    int ibgn = 0, iend = matrix.length - 1;
    int jbgn = 0, jend = matrix[0].length - 1;
    boolean toup = false, toleft = false; // 向上， 向左
    while (res.size() < size && ibgn < matrix.length && jbgn < matrix[0].length) {
        for (int j = jbgn; j <= jend; j++) {
            if (res.size() == size) break;
            res.add(matrix[ibgn][j]);
        }
        ++ibgn;
        toleft = true;
        for (int j = ibgn; j <= iend; j++) {
            if (res.size() == matrix.length * matrix[0].length) break;
            res.add(matrix[j][jend]);
        }
        --jend;
        toup = true;
        if (toleft && res.size() < matrix.length * matrix[0].length) {
            for (int j = jend; j >= jbgn ; j --) {
                if (res.size() == matrix.length * matrix[0].length) break;
                res.add(matrix[iend][j]);
            }
            --iend;
            toleft = false;
        }
        if (toup && res.size() < matrix.length * matrix[0].length) {
            for (int i = iend; i >= ibgn ; i --) {
                if (res.size() == matrix.length * matrix[0].length) break;
                res.add(matrix[i][jbgn]);
            }
            ++jbgn;
            toup = false;
        }
    }
    return res;
}
#+END_SRC

*** Spiral Matrix II
Given an integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.

For example,
Given n = 3,

You should return the following matrix:
#+BEGIN_SRC java
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
#+END_SRC

这题比上一题要简单。
**** 时间复杂度 O(n^2), 空间复杂度 O(n^2)
#+BEGIN_SRC java
public int[][] generateMatrix(int n) {
    int [][] mat = new int[n][n];
    int bgn = 0, end = n - 1;
    int num = 1;
    while (bgn < end) {
        for (int j = bgn; j < end; j++) mat[bgn][j] = num++;
        for (int i = bgn; i < end; i++) mat[i][end] = num++;
        for (int j = end; j > bgn; j--) mat[end][j] = num++;
        for (int i = end; i > bgn; i--) mat[i][bgn] = num++;
        ++bgn;
        --end;
    }
    if (bgn == end) mat[bgn][bgn] = num;
    return mat;
}
#+END_SRC
**** 时间复杂度 O(n^2), 空间复杂度 O(n^2)
#+BEGIN_SRC java
public int[][] generateMatrix(int n) {
    int [][] mat = new int[n][n];
    int ibgn = 0, iend = n - 1;
    int jbgn = 0, jend = n - 1;
    int cnt = 1;
    while (true) {
        for (int j = jbgn; j <= jend; j++) mat[ibgn][j] = cnt++;
        if (++ibgn > iend) break;
                
        for (int j = ibgn; j <= iend; j++) mat[j][jend] = cnt++;
        if (jbgn > --jend) break;

        for (int j = jend; j >= jbgn ; j--) mat[iend][j] = cnt++;
        if (ibgn > --iend) break;
                
        for (int i = iend; i >= ibgn ; i--) mat[i][jbgn] = cnt++;
        if (++jbgn > jend) break;
    }
    return mat;
}
#+END_SRC

同自己的思路很像，但是要精练很多。。。

*** Multiply Strings
Given two numbers represented as strings, return multiplication of the numbers as a string.

Note: The numbers can be arbitrarily large and are non-negative.

高精度乘法。

常见的做法是将字符转化为一个 int,一一对应,形成一个 int 数组。但是这样很浪费空间,一
个 int32 的最大值是 2^31 − 1 = 2147483647,可以与 9 个字符对应,由于有乘法,减半,则至少可以
与 4 个字符一一对应。一个 int64 可以与 9 个字符对应。

**** 一个字符对应一个 int: 时间复杂度 O(n*m),空间复杂度 O(n+m)

**** 9 个字符对应一个 int64\textunderscore t: 时间复杂度 O(n*m/81),空间复杂度 O((n+m)/9)

看得头大，自已的土方法： 
#+BEGIN_SRC java
public int getVal(char x) {
    switch (x) {
    case '0': return 0;
    case '1': return 1;
    case '2': return 2;
    case '3': return 3;
    case '4': return 4;
    case '5': return 5;
    case '6': return 6;
    case '7': return 7;
    case '8': return 8;
    case '9': return 9;
    }
    return 0;
}

public String myMul(String a, char s) {
    StringBuffer res = new StringBuffer();
    int b = getVal(s);
    int leftover = 0;
    int curr = 0;
    for (int i = a.length() - 1; i >= 0 ; i--) {
        curr = (getVal(a.charAt(i)) * b + leftover) % 10 ;
        leftover = (getVal(a.charAt(i)) * b + leftover) / 10;
        res.insert(0, curr);
    }
    if (leftover > 0)
        res.insert(0, leftover);
    return res.toString();
}

public String myAdd(StringBuffer a, StringBuffer b) {
    StringBuffer res;
    res = new StringBuffer(a.length() < b.length() ? a : b);
    a = a.length() < b.length() ? b : a; // long
    b = res;   // short
    int gap = a.length() - b.length();
    int leftover = 0;
    int curr = 0;
    res = new StringBuffer("");
    for (int i = b.length() - 1; i >= 0; i--) {
        curr = (getVal(a.charAt(i+gap)) + getVal(b.charAt(i)) + leftover) % 10;
        leftover = (getVal(a.charAt(i+gap)) + getVal(b.charAt(i)) + leftover) / 10;
        res.insert(0, curr);
    }
    for (int i = gap - 1; i >= 0; i--) {
        curr = (getVal(a.charAt(i)) + leftover) % 10;
        leftover = (getVal(a.charAt(i)) + leftover) / 10;
        res.insert(0, curr);
    }
    if (leftover > 0)
        res.insert(0, leftover);
    return res.toString();
}
        
public String multiply(String num1, String num2) {
    if (num1 == null || num2 == null || num1.length() == 0 || num2.length() == 0) return "";
    if (num1.equals("0") || num2.equals("0")) return "0";  // forgot "0" case
    StringBuffer res, tmp = new StringBuffer();
    String temp;
    res = new StringBuffer(num1.length() < num2.length() ? num1 : num2);
    num1 = num1.length() < num2.length() ? num2 : num1; // long
    num2 = res.toString();   // short
    for (int i = num2.length() - 1; i >= 0 ; i--) {
        temp = myMul(num1, num2.charAt(i));
        if (i == num2.length() - 1)
            res = new StringBuffer(temp);
        else {
            tmp = new StringBuffer(temp);
            for (int j = 0; j < num2.length() - 1 - i; j++)
                tmp.append('0');
            res = new StringBuffer(myAdd(res, tmp));
        }
    }
    return res.toString();
}
#+END_SRC

*** Substring with Concatenation of All Words
You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.

For example, given:
#+BEGIN_SRC java
S: "barfoothefoobarman"
L: ["foo", "bar"]
#+END_SRC

You should return the indices: [0,9].
(order does not matter).

*Tags:* Hash Table, Two Pointers, String

#+BEGIN_SRC java
public List<Integer> findSubstring(String s, String[] l) {
    List<Integer> res = new ArrayList<Integer>();
    int n = l.length;
    int m = l[0].length();
    if (s.length() < n * m) return res;
    Map<String, Integer> hash = new HashMap<String, Integer>();
    for(String i : l)
        if (hash.containsKey(i)) hash.put(i, hash.get(i) + 1);                    
        else hash.put(i, 1); 
    Map<String, Integer> fnd = new HashMap<String, Integer>();
    String tmp;
    int cnt = 0;
    int j;
    for (int i = 0; i <= s.length() - m * n; i++) {
        tmp = s.substring(i, i + m);
        cnt = 0;
        j = i;
        fnd.clear();
        while (hash.containsKey(tmp) && (!fnd.containsKey(tmp) || fnd.get(tmp) < hash.get(tmp))) {
            if (!fnd.containsKey(tmp)) fnd.put(tmp, 1);
            else fnd.put(tmp, fnd.get(tmp) + 1);
            ++cnt;
            j += m;
            if (j + m <= s.length())
                tmp = s.substring(j, j + m);
        }
        if (cnt == n) res.add(i);
    }
    return res;
}
#+END_SRC

c++版：
#+BEGIN_SRC java
vector<int> findSubstring(string s, vector<string>& dict) {
    size_t wordLength = dict.front().length();
    size_t catLength = wordLength * dict.size();
    vector<int> result;
    if (s.length() < catLength) return result;
    unordered_map<string, int> wordCount;
    for (auto const& word : dict) ++wordCount[word];
    for (auto i = begin(s); i <= prev(end(s), catLength); ++i) {
        unordered_map<string, int> unused(wordCount);
        for (auto j = i; j != next(i, catLength); j += wordLength) {
            auto pos = unused.find(string(j, next(j, wordLength)));
            if (pos == unused.end() || pos->second == 0) break;
            if (--pos->second == 0) unused.erase(pos);
        }
        if (unused.size() == 0) result.push_back(distance(begin(s), i));
    }
    return result;
}
#+END_SRC

*** ZigZag Conversion	
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
#+BEGIN_SRC java
P   A   H   N
A P L S I I G
Y   I   R
#+END_SRC
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string text, int nRows);

convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".

要找到数学规律。真正面试中,不大可能出这种问题。

#+BEGIN_SRC java
n = 4:
P        I        N
A     L  S     I  G
Y  A     H  R
P        I
n = 5:
P           H
A        S  I
Y     I     R
P  L        I  G
A           N
#+END_SRC
#+CAPTION: ZigZag Conversion	
[[./pic/zigzag.png]]

所以,对于每一层垂直元素的坐标 (i, j) = (j + 1) ∗ n + i;对于每两层垂直元素之间的插入元
素(斜对角元素),(i, j) = (j + 1) ∗ n − i

#+BEGIN_SRC java
public String convert(String s, int nRows) {
    if (nRows <= 1 || s.length() <= nRows) return s;
    StringBuffer result = new StringBuffer();
    for (int i = 0; i < nRows; i++) {
        for (int j = 0, idx = i; idx < s.length();
             j++, idx = (2 * nRows - 2) * j + i) {
            result.append(s.charAt(idx));           // 垂直元素
            if (i == 0 || i == nRows - 1) continue; // 斜对角元素
            if (idx + (nRows - i - 1) * 2 < s.length())
                result.append(s.charAt(idx + (nRows - i - 1) * 2));
        }
    }
    return result.toString();
}
#+END_SRC
#+BEGIN_SRC java
string convert(string s, int nRows) {
    if (nRows <= 1 || s.size() <= 1) return s;
    string result;
    for (int i = 0; i < nRows; i++) {
        for (int j = 0, index = i; index < s.size();
             j++, index = (2 * nRows - 2) * j + i) {
            result.append(1, s[index]);             // 垂直元素
            if (i == 0 || i == nRows - 1) continue; // 斜对角元素
            if (index + (nRows - i - 1) * 2 < s.size())
                result.append(1, s[index + (nRows - i - 1) * 2]);
        }
    }
    return result;
}
#+END_SRC

*** Text Justification, bug...
Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

For example,
#+BEGIN_SRC java
words: ["This", "is", "an", "example", "of", "text", "justification."]
L: 16.
#+END_SRC

Return the formatted lines as:
#+BEGIN_SRC java
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
#+END_SRC

Note: Each word is guaranteed not to exceed L in length.

click to show corner cases.

Corner Cases:

A line other than the last line might contain only one word. What should you do in this case?

In this case, that line should be left-justified.

时间复杂度 O(n), 空间复杂度 O(1). 

c++版：
#+BEGIN_SRC java
// LeetCode, Text Justification
// 时间复杂度 O(n),空间复杂度 O(1)
class Solution {
public:
    vector<string> fullJustify(vector<string> &words, int L) {
        vector<string> result;
        const int n = words.size();
        int begin = 0, len = 0; // 当前行的起点,当前长度
        for (int i = 0; i < n; ++i) {
            if (len + words[i].size() + (i - begin) > L) {
                result.push_back(connect(words, begin, i - 1, len, L, false));
                begin = i;
                len = 0;
            }
            len += words[i].size();
        }
        // 最后一行不足 L
        result.push_back(connect(words, begin, n - 1, len, L, true));
        return result;
    }
    /**
     * @brief 将 words[begin, end] 连成一行
     * @param[in] words 单词列表
     * @param[in] begin 开始
     * @param[in] end 结束
     * @param[in] len words[begin, end] 所有单词加起来的长度
     * @param[in] L 题目规定的一行长度
     * @param[in] is_last 是否是最后一行
     * @return 对齐后的当前行
     */
    string connect(vector<string> &words, int begin, int end,
                   int len, int L, bool is_last) {
        string s;
        int n = end - begin + 1;
        for (int i = 0; i < n; ++i) {
            s += words[begin + i];
            addSpaces(s, i, n - 1, L - len, is_last);
        }
        if (s.size() < L) s.append(L - s.size(), ' ');
        return s;
    }
    /**
     * @brief 添加空格.
     * @param[inout]s 一行
     * @param[in] i 当前空隙的序号
     * @param[in] n 空隙总数
     * @param[in] L 总共需要添加的空额数
     * @param[in] is_last 是否是最后一行
     * @return 无
     */
    void addSpaces(string &s, int i, int n, int L, bool is_last) {
        if (n < 1 || i > n - 1) return;
        int spaces = is_last ? 1 : (L / n + (i < (L % n) ? 1 : 0));
        s.append(spaces, ' ');
    }
};
#+END_SRC

Java has a bug, will fix it later.....

#+BEGIN_SRC java
public StringBuffer addSpaces(StringBuffer s, int i, int n, int L, boolean last) {
    if (n < 1 || i > n - 1) return s;
    int spaces = last ? 1 : (L / n + (i < (L % n) ? 1 : 0));
    for (int j = 0; j < spaces; j++)
        s.append(" ");
    return s;
}
        
public StringBuffer connect(String [] words, int bgn, int end, int len, int L, boolean last) {
    StringBuffer s = new StringBuffer();
    int n = end - bgn + 1;
    for (int i = 0; i < n; i++) {
        s.append(words[bgn + i]);
        s = addSpaces(s, i, n - 1, L - len, last);
    }
    if (s.length() < L)
        for (int j = 0; j < L - s.length(); j++) 
            s.append(' ');
    return s;
}
        
public List<String> fullJustify(String[] words, int L) {
    List<String> res = new ArrayList<String>();
    int n = words.length;
    int bgn = 0, len = 0;
    for (int i = 0; i < n; i++) {
        if (len + words[i].length() + (i - bgn) > L) {
            res.add(connect(words, bgn, i - 1, len, L, false).toString());
            bgn = i;
            len = 0;
        }
        len += words[i].length();
    }
    res.add(connect(words, bgn, n - 1, len, L, true).toString());
    return res;
}
#+END_SRC

*** other Covered
- Majority Element	
- Container With Most Water
- Minimum Path Sum	
- Missing Ranges 	
- Find Minimum in Rotated Sorted Array
- Triangle
- Find Peak Element
- Find Minimum in Rotated Sorted Array II
- Jump Game II
- Word Ladder II


** Math
*** Add Binary
*** String to Integer (atoi)
*** Palindrome Number
*** Factorial Trailing Zeroes
*** Excel Sheet Column Title
*** Excel Sheet Column Number
*** Reverse Integer
*** Multiply Strings
*** Divide Two Integers
*** Fraction to Recurring Decimal
*** Permutation Sequence	
*** Next Permutation
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its
corresponding outputs are in the right-hand column.
#+BEGIN_SRC java
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
#+END_SRC

算法过程如图所示

#+CAPTION: Next Permutation
[[./pic/nextPermutation.png]]

#+BEGIN_SRC java
// LeetCode, Next Permutation
// 时间复杂度 O(n),空间复杂度 O(1)
class Solution {
public:
    void nextPermutation(vector<int> &num) {
        next_permutation(num.begin(), num.end());
    }
    template<typename BidiIt>
    bool next_permutation(BidiIt first, BidiIt last) {
        // Get a reversed range to simplify reversed traversal.
        const auto rfirst = reverse_iterator<BidiIt>(last);
        const auto rlast = reverse_iterator<BidiIt>(first);
        // Begin from the second last element to the first element.
        auto pivot = next(rfirst);
        // Find 'pivot', which is the first element that is no less than its
        // successor. 'Prev' is used since 'pivort' is a 'reversed_iterator'.
        while (pivot != rlast and !(*pivot < *prev(pivot)))
            ++pivot;
        // No such elemenet found, current sequence is already the largest
        // permutation, then rearrange to the first permutation and return false.
        if (pivot == rlast) {
            reverse(rfirst, rlast);
            return false;
        }
        // Scan from right to left, find the first element that is greater than
        // 'pivot'.
        auto change = find_if(rfirst, pivot, bind1st(less<int>(), *pivot));
        swap(*change, *pivot);
        reverse(rfirst, pivot);
        return true;
    }
};
#+END_SRC

#+BEGIN_SRC java
public void swap(int [] a, int i, int j) {
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}
        
public void nextPermutation(int[] a) {
    if (a == null || a.length < 2) return;
    int n = a.length - 1;
    int i = n;
    int j = n - 1;
    while (i >= 1) {
        while (j >= 0 && a[j] > a[i]) {
            j--;
            i--;
        } 
        if (j < 0 && i >= 1 ||
            (j >= 0 && i >= 1 && a[j] == a[i] && i - j >= 1)) {
            i--;
            j = i - 1;
        } else if (j >= 0 && a[j] < a[i]) {
            while (i <= n && a[i] > a[j]) i++;
            swap(a, j, i - 1);
            Arrays.sort(a, j + 1, n + 1); 
            return;
        }
        if (i < 1) {
            Arrays.sort(a);
            return;
        }
    }
}
#+END_SRC

*** Valid Number
*** Max Points on a Line
*** other Covered
- Plus One
  [[Plus One]]
- Roman to Integers
  [[Roman to Integers]]
- Integer to Roman
  [[Integer to Roman]]
- Pow(x, n)
  [[Pow(x, n)]]
- Sqrt(x)
  [[Sqrt(x)]]
