#+latex_class: book
#+title: LeetCode Summary
#+author: deepwaterooo

* LeetCode Summary - Part I

** 数组 Array
*** Remove Duplicates from Sorted Array
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,

Given input array A = [1,1,2],

Your function should return length = 2, and A is now [1,2].

**** 时间复杂度 O(n), 空间复杂度 O(1)
#+BEGIN_SRC java
public int removeDuplicates(int[] a) {
    if (a.length == 0) return 0;
    int idx = 0;
    for (int i = 1; i < a.length; i++) {
        if (a[idx] != a[i])
            a[++idx] = a[i];
    }
    return idx + 1;
}
#+END_SRC
**** 使用 STL, 时间复杂度 O(n), 空间复杂度 O(1)
#+BEGIN_SRC java
int removeDuplicates(int a[], int n) {
    return distance(a, unique(a, a + n));
}
#+END_SRC
**** 使用 STL, 时间复杂度 O(n), 空间复杂度 O(1)
#+BEGIN_SRC java
int removeDuplicates(int A[], int n) {
    return removeDuplicates(A, A + n, A) - A;
}
template<typename InIt, typename OutIt>
OutIt removeDuplicates(InIt first, InIt last, OutIt output) {
    while (first != last) {
        *output++ = *first;
        first = find_if(first, last,
                        bind1st(not_equal_to<int>(), *first));
    }
    return output;
}
#+END_SRC

*** Remove Element	
Given an array and a value, remove all instances of that value in place and return the new length.

The order of elements can be changed. It doesn't matter what you leave
beyond the new length.

**** 时间复杂度 O(n),空间复杂度 O(1)
#+BEGIN_SRC java
public int removeElement(int[] a, int elem) {
    int idx = 0;
    for (int i = 0; i < a.length; i++) {
        if (a[i] != elem)
            a[idx++] = a[i];
    }
    return idx;
}
#+END_SRC
**** 使用 remove(),时间复杂度 O(n),空间复杂度 O(1)
#+BEGIN_SRC java
int removeElement(int A[], int n, int elem) {
    return distance(A, remove(A, A+n, elem));
}
#+END_SRC

*** Plus One

*** Remove Duplicates from Sorted Array II
Follow up for "Remove Duplicates":
What if duplicates are allowed at most twice?

For example,

Given sorted array A = [1,1,1,2,2,3],

Your function should return length = 5, and A is now [1,1,2,2,3].*** Rotate Image

加一个变量记录一下元素出现的次数即可。这题因为是已经排序的数组,所以一个变量即可解
决。如果是没有排序的数组,则需要引入一个 hashmap 来记录出现次数。

**** 时间复杂度 O(n),空间复杂度 O(1)
#+BEGIN_SRC java
public int removeDuplicates(int[] a) {
    if (a.length == 0) return 0;
    int ocnt = 1;  // occurance count
    int idx = 0;
    for (int i = 1; i < a.length; i++) {
        if (a[idx] == a[i]) {
            if (ocnt < 2) {
                a[++idx] = a[i];
                ocnt++;
            }
        } else {
            a[++idx] = a[i];
            ocnt = 1;
        }
    }
    return idx + 1;
}
#+END_SRC
**** 时间复杂度 O(n),空间复杂度 O(1)

下面是一个更简洁的版本。上面的代码略长,不过扩展性好一些,例如将 occur < 2 改为
occur < 3,就变成了允许重复最多 3 次。

#+BEGIN_SRC java
public int removeDuplicates(int[] a) {
    //if (a.length == 0) return 0;
    int idx = 0;
    for (int i = 0; i < a.length; i++) {
        if (i > 0 && i < a.length - 1 && a[i] == a[i - 1] && a[i] == a[i + 1])
            continue;
        a[idx++] = a[i];
    }
    return idx;
}
#+END_SRC
*** Set Matrix Zeroes	

*** Search in Rotated Sorted Array II
Follow up for "Search in Rotated Sorted Array":

What if duplicates are allowed?

Would this affect the run-time complexity? How and why?

Write a function to determine if a given target is in the array.

允许重复元素,则上一题中如果 A[m]>=A[l], 那么 [l,m] 为递增序列的假设就不能成立了,比
如 [1,3,1,1,1]。

如果 A[m]>=A[l] 不能确定递增,那就把它拆分成两个条件:

• 若 A[m]>A[l],则区间 [l,m] 一定递增

• 若 A[m]==A[l] 确定不了,那就 l++,往下看一步即可。

#+BEGIN_SRC java
public boolean search(int[] a, int target) {
    int bgn = 0, end = a.length;
    while (bgn != end) {
        int mid = bgn + (end - bgn) / 2;
        if (a[mid] == target) return true;
        if (a[bgn] < a[mid]) {
            if (a[bgn] <= target && target < a[mid])
                end = mid;
            else
                bgn = mid + 1;
        } else if (a[bgn] > a[mid]) {
            if (a[mid] < target && target <= a[end - 1])
                bgn = mid + 1;
            else
                end = mid;
        } else 
            // skip duplicated one, a[bgn] == a[mid]
            bgn++;
    }
    return false;
}
#+END_SRC

- 3Sum
- 3Sum Closest
- 4Sum
*** Remove Element
- Next Permutation
*** Permutation Sequence
*** Valid Sudoku
*** Trapping Rain Water
*** Gray Code
Hard
*** Search in Rotated Sorted Array
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

二分查找,难度主要在于左右边界的确定。

时间复杂度 O(log n),空间复杂度 O(1). 

#+BEGIN_SRC java
public int search(int[] a, int target) {
    int bgn = 0, end = a.length;
    while (bgn < end) {
        int mid = bgn + (end - bgn) / 2;
        if (a[mid] == target) return mid;
        if (a[bgn] <= a[mid]) {
            if (a[bgn] <= target && target < a[mid])
                end = mid;
            else
                bgn = mid + 1;
        } else {
            if (a[mid] < target && target <= a[end - 1])    //
                bgn = mid + 1;
            else
                end = mid;
        }
    }
    return -1;
}
#+END_SRC

*** Median of Two Sorted Arrays
There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

*Tags:* Divide and Conquer, Array, Binary Search

这是一道非常经典的题。这题更通用的形式是,给定两个已经排序好的数组,找到两者所有元
素中第 k 大的元素。

O(m + n) 的解法比较直观,直接 merge 两个数组,然后求第 k 大的元素。

不过我们仅仅需要第 k 大的元素,是不需要“排序”这么复杂的操作的。可以用一个计数器,
记录当前已经找到第 m 大的元素了。同时我们使用两个指针 pA 和 pB,分别指向 A 和 B 数组的第
一个元素,使用类似于 merge sort 的原理,如果数组 A 当前元素小,那么 pA++,同时 m++;如果
数组 B 当前元素小,那么 pB++,同时 m++。最终当 m 等于 k 的时候,就得到了我们的答案,O(k)
时间,O(1) 空间。但是,当 k 很接近 m + n 的时候,这个方法还是 O(m + n) 的。

有没有更好的方案呢?我们可以考虑从 k 入手。如果我们每次都能够删除一个一定在第 k 大元
素之前的元素,那么我们需要进行 k 次。但是如果每次我们都删除一半呢?由于 A 和 B 都是有序
的,我们应该充分利用这里面的信息,类似于二分查找,也是充分利用了“有序”
。

假设 A 和 B 的元素个数都大于 k/2,我们将 A 的第 k/2 个元素(即 A[k/2-1])和 B 的第 k/2
个元素(即 B[k/2-1])进行比较,有以下三种情况(为了简化这里先假设 k 为偶数,所得到的结
论对于 k 是奇数也是成立的):

• A[k/2-1] == B[k/2-1]

• A[k/2-1] > B[k/2-1]

• A[k/2-1] < B[k/2-1]

如果 A[k/2-1] < B[k/2-1],意味着 A[ 0 ] 到 A[k/2-1] 的肯定在 A ∪ B 的 top k 元素的范围
内,换句话说,A[k/2-1 不可能大于 A ∪ B 的第 k 大元素。留给读者证明。

因此,我们可以放心的删除 A 数组的这 k/2 个元素。同理,当 A[k/2-1] > B[k/2-1] 时,可
以删除 B 数组的 k/2 个元素。

当 A[k/2-1] == B[k/2-1] 时,说明找到了第 k 大的元素,直接返回 A[k/2-1] 或 B[k/2-1]
即可。

因此,我们可以写一个递归函数。那么函数什么时候应该终止呢?

• 当 A 或 B 是空时,直接返回 B[k-1] 或 A[k-1];


• 当 k=1 是,返回 min(A[ 0 ], B[ 0 ]);

• 当 A[k/2-1] == B[k/2-1] 时,返回 A[k/2-1] 或 B[k/2-1]

#+BEGIN_SRC java
public int helper(int [] a, int [] b, int k, int i, int j, int x, int y) {
    int m = a.length;
    int n = b.length;
    if (j == i) return b[x + k];
    if (y == x) return a[i + k];
    int mida = (i + j) / 2;
    int midb = (x + y) / 2;
    int lena = mida - i;
    int lenb = midb - x;
    if (b[midb] >= a[mida]) {
        if (k <= lena + lenb) 
            return helper(a, b, k, i, j, x, midb);
        else
            return helper(a, b, k - lena - 1, mida + 1, j, x, y);
    } else {
        if (k <= lena + lenb) {
            return helper(a, b, k, i, mida, x, y);
        } else {
            return helper(a, b, k - lenb - 1, i, j, midb + 1, y);
        }
    }
}
        
public double findMedianSortedArrays(int a[], int b[]) {
    int m = a.length;
    int n = b.length;
    if ((m + n) % 2 == 0)
        return (helper(a, b, (m + n) / 2, 0, m, 0, n) +
                helper(a, b, (m + n) / 2 - 1, 0, m, 0, n)) / 2.0;
    else
        return helper(a, b, (m + n) / 2, 0, m, 0, n);
}
#+END_SRC

*** Longest Consecutive Sequence
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

For example,

Given [100, 4, 200, 1, 3, 2],

The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.

如果允许 O(n log n) 的复杂度,那么可以先排序,可是本题要求 O(n)。
由于序列里的元素是无序的,又要求 O(n),首先要想到用哈希表。

用一个哈希表 unordered\textunderscore map<int, bool> used 记录每个元素是否使用,对每个元素,以该
元素为中心,往左右扩张,直到不连续为止,记录下最长的长度。

#+BEGIN_SRC java
public int longestConsecutive(int[] num) {
    Map<Integer, Boolean> used = new HashMap<Integer, Boolean>();
    int longest = 0;
    for(int i : num) {
        if (used.containsKey(i)) continue;
        int length = 1;
        used.put(i, true);
        for (int j = i + 1; used.containsKey(j); j++) {
            used.put(j, true);
            ++length;
        }
        for (int j = i - 1; used.containsKey(j); j--) {
            used.put(j, true);
            ++length;
        }
        longest = Math.max(longest, length);
    }
    return longest;
}
#+END_SRC

OJ超时。

#+BEGIN_SRC java
public int longestConsecutive(int[] num) {
    Map<Integer, Integer> used = new HashMap<Integer, Integer>();
    int res = 0, tmp;
    int left, right;
    for(int i : num) {
        if (!used.containsKey(i)) {
            left = (used.containsKey(i - 1)) ? used.get(i - 1) : 0;
            right = (used.containsKey(i + 1)) ? used.get(i + 1) : 0;
            tmp = left + right + 1;
            used.put(i, tmp);
            res = Math.max(res, tmp);
            used.put(i - left, tmp);
            used.put(i + right, tmp);
        } else continue;
    }
    return res;
}
#+END_SRC

简单地想一下，就知道前面一个遍历了所有数组中的无素，重复了已经cnt在最
长片段里的元素，而这部分是可以跳过的。

*** Trapping Rain Water
*** others Covered
- Construct Binary Tree from Inorder and Postorder Traversal
  [[Construct Binary Tree from Inorder and Postorder Traversal]]
- Construct Binary Tree from Preorder and Inorder Traversal
  [[Construct Binary Tree from Preorder and Inorder Traversal]]
- Best Time to Buy and Sell Stock
  [[Best Time to Buy and Sell Stock]]
- Best Time to Buy and Sell Stock II	
  [[Best Time to Buy and Sell Stock II]]
- Largest Rectangle in Histogram
  [[Largest Rectangle in Histogram]]
- Maximal Rectangle
  [[Maximum Rectangle]]
- Pascal's Triangle
- Pascal's Triangle II
- Merge Sorted Array	
  [[Merge Sorted Array]]
- Two Sum
  [[Two Sum]]
- Two Sum II - Input array is sorted
  [[Two Sum II - Input array is sorted]]
- Spiral Matrix
  [[Spiral Matrix]]
- Spiral Matrix II
  [[Spiral Matrix II]]
- Sort Colors
  [[Sort Colors]]
- Insert Interval
  [[Insert Interval]]
- Merge Intervals
  [[Merge Intervals]]
*** Majority Element	
*** Container With Most Water
*** Minimum Path Sum	
- Search Insert Position
  [[Search Insert Position]]
- Unique Paths
- Search for a Range
  [[Search for a Range]]
- Search a 2D Matrix
  [[Search a 2D Matrix]]
- Unique Paths II
*** Missing Ranges 	
*** Find Minimum in Rotated Sorted Array
*** Triangle
- Maximum Subarray
  [[Maximum Subarray]]
- Maximum Product Subarray
  [[Maximum Product Subarray]]
- Word Search
  [[Word Search]]
- Combination Sum	
  [[Combination Sum]]
- Combination Sum II
  [[Combination Sum II]]
- Subsets
  [[Subsets]]
- Subsets II
  [[Subsets II]]
- Jump Game
  [[Jump Game]]
*** Find Peak Element
*** Find Minimum in Rotated Sorted Array II
*** Jump Game II
- First Missing Positive	
  [[First Missing Positive]]
- Word Ladder II
[[Word Ladder II]]
- Best Time to Buy and Sell Stock III
  [[Best Time to Buy and Sell Stock III]]
- Roman to Integers
  [[Roman to Integers]]
- Integer to Roman
  [[Integer to Roman]]
- Pow(x, n)
  [[Pow(x, n)]]
- Sqrt(x)
  [[Sqrt(x)]]


** 字符串 String
*** Valid Palindrome	
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.

Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid
palindrome.

时间复杂度 O(n), 空间复杂度 O(1). 

#+BEGIN_SRC java
public boolean isPalindrome(String s) {
    int i = 0, j = s.length()-1;
    while (i < j) {
        while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;
        while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;
        if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))
            return false;
        i++;
        j--;
    }
    return true;
}
#+END_SRC

*** Implement strStr(), undone~~
Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

The signature of the function had been updated to return the index instead of the pointer. If you still see your function signature returns a char * or String, please click the reload button  to reset your code definition.

*Tags:* Two Pointers String

暴力算法的复杂度是 O(m ∗ n), 代码如下。更高效的的算法有 KMP 算法、Boyer-Mooer 算法和
Rabin-Karp 算法。面试中暴力算法足够了, 一定要写得没有 BUG。

**** 暴力解法, 时间复杂度 O(N*M), 空间复杂度 O(1)
#+BEGIN_SRC java
public int strStr(String haystack, String needle) {
    for (int i = 0; ; i++) {
        for (int j = 0; ; j++) {
            if (j == needle.length()) return i;
            if (i + j == haystack.length()) return -1;
            if (needle.charAt(j) != haystack.charAt(i + j)) break;
        }
    }
}
#+END_SRC

**** KMP, 时间复杂度 O(N+M), 空间复杂度 O(M)

#+BEGIN_SRC java
#+END_SRC

*** String to Integer (atoi)	
Implement atoi to convert a string to an integer.

*Hint:* Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

*Notes:* It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.

spoilers alert... click to show requirements for atoi.

Requirements for atoi:

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is
returned. If the correct value is out of the range of representable
values, INT\textunderscore MAX (2147483647) or INT\textunderscore MIN (-2147483648) is returned.

细节题。注意几个测试用例:

1. 不规则输入,但是有效,”-3924x8fc”,” + 413”,

2. 无效格式,” ++c”, ” ++1”

3. 溢出数据,”2147483648”

时间复杂度 O(n),空间复杂度 O(1). 
#+BEGIN_SRC java
private static final int maxdt = Integer.MAX_VALUE / 10;

public int atoi(String str) {
    int i = 0, n = str.length();
    while (i < n && Character.isWhitespace(str.charAt(i))) i++;

    int sign = 1;
    if (i < n && str.charAt(i) == '+') i++;
    else if (i < n && str.charAt(i) == '-') {
        sign = -1;
        i++;
    }

    int val = 0;
    while (i < n && Character.isDigit(str.charAt(i))) {
        int dgt = Character.getNumericValue(str.charAt(i));
        if (val > maxdt || val == maxdt && dgt >= 8) 
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        val = val * 10 + dgt;
        i++;
    }
    return sign * val;
}
#+END_SRC

时间复杂度 O(n), 空间复杂度 O(1). 

#+BEGIN_SRC java
public int atoi(String str) {
    int num = 0;
    int sign = 1;
    int n = str.length();
    int i = 0;
    while (i < n && Character.isWhitespace(str.charAt(i))) i++;
    if (i < n && str.charAt(i) == '+') i++;
    else if (i < n && str.charAt(i) == '-') {
        sign = -1;
        i++;
    }
    for(; i < n; i++) {
        if (!Character.isDigit(str.charAt(i))) break;
        if (num > Integer.MAX_VALUE / 10
            || (num == Integer.MAX_VALUE / 10            
                && (str.charAt(i) - '0' > Integer.MAX_VALUE % 10)))
            return sign == -1 ? Integer.MIN_VALUE : Integer.MAX_VALUE;
        num = num * 10 + str.charAt(i) - '0';
    }
    return num * sign;
}
#+END_SRC

*** Add Binary	
Given two binary strings, return their sum (also a binary string).

For example,

a = "11"

b = "1"

Return "100".

时间复杂度 O(n),空间复杂度 O(1)

#+BEGIN_SRC java
public String addBinary(String a, String b) {
    StringBuffer res = new StringBuffer("");
    int n = a.length() > b.length() ? a.length() : b.length();
    a = new StringBuilder(a).reverse().toString();
    b = new StringBuilder(b).reverse().toString();
    int carry = 0;
    for (int i = 0; i < n; i++) {
        int aval = i < a.length() ? a.charAt(i) - '0' : 0;
        int bval = i < b.length() ? b.charAt(i) - '0' : 0;
        int value = (aval + bval + carry) % 2;
        carry = (aval + bval + carry) / 2;
        res.insert(0, (char)(value + '0'));
    }
    if (carry == 1)
        res.insert(0, '1');
    return res.toString();
}
#+END_SRC

*** Longest Common Prefix
Write a function to find the longest common prefix string amongst an
array of strings.

从位置 0 开始,对每一个位置比较所有字符串,直到遇到一个不匹配。

**** 纵向扫描,从位置 0 开始,对每一个位置比较所有字符串,直到遇到一个不匹配

时间复杂度 O(n1+n2+...)

#+BEGIN_SRC java
public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) return "";
    for (int j = 0; j < strs[0].length(); j++) {
        for (int i = 1; i < strs.length; i++) {
            if (strs[i].length() < j+1 || strs[i].charAt(j) != strs[0].charAt(j))
                return strs[0].substring(0, j);
        }
    }
    return strs[0];
}
#+END_SRC
**** 横向扫描, 每个字符串与第 0 个字符串,从左到右比较,直到遇到一个不匹配, 然后继续下一个字符串

时间复杂度 O(n1+n2+...)

#+BEGIN_SRC java
#+END_SRC

*** Roman to Integer
Given a roman numeral, convert it to an integer.

Input is guaranteed to be within the range from 1 to 3999.

从前往后扫描,用一个临时变量记录分段数字。

如果当前比前一个大,说明这一段的值应该是当前这个值减去上一个值。比如 IV = 5 – 1;否
则,将当前值加入到结果中,然后开始下一段记录。比如 VI = 5 + 1, II=1+1

#+BEGIN_SRC java
public int getInt(char x) {
    switch (x) {
    case 'I': return 1;
    case 'V': return 5;
    case 'X': return 10;
    case 'L': return 50;
    case 'C': return 100;
    case 'D': return 500;
    case 'M': return 1000;
    default: return 0;
    }
}

public int romanToInt(String s) {
    int result = getInt(s.charAt(0));
    int tmp, prev;
    for (int i = 1; i < s.length(); i++) {
        tmp = getInt(s.charAt(i));
        prev = getInt(s.charAt(i-1));
        result += prev < tmp ? tmp - 2 * prev : tmp;
    }
    return result;
}
#+END_SRC
	
*** Count and Say	
The count-and-say sequence is the sequence of integers beginning as
follows:
#+BEGIN_SRC java
1, 11, 21, 1211, 111221, ...
1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.
#+END_SRC

Given an integer n, generate the nth sequence.

Note: The sequence of integers will be represented as a string.

模拟。

时间复杂度 O(n^2), 空间复杂度 O(n)

#+BEGIN_SRC java
string countAndSay(int n) {
    string s("1");
    while (--n)
        s = getNext(s);
    return s;
}

string getNext(const string &s) {
    stringstream ss;
    for (auto i = s.begin(); i != s.end(); ) {
        auto j = find_if(i, s.end(), bind1st(not_equal_to<char>(), *i));
        ss << distance(i, j) << *i;
        i = j;
    }
    return ss.str();
}
#+END_SRC

得优化自己的java代码 。。

*** Length of Last Word
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

For example, 

Given s = "Hello World",

return 5.

细节实现题。

**** 用 STL: 时间复杂度 O(n), 空间复杂度 O(1)
#+BEGIN_SRC java
int lengthOfLastWord(const char *s) {
    const string str(s);
    auto first = find_if(str.rbegin(), str.rend(), ::isalpha);
    auto last = find_if_not(first, str.rend(), ::isalpha);
    return distance(first, last);
}
#+END_SRC
**** 顺序扫描, 记录每个 word 的长度, 时间复杂度 O(n), 空间复杂度 O(1)
#+BEGIN_SRC java
int lengthOfLastWord(const char *s) {
    int len = 0;
    while (*s) {
        if (*s++ != ' ')
            ++len;
        else if (*s && *s != ' ')
            len = 0;
    }
    return len;
}
#+END_SRC
#+BEGIN_SRC java
public int lengthOfLastWord(String s) {
    if (s == null || s.length() == 0) return 0;
    String [] tmp = s.split("\\s+");
    if (tmp.length == 0) return 0;
    return tmp[tmp.length-1].length();
}
#+END_SRC
*** Longest Palindromic Substring
Given a string S, find the longest palindromic substring in S. You may
assume that the maximum length of S is 1000, and there exists one
unique longest palindromic substring.

最长回文子串,非常经典的题。

思路一:暴力枚举,以每个元素为中间元素,同时从左右出发,复杂度 O(n 2 )。

思路二:记忆化搜索,复杂度 O(n 2 )。设 f[i][j] 表示 [i,j] 之间的最长回文子串,递推方程如
下:
#+BEGIN_SRC java
f[i][j] = 
if (i == j) S[i]
if (S[i] == S[j] && f[i+1][j-1] == S[i+1][j-1]) S[i][j]
else max(f[i+1][j-1], f[i][j-1], f[i+1][j])
#+END_SRC

思路三:动规,复杂度 O(n 2 )。设状态为 f(i,j),表示区间 [i,j] 是否为回文串,则状态转移方
程为

#+BEGIN_latex 
f(i, j) = \Bigg\{
true, & i = j;\\
S[i] = S[j], & j = i + 1 \\
S[i] = S[j] \text{and } f (i + 1, j − 1) , & j > i + 1 \Bigg
#+END_latex 

(fix this format  one later) 

思路四:Manacher’s Algorithm, 复 杂 度 O(n)。 详 细 解 释 见 http://leetcode.com/2011/11/longest-
palindromic-substring-part-ii.html 。

**** 备忘录法,会超时: 时间复杂度 O(n^2),空间复杂度 O(n^2)

**** 动规: 时间复杂度 O(n^2),空间复杂度 O(n^2)
#+BEGIN_SRC java
public String longestPalindrome(String s) {
    int n = s.length();
    boolean [][] f = new boolean[n][n];
    int maxLen = 1, start = 0;   // 最长回文子串的长度,起点
    for (int i = 0; i < n; i++) {
        f[i][i] = true;
        for (int j = 0; j < i; j++) {  // [j, i]
            f[j][i] = (s.charAt(j) == s.charAt(i) && (i - j < 2 || f[j + 1][i - 1]));
            if (f[j][i] && maxLen < (i - j + 1)) {
                maxLen = i - j + 1;
                start = j;
            }
        }
    }
    return s.substring(start, start + maxLen);
}
#+END_SRC
**** Manacher’s Algorithm: 时间复杂度 O(n),空间复杂度 O(n)

*** Integer to Roman
Given an integer, convert it to a roman numeral.

Input is guaranteed to be within the range from 1 to 3999.

#+BEGIN_SRC java
public String intToRoman(int num) {
    int radix [] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    String symbol [] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
    StringBuffer res = new StringBuffer();
    for (int i = 0; num > 0; i++) {
        int cnt = num / radix[i];
        num %= radix[i];
        for (; cnt > 0 ; --cnt)
            res.append(symbol[i]);
    }
    return res.toString();
}
#+END_SRC

感觉这个好像 hard code 稍微多了一点儿，如果面试官比较严格，就用下面这
个吧。。。

#+BEGIN_SRC java
public String intToRoman(int num) {
    // index        0    1    2    3    4    5    6
    char [] sym = {'I', 'V', 'X', 'L', 'C', 'D', 'M'};
    // value:       1    5    10   50   100  500  1000
    int scale = 1000;
    StringBuffer result = new StringBuffer();
    for (int i = 6; i >= 0; i -= 2) {
        int digit = num / scale;
        if (digit != 0) {
            if (digit <= 3) {
                for (int j = 0; j < digit; j++) 
                    result.append(sym[i]);    
            } else if (digit == 4) {
                result.append(sym[i]);
                result.append(sym[i+1]);
            } else if (digit == 5)
                result.append(sym[i+1]);
            else if (digit > 5 && digit <= 8) {
                result.append(sym[i+1]);
                for (int j = 0; j < digit-5; j++) 
                    result.append(sym[i]);
            } else { // == 9
                result.append(sym[i]);
                result.append(sym[i+2]);
            }
        }
        num = num % scale;
        scale /= 10;
    }
    return result.toString();
}
#+END_SRC

*** Anagrams
Given an array of strings, return all groups of strings that are anagrams.

Note: All inputs will be in lower-case.

Anagram(回文构词法)是指打乱字母顺序从而得到新的单词, 比如 "dormitory" 打乱字母顺
序会变成 "dirty room" , "tea" 会变成"eat"。

回文构词法有一个特点:单词里的字母的种类和数目没有改变, 只是改变了字母的排列顺序。
因此, 将几个单词按照字母顺序排序后, 若它们相等, 则它们属于同一组 anagrams 。

时间复杂度 O(n), 空间复杂度 O(n)

#+BEGIN_SRC java
vector<string> anagrams(vector<string> &strs) {
    unordered_map<string, vector<string> > hash;
    for (string s : strs) {
        string tmp = s;
        sort(tmp.begin(), tmp.end());
        hash[tmp].push_back(s);
    }
    vector<string> result;
    /*
    for (auto key : hash)  {
        if (key.second.size() > 1)
            result.insert(result.end(), key.second.begin(), key.second.end());
    } */
    for (auto it = hash.cbegin(); it != hash.cend(); it++) {
        if (it->second.size() > 1)
            result.insert(result.end(), it->second.begin(), it->second.end());
    }
    return result;

}
#+END_SRC

Java版：

#+BEGIN_SRC java
public String sort(String a) {
    if (a == "") return "";
    char [] s = a.toCharArray();
    Arrays.sort(s);
    return new String(s);
}
        
public List<String> anagrams(String[] strs) {
    List<String> list = new ArrayList<String>();  // result
    Map<String, List<Integer>> res = new HashMap<String, List<Integer>>();
    String [] sorted = new String[strs.length];
    List<Integer> one = new ArrayList<Integer>();
    for (int i = 0; i < strs.length; i++) {
        sorted[i] = sort(strs[i]);
        if (res.containsKey(sorted[i])) 
            res.get(sorted[i]).add(i);
        else {
            one.add(i);
            res.put(sorted[i], one);
            one = new ArrayList<Integer>();
        }
    }
    for (String key : res.keySet()) 
        if (res.get(key).size() > 1) 
            for (int i = 0; i < res.get(key).size(); i++) 
                list.add(strs[res.get(key).get(i)]);
    return list;
}
#+END_SRC

*** Simplify Path

Given an absolute path for a file (Unix-style), simplify it.

For example,
#+BEGIN_SRC java
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"
#+END_SRC
click to show corner cases.

Corner Cases:

Did you consider the case where path = "/../"?

In this case, you should return "/".

Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".

In this case, you should ignore redundant slashes and return
"/home/foo".

很有实际价值的题目。

时间复杂度 O(n),空间复杂度 O(n)

#+BEGIN_SRC java
public String simplifyPath(String path) {
    Stack<String> stack = new Stack<String>();
    Stack<String> f = new Stack<String>();
    String [] s = path.split("\\/");
    StringBuffer res = new StringBuffer();
    if (s.length == 0) return res.append('/').toString();
    for (int i = s.length - 1; i >= 0; i--)
        if (!s[i].equals("")) {
            stack.push(s[i]);
        }
    String tmp = "";
    while (!stack.isEmpty()) {
        tmp = stack.pop();
        if (tmp.equals("."));
        else if (tmp.equals("..")) {
            if (!f.isEmpty()) 
                f.pop();
        } else f.push(tmp); 
    }
    if (!f.isEmpty()) {
        while (!f.isEmpty()) {
            tmp = f.pop();
            res.insert(0, tmp);
            res.insert(0, "/");
        }
    } else 
        res.append('/');
    return res.toString();
}
#+END_SRC

c++版： 需要明天再做一下。。

#+BEGIN_SRC java
string simplifyPath(string const& path) {
    vector<string> dirs;
    for (auto i = path.begin(); i != path.end() ; ) {
        ++i;
        auto j = find(i, path.end(), '/');
        auto dir = string(i, j);
        if (!dir.empty() && dir != ".") {
            if (dir == "..") {
                if (!dirs.empty())
                    dirs.pop_back();
            } else
                dirs.push_back(dir);
        }
        i = j;
    }
    stringstream out;
    if (dirs.empty()) out << "/";
    else {
        for (auto dir : dirs)
            cout << '/' << dir;
    }
    return out.str();
}
/*
  Input:	"/..."
Output:	""
Expected:	"/..."
 */
#+END_SRC

Hard
*** Valid Number
Validate if a given string is numeric.

Some examples:
#+BEGIN_SRC java
"0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true
#+END_SRC

Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.

click to show spoilers.

Update (2014-12-06):
New test cases had been added. Thanks unfounder's contribution.

细节实现题。

本题的功能与标准库中的 strtod() 功能类似。

**** 有限自动机: finite automata,时间复杂度 O(n),空间复杂度 O(n)

这个还是等我改天再仔细研究吧。。。

**** 使用 strtod(): 偷懒,直接用 strtod(),时间复杂度 O(n)
#+BEGIN_SRC java
bool isNumber (char const* s) {
    char* endptr;
    strtod (s, &endptr);
    if (endptr == s) return false;
    for (; *endptr; ++endptr)
        if (!isspace (*endptr)) return false;
    return true;
}
#+END_SRC

*** Edit Distance
*** Minimum Window Substring
*** Longest Substring with At Most Two Distinct Characters 	
*** Read N Characters Given Read4 II - Call multiple times
other Covered
- Longest Valid Parentheses
  [[Longest Valid Parentheses]]
*** Valid Parentheses
*** Compare Version Numbers
*** Read N Characters Given Read4
*** One Edit Distance
*** Decode Ways
*** Longest Substring Without Repeating Characters
*** Reverse Words in a String
*** Interleaving String

- Multiply Strings
- Substring with Concatenation of All Words
- ZigZag Conversion	
- Text Justification
- Restore IP Addresses

- Letter Combinations of a Phone Number
- Generate Parentheses
- Regular Expression Matching
- Wildcard Matching
- Scramble String	
- Distinct Subsequences
- Word Ladder II [[Word Ladder II]]

** Linked List
*** Remove Duplicates from Sorted List
*** Remove Nth Node From End of List

Given a linked list, remove the nth node from the end of list and return its head.

For example,

   Given linked list: 1->2->3->4->5, and n = 2.

   After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.

Try to do this in one pass.

*Tags:* Linked List, Two Pointers

设两个指针 p,  q, 让 q 先走 n 步, 然后 p 和 q 一起走, 直到 q 走到尾节点, 删
除 p->next 即可。

时间复杂度 O(n), 空间复杂度 O(1). 

#+BEGIN_SRC java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(-1);
    ListNode p = dummy;
    ListNode q = dummy;
    p.next = head;
    q.next = head;
    for (int i = 0; i < n; i++) {    // q 先走 n 步
        q = q.next;
    }
    while (q.next != null) {              // 一起走
        p = p.next;
        q = q.next;
    }
    ListNode tmp = p.next;
    p.next = tmp.next;
    return dummy.next;
}
#+END_SRC

*** Merge Two Sorted Lists
*** Intersection of Two Linked Lists
*** Add Two Numbers	
You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)

Output: 7 -> 0 -> 8

跟 Add Binary(见 §3.4)很类似. 

#+BEGIN_SRC java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode head = new ListNode(-1);   // dummy 头节点
    int carry = 0;
    ListNode prev = head;
    for (ListNode pa = l1, pb = l2;
         pa != null || pb != null;
         pa = pa == null ? null : pa.next,
             pb = pb == null ? null : pb.next,
             prev = prev.next) {
        int aval = pa == null ? 0 : pa.val;
        int bval = pb == null ? 0 : pb.val;
        int value = (aval + bval + carry) % 10;
        carry = (aval + bval + carry) / 10;
        prev.next = new ListNode(value); // 尾插法
    }
    if (carry > 0)
        prev.next = new ListNode(carry);
    return head.next;
}
#+END_SRC

*** Reverse Linked List II

Reverse a linked list from position m to n. Do it in-place and in one-pass.

For example:

Given 1->2->3->4->5->NULL, m = 2 and n = 4,

return 1->4->3->2->5->NULL.

Note:

Given m, n satisfy the following condition:

1 ≤ m ≤ n ≤ length of list.

这题非常繁琐,有很多边界检查,15 分钟内做到 bug free 很有难度!

**** 迭代版, 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public ListNode reverseBetween(ListNode head, int m, int n) {
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode prevM = null;
    ListNode curr = dummy;
    for (int i = 1; i <= n ; i++) {
        if (i == m) prevM = curr;
        if (i > m && i <= n) { // prev_m 和 curr 静止不动
            curr.next = head.next;
            head.next = prevM.next;
            prevM.next = head;
            head = curr;
        }
        curr = head;
        head = head.next;
    }
    return dummy.next;
}
#+END_SRC

再仔细好好想一下这个代码 ~~~

*** Partition List

Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

For example,

Given 1->4->3->2->5->2 and x = 3,

return 1->2->2->4->3->5.

*Tags:* Linked List, Two Pointers

**** 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public ListNode partition(ListNode head, int x) {
    if (head == null) return head;
    ListNode lftDummy = new ListNode(0);
    ListNode ritDummy = new ListNode(0);
    ListNode lftCurr = lftDummy; // 左头结点
    ListNode ritCurr = ritDummy; // 右头结点
        
    for (; head != null; head = head.next) {
        if (head.val < x) {
            lftCurr.next = head;
            lftCurr = head;
        } else {
            ritCurr.next = head;
            ritCurr = head;
        }
    }
    lftCurr.next = ritDummy.next;
    ritCurr.next = null; // 无限寻还
    return lftDummy.next;
}
#+END_SRC

*** Remove Duplicates from Sorted List
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,

Given 1->1->2, return 1->2.

Given 1->1->2->3->3, return 1->2->3.

**** 递归版, 时间复杂度 O(n), 空间复杂度 O(1)

c++版： 
#+BEGIN_SRC java
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if (!head) return head;
        ListNode dummy{head->val + 1, head}; // 值只要跟 head 不同即可
        recur(&dummy, head);
        return dummy.next;
    }
private:
    static void recur(ListNode *prev, ListNode *cur) {
        if (cur == nullptr) return;
        if (prev->val == cur->val) { // 删除 head
            prev->next = cur->next;
            delete cur;
            recur(prev, prev->next);
        } else {
            recur(prev->next, cur->next);
        }
    }
};
#+END_SRC

Java版：
#+BEGIN_SRC java
public void recursion(ListNode prev, ListNode curr) {
    if (curr == null) return;
    if (prev.val == curr.val) {     // 删除 head
        prev.next = curr.next;
        recursion(prev, curr.next);
    } else {
        prev.next = curr;   // important for Java
        recursion(prev.next, curr.next);
    }
}
        
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return head;
    ListNode dummy = new ListNode(head.val + 1);
    // 值只要跟 head 不同即可
    recursion(dummy, head);
    return dummy.next;
}
#+END_SRC

**** 迭代版, 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return head;
    for (ListNode prev = head, curr = head.next; curr != null; curr = curr.next) {
        if (prev.val == curr.val) {
            prev.next = curr.next;
        } else {
            prev = curr;
        }
    }
    return head;
}
#+END_SRC

虽然觉得自己链表和树的原理掌握得还不错，可这两个版块都因为代码没有受过
正规训练，所以代码奇差无比，看看别人写的。。。照葫芦画饼地写一遍，也算是一个提高的过程
吧。。。

*** Remove Duplicates from Sorted List II
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

For example,

Given 1->2->3->3->4->4->5, return 1->2->5.

Given 1->1->1->2->3, return 2->3.

**** 递归版, 时间复杂度 O(n), 空间复杂度 O(1)
#+BEGIN_SRC java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) return head;  
    ListNode curr = head.next;
    if (head.val == curr.val) {
        while (curr != null && head.val == curr.val) 
            curr = curr.next;
        return deleteDuplicates(curr);
    } else {
        head.next = deleteDuplicates(head.next);
        return head;
    }
}
#+END_SRC

**** 迭代版, 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return head;  
    ListNode dummy = new ListNode(Integer.MIN_VALUE);
    dummy.next = head;
    ListNode prev = dummy;
    ListNode curr = head;
    while (curr != null) {
        boolean dup = false;
        while (curr.next != null && curr.val == curr.next.val) {
            dup = true;
            curr = curr.next;
        }
        if (dup) {    // 删除重复的最后一个元素
            curr = curr.next;
            continue;
        }
        prev.next = curr;
        prev = prev.next;
        curr = curr.next;
    }
    prev.next = curr;
    return dummy.next;
}
#+END_SRC

*** Rotate List

Given a list, rotate the list to the right by k places, where k is non-negative.

For example:

Given 1->2->3->4->5->NULL and k = 2,

return 4->5->1->2->3->NULL.

*Tags:* Linked List, Two Pointers

先遍历一遍, 得出链表长度 len, 注意 k 可能大于 len, 因此令 k% = len。将尾节点 next 指针
指向首节点, 形成一个环, 接着往后跑 len − k 步, 从这里断开, 就是要求的结果
了。(这个思路真是好。。。)

#+BEGIN_SRC java
public ListNode rotateRight(ListNode head, int n) {
    if (head == null || n == 0) return head;
    int len = 1;
    ListNode curr = head;
    while (curr.next != null) {    // 求长度
        len++;
        curr = curr.next;
    }
    n = len - n % len;
    curr.next = head;            // 首尾相连
    for (int step = 0; step < n; step++) {
        curr = curr.next;      // 接着往后跑
    }
    head = curr.next;          // 新的首节点
    curr.next = null;             // 断开环
    return head;
}
#+END_SRC

*** Swap Nodes in Pairs

Given a linked list, swap every two adjacent nodes and return its head.

For example,

Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

**** 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    for (ListNode prev = dummy, curr = prev.next, next = curr.next;
         next != null;
         prev = curr, curr = curr.next, next = curr != null ? curr.next : null) {
        prev.next = next;
        curr.next = next.next;
        next.next = curr;
    }
    return dummy.next;
}
#+END_SRC

**** 简洁版： 时间复杂度 O(n), 空间复杂度 O(1)


下面这种写法更简洁, 但题目规定了不准这样做。

#+BEGIN_SRC java
public ListNode swapPairs(ListNode head) {
    ListNode p = head;
    int tmp = 0;
    while (p != null && p.next != null) {
        tmp = p.val;
        p.val = p.next.val;
        p.next.val = tmp;
        p = p.next.next;
    }
    return head;
}
#+END_SRC

*** Reorder List

Given a singly linked list L: L\textunderscore 0→L\textunderscore 1→…→L\textunderscore {n-1}→L\textunderscore n,

reorder it to: L\textunderscore 0→L\textunderscore n→L\textunderscore 1→L\textunderscore {n-1}→L\textunderscore 2→L\textunderscore {n-2}→…

You must do this in-place without altering the nodes' values.

For example,

Given {1, 2, 3, 4},  reorder it to {1, 4, 2, 3}.

题目规定要 in-place,也就是说只能使用 O(1) 的空间。

可以找到中间节点,断开,把后半截单链表 reverse 一下,再合并两个单链表。

时间复杂度 O(n),空间复杂度 O(1)

#+BEGIN_SRC java
public ListNode reverse(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode prev = head;
    for (ListNode curr = head.next, next = curr.next;
         curr != null;
         prev = curr, curr = next, next = next != null ? next.next : null) {
        curr.next = prev;
    }
    head.next = null;
    return prev;
}

public void reorderList(ListNode head) {
    if (head == null || head.next == null) return;
    ListNode slow = head;
    ListNode fast = head;
    ListNode prev = null;
    while (fast != null && fast.next != null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    prev.next = null;     // cut at middle
    slow = reverse(slow);
    ListNode curr = head;
    while (curr.next != null) {
        ListNode tmp = curr.next;
        curr.next = slow;
        slow = slow.next;
        curr.next.next = tmp;
        curr = tmp;
    }
    curr.next = slow;
}
#+END_SRC

*** Convert Sorted List to Binary Search Tree
*** Linked List Cycle
Given a linked list, determine if it has a cycle in it.

Follow up:

Can you solve it without using extra space?

*Tags：* Linked List， Two Pointers

最容易想到的方法是, 用一个哈希表 unordered_map<int,  bool> visited, 记录每个元素是
否被访问过, 一旦出现某个元素被重复访问, 说明存在环。空间复杂度 O(n), 时间复杂度 O(N )。

最好的方法是时间复杂度 O(n), 空间复杂度 O(1) 的。设置两个指针, 一个快一个慢, 快
的 指 针 每 次 走 两 步,  慢 的 指 针 每 次 走 一 步,  如 果 快 指 针 和 慢 指 针 相 遇,  则 说 明 有 环。 参 考
http://leetcode.com/2010/09/detecting-loop-in-singly-linked-list.html

**** 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public boolean hasCycle(ListNode head) {
    // 设置两个指针,一个快一个
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) return true;
    }
    return false;
}
#+END_SRC

*** Linked List Cycle II

Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Follow up:

Can you solve it without using extra space?

*Tags:* Linked List, Two Pointers

当 fast 与 slow 相遇时, slow 肯定没有遍历完链表, 而 fast 已经在环内循环了 n 圈 (1 ≤ n)。假
设 slow 走了 s 步, 则 fast 走了 2s 步(fast 步数还等于 s 加上在环上多转的 n 圈), 设环长为 r, 则:

2s = s + nr

s = nr

设整个链表长 L, 环入口点与相遇点距离为 a, 起点到环入口点的距离为 x, 则

x + a = nr = (n-1)r + r = (n - 1)r + L - x

x = (n - 1)r + (L - x - a)

L-x-a 为相遇点到环入口点的距离, 由此可知, 从链表头到环入口点等于 n - 1 圈内环 + 相遇
点到环入口点, 于是我们可以从 head 开始另设一个指针 slow2, 两个慢指针每次前进一步, 它俩
一定会在环入口点相遇。

#+CAPTION: Linked List Cycle II
[[./pic/listcycle.jpg]]

**** 方法一（网上都是这个答案）：

第一次相遇后，让slow,fast继续走，记录到下次相遇时循环了几次。因为当fast第二次到达Z点时，fast走了一圈，slow走了半圈，而当fast第三次到达Z点时，fast走了两圈，slow走了一圈，正好还在Z点相遇。

方法二：

第一次相遇后，让fast停着不走了，slow继续走，记录到下次相遇时循环了几次。

方法三（最简单）：

第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b。

因为fast的速度是slow的两倍，所以fast走的距离是slow的两倍，有 2(a+b) = a+b+c+b，可以得到a=c（这个结论很重要！）。

我们发现L=b+c=a+b，也就是说，从一开始到二者第一次相遇，循环的次数就等于环的长度。

**** 我们已经得到了结论a=c，那么让两个指针分别从X和Z开始走，每次走一步，那么正好会在Y相遇！也就是环的第一个节点。

**** 在上一个问题的最后，将c段中Y点之前的那个节点与Y的链接切断即可。

**** 如何判断两个单链表是否有交点？先判断两个链表是否有环，如果一个有环一个没环，肯定不相交；如果两个都没有环，判断两个列表的尾部是否相等；如果两个都有环，判断一个链表上的Z点是否在另一个链表上。

如何找到第一个相交的节点？求出两个链表的长度L1,L2（如果有环，则将Y点当
做尾节点来算），假设L1<L2，用两个指针分别从两个链表的头部开始走，长度
为L2的链表先走(L2-L1)步，然后两个一起走，直到二者相遇。

时间复杂度 O(n), 空间复杂度 O(1). 

#+BEGIN_SRC java
public ListNode detectCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next; // 2X speed
        if (fast == slow) {
            ListNode curr = head;
            while (curr != slow) {
                curr = curr.next;
                slow = slow.next;
            }
            return curr;
        }
    }
    return null;
} 
#+END_SRC

*** Reverse Nodes in k-Group

Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.

Only constant memory is allowed.

For example,

Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5

**** 递归版, 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public ListNode reverseKGroup(ListNode head, int k) {
    if (head == null || head.next == null || k < 2) return head;
    ListNode gNext = head;
    for (int i = 0; i < k; i++) {
        if (gNext != null) {
            gNext = gNext.next;
        } else return head;
    }
    // gNext is the head of next group
    // newGNext is the new head of next group after reversion
    ListNode newGNext = reverseKGroup(gNext, k);
    ListNode prev = null;
    ListNode curr = head;
    while (curr != gNext) {
        ListNode next = curr.next;
        curr.next = prev != null ? prev : newGNext;
        prev = curr;
        curr = next;
    }
    return prev;
}
#+END_SRC

**** 迭代版, 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
bug~~
#+END_SRC

*** Copy List with Random Pointer

A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

Return a deep copy of the list.

*Tags:* Hash Table, Linked List

#+BEGIN_SRC java
public RandomListNode copyRandomList(RandomListNode head) {
    if (head == null) return null;
    for (RandomListNode curr = head; curr != null; ) {
        RandomListNode node = new RandomListNode(curr.label);
        node.next = curr.next;
        curr.next = node;
        curr = node.next;
    }
    for (RandomListNode curr = head; curr != null; ) {
        if (curr.random != null)
            curr.next.random = curr.random.next;
        curr = curr.next.next;
    }
    // 分拆两个单链表
    RandomListNode dummy = new RandomListNode(-1);
    for (RandomListNode curr = head, newC = dummy; curr != null; ) {
        newC.next = curr.next;
        newC = newC.next;
        curr.next = curr.next.next;
        curr = curr.next;
    }
    return dummy.next;
}
#+END_SRC

改天去找一下 HashMap 的解法， 或者自己写一个。

other Covered
- Sort List
  [[Sort List]]
- Insertion Sort List
  [[Insertion Sort List]]
- Merge k Sorted Lists
  [[Merge k Sorted Lists]]

** 树 Binary Tree, Binary Search Tree
Morris 专题

http://blog.ygui.me/algorithms/datastructure/2014-09/166

二叉树的Morris遍历可不使用用栈，在常量空间O(1)、线性时间O(n)内实现二叉树的前中后序遍历，且遍历后不破坏二叉树的形状（中间过程允许改变其形状）。

Morris遍历的基本原理是利用所有叶子结点的right指针，指向其后继结点，组
成一个环，在第二次遍历到这个结点时，由于其左子树已经遍历完了，则访问该
结点。

*** 中序遍历(Inorder Traversal)

中序遍历的算法步骤如下：

**** 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。

**** 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

\nbsp{} \nbsp{} A.如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

\nbsp{} \nbsp{} B.如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。

**** 重复以上1、2直到当前节点为空。

下图为每一步迭代的结果（从左至右，从上到下），cur代表当前节点，深色节点表示该节点已输出。

#+CAPTION: Morris 中序遍历 
[[./pic/morrIn.jpg]]

#+BEGIN_SRC java
vector inorderTraversal(TreeNode *root) {
    vector order;
    for(TreeNode *now = root, *tmp; now;) {
        if (now->left == NULL) {
                order.push_back(now->val);
                now = now->right;   
        } else {		
                for (tmp = now->left;
                     tmp->right != NULL && tmp->right != now;) 
                    tmp = tmp->right;
                if (tmp->right) {
                    order.push_back(now->val);
                    tmp->right = NULL;
                    now = now->right;
                } else {
                    tmp->right = now;
                    now = now->left;
                }
         }
    }
    return order;
}
#+END_SRC

*** 先序遍历(Preorder Traversal)
先序遍历与中序遍历相似，代码上只有一行不同，不同就在于输出的顺序。

**** 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。
**** 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。
\nbsp{} \nbsp{} A.如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。输出当前节点并将当前节点更新为当前节点的左孩子。

\nbsp{} \nbsp{} B.如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。当前节点更新为当前节点的右孩子。
**** 重复以上1、2直到当前节点为空。

下图为每一步迭代的结果（从左至右，从上到下），cur代表当前节点，深色节
点表示该节点已输出。

#+CAPTION: Morris 先序遍历 
[[./pic/morrPre.jpg]]

#+BEGIN_SRC java
vector preorderTraversal(TreeNode *root) {
	vector order;
	for (TreeNode *now = root, *tmp; now;) {
	    if (now->left == NULL) {
                order.push_back(now->val);
                now = now->right;   
            } else {
	        for (tmp = now->left; tmp->right != NULL && tmp->right != now;) {
                    tmp = tmp->right;
	        if (tmp->right) {
				tmp->right = NULL;
				now = now->right;
	        } else {
				order.push_back(now->val);
				tmp->right = now;
				now = now->left;
	        }
	    }
	}
	return order;
}
#+END_SRC

*** 后序遍历(Postorder Traversal)

后序遍历比较复杂，它的思路是利用中序遍历，所以首先产生了一个假的根结点，其左子树为原来的二叉树，从假的根结点开始中序遍历它和中序遍历有所不同，在发现当前结点左子树为空时，不访问此结点(后序遍历需要保证访问完右子树后才能访问根结点)，直接访问右子树。第二次遍历到某个结点时，将该结点左子树的最右路径反序输出即可。具体步骤如下：

**** 当前节点设置为临时节点dump。
**** 如果当前节点的左孩子为空，则将其右孩子作为当前节点。
**** 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

\nbsp{} \nbsp{} A.如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

\nbsp{} \nbsp{} B.如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。倒序输出从当前节点的左孩子到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右孩子。

**** 重复以上2、3直到当前节点为空。

下图为每一步迭代的结果（从左至右，从上到下），cur代表当前节点，深色节点表示该节点已输出。

#+CAPTION: Morris 后序遍历
[[./pic/morrPost.jpg]]

二叉树的遍历

   树的遍历有两类:深度优先遍历和宽度优先遍历。深度优先遍历又可分为两种:先根(次序)遍历和后根(次序)遍历。

   树的先根遍历是:先访问树的根结点,然后依次先根遍历根的各棵子树。树的先跟遍历的结果与对应二叉树(孩子兄弟表示法)的先序遍历的结果相同。

   树的后根遍历是:先依次后根遍历树根的各棵子树,然后访问根结点。树的后跟遍历的结果与对应二叉树的中序遍历的结果相同。

   二叉树的先根遍历有: 先序遍历 (root -> left -> right), root -> right -> left; 后根遍历有: 后序遍历(left -> right -> root), right -> left -> root; 二叉树还有个一般的树没有的遍历次序, 中序遍历 (left -> root -> right)。

*** Binary Tree Preorder Traversal
    Given a binary tree, return the preorder traversal of its nodes' values.
    
    For example:

    Given binary tree {1,#,2,3},
    #+BEGIN_SRC java
    1
     \
      2
     /
    3
    #+END_SRC
    
    return [1,2,3].
    
    Note: Recursive solution is trivial, could you do it iteratively?

    用栈或Morris遍历

**** 栈： 使用栈,时间复杂度 O(n), 空间复杂度 O(n)

#+BEGIN_SRC java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) return res;
    Stack<TreeNode> s = new Stack<TreeNode>();
    TreeNode curr = root;
    if (curr != null) s.push(curr);
    while (!s.isEmpty()) {
        curr = s.pop();
        res.add(curr.val);
        if (curr.right != null) s.push(curr.right);
        if (curr.left != null) s.push(curr.left);
    }
    return res;
}
#+END_SRC

**** Morris先序遍历： Morris 先序遍历,时间复杂度 O(n),空间复杂度 O(1)

#+BEGIN_SRC java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    TreeNode curr = root;
    TreeNode prev = null;
    while (curr != null) {
        if (curr.left == null) {
            res.add(curr.val);
            prev = curr;      /* cur 刚刚被访问过 */
            curr = curr.right;
        } else {                     /* 查找前驱 */
            TreeNode node = curr.left;
            while (node.right != null && node.right != curr) {
                node = node.right;
            }
            if (node.right == null) {   /* 还没线索化,则建立线索 */
                res.add(curr.val);    /* 仅这一行的位置与中序不同 */
                node.right = curr;
                prev = curr;        /* cur 刚刚被访问过 */
                curr = curr.left;
            } else {            /* 已经线索化,则删除线索 */
                node.right = null;
                /* prev = cur; 不能有这句,cur 已经被访问 */
                curr = curr.right;
            }
        }
    }
    return res;
}
#+END_SRC

*** Binary Tree Inorder Traversal
    Given a binary tree, return the inorder traversal of its nodes' values.
    
    For example:

    Given binary tree {1,#,2,3},
    #+BEGIN_SRC java
   1
    \
     2
    /
   3
#+END_SRC
    
    return [1,3,2].
    
    Note: Recursive solution is trivial, could you do it iteratively?
**** 栈： 使用栈,时间复杂度 O(n), 空间复杂度 O(n)

#+BEGIN_SRC java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    TreeNode p = root;
    Stack<TreeNode> s = new Stack<TreeNode>();
    while (!s.isEmpty() || p != null) {
        if (p != null) {
            s.push(p);
            p = p.left;
        } else {
            p = s.pop();
            res.add(p.val);
            p = p.right;
        }
    }
    return res;
}
#+END_SRC

**** Morris先序遍历： Morris 先序遍历,时间复杂度 O(n),空间复杂度 O(1)

#+BEGIN_SRC java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    TreeNode prev = null;
    TreeNode curr = root;
    Stack<TreeNode> s = new Stack<TreeNode>();
    while (curr != null) {
        if (curr.left == null) {
            res.add(curr.val);
            prev = curr;
            curr = curr.right;
        } else {
            /* 查找前驱 */
            TreeNode node = curr.left;
            while (node.right != null && node.right != curr) {
                node = node.right;
            }
            if (node.right == null) {  /* 还没线索化,则建立线索 */
                node.right = curr;
                /* prev = cur; 不能有这句,cur 还没有被访问 */
                curr = curr.left;
            } else {         /* 已经线索化,则访问节点,并删除线索 */
                res.add(curr.val);
                node.right = null;
                curr = curr.right;
            }
        }
    }
    return res;
}
#+END_SRC

*** Binary Tree Postorder Traversal	
    Given a binary tree, return the postorder traversal of its nodes' values.
    
    For example:

    Given binary tree {1,#,2,3},
    #+BEGIN_SRC java
   1
    \
     2
    /
   3
    #+END_SRC
    
    return [3,2,1].
    
    Note: Recursive solution is trivial, could you do it iteratively?
**** 栈： 使用栈,时间复杂度 O(n), 空间复杂度 O(n)

#+BEGIN_SRC java
 public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    /* curr, 正在访问的结点; prev,刚刚访问过的结点 */
    TreeNode prev = null; 
    TreeNode curr = root; 
    Stack<TreeNode> s = new Stack<TreeNode>();
    do {
        while (curr != null) {     /* 往左下走 */
            s.push(curr);
            curr = curr.left;
        }
        prev = null;
        while (!s.isEmpty()) {
            curr = s.pop();
            /* 右孩子不存在或已被访问,访问之 */
            if (curr.right == prev) {
                res.add(curr.val);
                prev = curr;  /* 保存刚访问过的结点 */
            } else {
                /* 当前结点不能访问,需第二次进栈 */
                s.push(curr);
                curr = curr.right; /* 先处理右子树 */
                break;
            }
        }
    } while (!s.isEmpty());
    return res;
}
#+END_SRC

**** Morris先序遍历： Morris 先序遍历,时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
// 逆转路径
public void reverse(TreeNode bgn, TreeNode end) {
    TreeNode x = bgn;
    TreeNode y = bgn.right;
    TreeNode z = null;
    if (bgn == end) return;
    while (x != end) {
        z = y.right;
        y.right = x;
        x = y;
        y = z;
    }
}

// 访问逆转后的路径上的所有结点
public void visit_reverse(TreeNode bgn, TreeNode end, List<Integer> res) {
    TreeNode p = end;
    reverse(bgn, end);
    while (true) {
        res.add(p.val);
        if (p == bgn) break;
        p = p.right;
    }
    reverse(end, bgn);
}
        
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    TreeNode dummy = new TreeNode(-1);
    TreeNode curr = null;
    TreeNode prev = null;
    dummy.left = root;
    curr = dummy;
    while (curr != null) {
        if (curr.left == null) {
            prev = curr;                         /* 必须要有 */
            curr = curr.right;
        } else {
            TreeNode node = curr.left;
            while (node.right != null && node.right != curr)
                node = node.right;
            if (node.right == null) { /* 还没线索化,则建立线索 */
                node.right = curr;
                prev = curr;                    /* 必须要有 */
                curr = curr.left;
            } else {        /* 已经线索化,则访问节点,并删除线索 */
                visit_reverse(curr.left, prev, res);
                prev.right = null;
                prev = curr;                    /* 必须要有 */
                curr = curr.right;
            }
        }
    }
    return res;
}
#+END_SRC

c++版：

#+BEGIN_SRC java
// LeetCode, Binary Tree Postorder Traversal
// Morris 后序遍历, 时间复杂度 O(n), 空间复杂度 O(1)
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> result;
        TreeNode dummy(-1);
        TreeNode *cur, *prev = nullptr;
        std::function < void(const TreeNode*)>
            visit = [&result](const TreeNode *node) {
            result.push_back(node->val);
        };

        dummy.left = root;
        cur = &dummy;
        while (cur != nullptr) {
            if (cur->left == nullptr) {
                prev = cur;                  /* 必须要有 */
                cur = cur->right;
            } else {
                TreeNode *node = cur->left;
                while (node->right != nullptr && node->right != cur)
                    node = node->right;
                if (node->right == nullptr) { /* 还没线索化,则建立线索 */
                    node->right = cur;
                    prev = cur;              /* 必须要有 */
                    cur = cur->left;
                } else { /* 已经线索化,则访问节点,并删除线索 */
                    visit_reverse(cur->left, prev, visit);
                    prev->right = nullptr;
                    prev = cur;              /* 必须要有 */
                    cur = cur->right;
                }
            }
        }
        return result;
    }
private:
    // 逆转路径
    static void reverse(TreeNode *from, TreeNode *to) {
        TreeNode *x = from, *y = from->right, *z;
        if (from == to) return;
        while (x != to) {
            z = y->right;
            y->right = x;
            x = y;
            y = z;
        }
    }
    // 访问逆转后的路径上的所有结点
    static void visit_reverse(TreeNode* from, TreeNode *to,
                              std::function< void(const TreeNode*) > &visit) {
        TreeNode *p = to;
        reverse(from, to);
        while (true) {
            visit(p);
            if (p == from)
                break;
            p = p->right;
        }
        reverse(to, from);
    }
};
#+END_SRC

一段代码写成这样，实在是太恐怖了。。。面试的时候怎么出得来？还是把原理
弄懂尽量不要写这种方法好了。。。

**** root, right, left --> Reverse

另一个比较 tricky 的方法就是先模拟 postorder （实际上是按 root, right,
left 的顺序遍历的）, 再 reverse 得到的结果。

#+BEGIN_SRC java
public List<Integer> postorderTraversal0(TreeNode root) {
    // get preorder results first, no no no no, root, right, left
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    Stack<TreeNode> s = new Stack<TreeNode>();
    TreeNode curr = root;
    while (!s.isEmpty() || curr != null) {
        while (curr != null) {
            res.add(curr.val);
            s.push(curr);
            curr = curr.right;
        }
        if (!s.isEmpty()) {
            curr = s.pop();
            curr = curr.left;
        } 
    }
    // then reverse the values
    List<Integer> result = new ArrayList<Integer>();
    for (int i = res.size() - 1; i >= 0; i--) {
        result.add(res.get(i));
    }
    return result;
}
#+END_SRC

*** Binary Tree Level Order Traversal
    Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).
    
    For example:

    Given binary tree {3,9,20,#,#,15,7},
    #+BEGIN_SRC java
    3
   / \
  9  20
    /  \
   15   7
    #+END_SRC
    return its level order traversal as:
    #+BEGIN_SRC java
[
  [3],
  [9,20],
  [15,7]
]
    #+END_SRC

**** 递归版: 时间复杂度 O(n), 空间复杂度 O(n)

#+BEGIN_SRC java
public void traverse(TreeNode root, int level, List<List<Integer>> res) {
    if (root == null) return;
    if (level > res.size())
        res.add(new ArrayList<Integer>());
    res.get(level - 1).add(root.val);
    traverse(root.left, level + 1, res);
    traverse(root.right, level + 1, res);
}
        
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    traverse(root, 1, res);
    return res;
}
#+END_SRC

**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) return res;
    Queue<TreeNode> curr = new LinkedList<TreeNode>();
    Queue<TreeNode> next = new LinkedList<TreeNode>();
    List<Integer> level = new ArrayList<Integer>();

    curr.add(root);
    while (!curr.isEmpty()) {
        while (!curr.isEmpty()) {
            TreeNode node = curr.poll();
            level.add(node.val);
            if (node.left != null) next.add(node.left);
            if (node.right != null) next.add(node.right);
        }
        res.add(level);
        //level.clear();    // not working
        level = new ArrayList<Integer>();
        curr.addAll(next);
        next.clear();
    }
    return res;
}
#+END_SRC

*** Binary Tree Level Order Traversal II
    Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).
    
    For example:
    Given binary tree {3,9,20,#,#,15,7},
    #+BEGIN_SRC java
    3
   / \
  9  20
    /  \
   15   7
    #+END_SRC
    return its bottom-up level order traversal as:
    #+BEGIN_SRC java
[
  [15,7],
  [9,20],
  [3]
]
    #+END_SRC

在上一题(Binary Tree Level Order Traversal见 [[Binary Tree Level Order Traversal]] )的基础上,reverse() 一下即可。

**** 递归版: 时间复杂度 O(n), 空间复杂度 O(n)


#+BEGIN_SRC java
public void traverse(TreeNode root, int level, List<List<Integer>> res) {
    if (root == null) return;
    if (level > res.size())
        res.add(new ArrayList<Integer>());
    res.get(level - 1).add(root.val);
    traverse(root.left, level + 1, res);
    traverse(root.right, level + 1, res);
}
        
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    traverse(root, 1, res);
    Collections.reverse(res);    // 比上一题多此一行
    return res;
}
#+END_SRC

**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(1)


#+BEGIN_SRC java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) return res;
    Queue<TreeNode> curr = new LinkedList<TreeNode>();
    Queue<TreeNode> next = new LinkedList<TreeNode>();
    List<Integer> level = new ArrayList<Integer>();

    curr.add(root);
    while (!curr.isEmpty()) {
        while (!curr.isEmpty()) {
            TreeNode node = curr.poll();
            level.add(node.val);
            if (node.left != null) next.add(node.left);
            if (node.right != null) next.add(node.right);
        }
        res.add(level);
        level = new ArrayList<Integer>();
        curr.addAll(next);
        next.clear();
    }
    Collections.reverse(res);    // 比上一题多此一行
    return res;
}
#+END_SRC

*** Binary Tree Zigzag Level Order Traversal	
    Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).
    
    For example:

    Given binary tree {3,9,20,#,#,15,7},
    #+BEGIN_SRC java
    3
   / \
  9  20
    /  \
   15   7
    #+END_SRC
    return its zigzag level order traversal as:
    #+BEGIN_SRC java
[
  [3],
  [20,9],
  [15,7]
]
    #+END_SRC

广度优先遍历, 用一个 bool 记录是从左到右还是从右到左, 每一层结束就翻转一
下。

**** 递归版,时间复杂度 O(n),空间复杂度 O(n)

#+BEGIN_SRC java
public void traverse(TreeNode root, int level,
                     List<List<Integer>> res, boolean lefttoright) {
    if (root == null) return;
    if (level > res.size())
        res.add(new ArrayList<Integer>());
    if (lefttoright)
        res.get(level - 1).add(root.val);
    else
        res.get(level - 1).add(0, root.val);
    traverse(root.left, level + 1, res, !lefttoright);
    traverse(root.right, level + 1, res, !lefttoright);
}
        
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    traverse(root, 1, res, true);
    return res;
}
#+END_SRC

**** 迭代版,时间复杂度 O(n),空间复杂度 O(n)

广度优先遍历, 用一个 bool 记录是从左到右还是从右到左, 每一层结束就翻转一
下。

#+BEGIN_SRC java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) return res;
    Queue<TreeNode> q = new LinkedList<TreeNode>();
    boolean lefttoright = true;
    List<Integer> level = new ArrayList<Integer>();
    q.add(root);
    q.add(null);      // level separator
    while (!q.isEmpty()) {
        TreeNode curr = q.poll();
        if (curr != null) {
            level.add(curr.val);
            if (curr.left != null) q.add(curr.left);
            if (curr.right != null) q.add(curr.right);
        } else {
            if (lefttoright) {
                res.add(level);
            } else {
                Collections.reverse(level);
                res.add(level);
            }
            level = new ArrayList<Integer>();
            lefttoright = !lefttoright;
            if (q.size() > 0) q.add(null);
        }
    }
    return res;
}
#+END_SRC

*** Recover Binary Search Tree
    Two elements of a binary search tree (BST) are swapped by mistake.
    
    Recover the tree without changing its structure.
    
    Note:

    A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?
    
    O(n) 空间的解法是, 开一个指针数组, 中序遍历, 将节点指针依次存放到数组里, 然后寻找两处逆向的位置, 先从前往后找第一个逆序的位置, 然后从后往前找第二个逆序的位置, 交换这两个指针的值。
    
    中序遍历一般需要用到栈, 空间也是 O(n) 的, 如何才能不使用栈? Morris 中序遍历。

**** 一个 inorder 的解法： 

#+BEGIN_SRC java
public void inOrderTraverse(TreeNode root) {
    if (root == null) return;
    if (root.left != null)
        inOrderTraverse(root.left);

    if (prev.val < root.val) {
        prev = root;
    } else if (prev.val > root.val) {
        if (first == null) {
            first = prev;
            second = root;
        } else second = root;
        prev = root;
    }
    if (root.right != null)
        inOrderTraverse(root.right);
}

public void recoverTree(TreeNode root) {
    if (root == null || (root.left == null && root.right == null)) return;
    if (first == null || second == null) {
        TreeNode curr = root;
        if (curr.left != null)
            while (curr.left != null) 
                curr = curr.left;
        prev = curr;
        inOrderTraverse(root);
    }
    int tmp = first.val;
    first.val = second.val;
    second.val = tmp;
}
#+END_SRC

**** Morris 中序遍历 , 时间复杂度 O(n) , 空间复杂度 O(1)

#+BEGIN_SRC java
public void detect(List<TreeNode> res, TreeNode prev, TreeNode curr) {
    if (prev != null && prev.val > curr.val) {
        if (res.get(0) == null)
            res.add(0, prev); 
        // 不能用 else,例如 {0,1},会导致最后 swap 时 second 为 nullptr,
        // 会 Runtime Error
        res.add(1, curr);
    }
}
        
public void recoverTree(TreeNode root) {
    TreeNode prev = null;
    TreeNode curr = root;
    List<TreeNode> res = new ArrayList<TreeNode>();
    res.add(null);

    while (curr != null) {
        if (curr.left == null) {
            detect(res, prev, curr);
            prev = curr;
            curr = curr.right;
        } else {
            TreeNode node = curr.left;
            while (node.right != null && node.right != curr) {
                node = node.right;
            }
            if (node.right == null) {
                node.right = curr;
                //prev = cur; 不能有这句!因为 cur 还没有被访问
                curr = curr.left;
            } else {
                detect(res, prev, curr);
                node.right = null;
                prev = curr;
                curr = curr.right;
            }
        }
    }
    int tmp = res.get(0).val;
    res.get(0).val = res.get(1).val;
    res.get(1).val = tmp;
}
#+END_SRC

这个可以套成模板，可能写得不熟悉吧，现在写起来还是怎么写怎么别扭，不如
原本朴素的 inorder traverse 来得自然。。。。

*** Same Tree
    Given two binary trees, write a function to check if they are equal or not.
    
    Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
**** 递归版: 时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;  // 终止条件
    if (p == null || q == null) return false; // 剪枝
    return p.val == q.val                     // 三方合并
        && isSameTree(p.left, q.left)                
        && isSameTree(p.right, q.right);
}
#+END_SRC

**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
public boolean isSameTree(TreeNode p, TreeNode q) {
    Stack<TreeNode> s = new Stack<TreeNode>();
    s.push(p);
    s.push(q);
    while (!s.isEmpty()) {
        p = s.pop();
        q = s.pop();
        if (p == null && q == null) continue;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        s.push(p.left);
        s.push(q.left);
        s.push(p.right);
        s.push(q.right);
    }
    return true;
}
#+END_SRC

*** Symmetric Tree
    Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

    For example, this binary tree is symmetric:
    #+BEGIN_SRC java
    1
   / \
  2   2
 / \ / \
3  4 4  3
    #+END_SRC
    But the following is not:
    #+BEGIN_SRC java
    1
   / \
  2   2
   \   \
   3    3
    #+END_SRC
    Note:

    Bonus points if you could solve it both recursively and iteratively.
**** 递归版: 时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
public boolean isSymTree(TreeNode left, TreeNode right) {
    if (left == null && right == null) return true;
    if (left == null || right == null) return false;
    return left.val == right.val
        && isSymTree(left.left, right.right)
        && isSymTree(left.right, right.left);
}

public boolean isSymmetric(TreeNode root) {
    if (root == null ) return true;
    return isSymTree(root.left, root.right);
}
#+END_SRC

**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    Stack<TreeNode> s = new Stack<TreeNode>();
    s.push(root.left);
    s.push(root.right);
    while (!s.isEmpty()) {
        TreeNode p = s.pop();
        TreeNode q = s.pop();
        if (p == null && q == null) continue;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        s.push(p.left);
        s.push(q.right);
        s.push(p.right);
        s.push(q.left);
    }
    return true;
}
#+END_SRC

*** Balanced Binary Tree
    Given a binary tree, determine if it is height-balanced.

    For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

    时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
public int balanceHeight(TreeNode root) {
    if (root == null) return 0;    // 终止条件
    int left = balanceHeight(root.left);
    int right = balanceHeight(root.right);
    if (left < 0 || right < 0 || Math.abs(left - right) > 1)
        return -1;                  // 剪枝
    return Math.max(left, right) + 1;   // 三方合并
}
        
public boolean isBalanced(TreeNode root) {
    return balanceHeight(root) >= 0;
}
#+END_SRC

*** Flatten Binary Tree to Linked List
    Given a binary tree, flatten it to a linked list in-place.

    For example, Given
    #+BEGIN_SRC java
         1
        / \
       2   5
      / \   \
     3   4   6
    #+END_SRC
    
    The flattened tree should look like:
    #+BEGIN_SRC java
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
    #+END_SRC
    click to show hints.
    
    Hints:

    If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.
**** 递归版1: 时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
public void flatten(TreeNode root) {
    if (root == null) return;    // 终止条件
    flatten(root.left);
    flatten(root.right);
    if (root.left == null) return;
    // 三方合并, 将左子树所形成的链表插入到 root 和 root->right 之间
    TreeNode p = root.left;
    while (p.right != null) 
        p = p.right;     //寻找左链表最后一个节点
    p.right = root.right;
    root.right = root.left;
    root.left = null;
}
#+END_SRC

**** 递归版2: 时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
// 把 root 所代表树变成链表后, tail 跟在该链表后面
public TreeNode flatten(TreeNode root, TreeNode tail) {
    if (root == null) return tail;
    root.right = flatten(root.left, flatten(root.right, tail));
    root.left = null;
    return root;
}
        
public void flatten(TreeNode root) {
    flatten(root, null);
}
#+END_SRC

**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
public void flatten(TreeNode root) {
    if (root == null) return;
    Stack<TreeNode> s = new Stack<TreeNode>();
    s.push(root);
    while (!s.isEmpty()) {
        TreeNode p = s.pop();
        if (p.right != null)
            s.push(p.right);
        if (p.left != null)
            s.push(p.left);
        p.left = null;
        if (!s.isEmpty())
            p.right = s.peek();
    }
}
#+END_SRC

*** Populating Next Right Pointers in Each Node II
    Follow up for problem "Populating Next Right Pointers in Each Node".
    
    What if the given tree could be any binary tree? Would your previous solution still work?
    
    Note:
    
    You may only use constant extra space.

    For example,

    Given the following binary tree,
    #+BEGIN_SRC java
         1
       /  \
      2    3
     / \    \
    4   5    7
    #+END_SRC
    
    After calling your function, the tree should look like:
    #+BEGIN_SRC java
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \    \
    4-> 5 -> 7 -> NULL
    #+END_SRC

    要处理一个节点,可能需要最右边的兄弟节点,首先想到用广搜。但广搜不是常数空间的,本题要求常数空间。

    注意,这题的代码原封不动,也可以解决 Populating Next Right Pointers in Each Node I.
**** 递归版: 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public void connect(TreeLinkNode root) {
    if (root == null) return;
    TreeLinkNode dummy = new TreeLinkNode(-1);
    for (TreeLinkNode curr = root, prev = dummy;
         curr != null;
         curr = curr.next) {
        if (curr.left != null) {
            prev.next = curr.left;
            prev = prev.next;
        }
        if (curr.right != null) {
            prev.next = curr.right;
            prev = prev.next;
        }
    }
    connect(dummy.next);
}
#+END_SRC

**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(1)

#+BEGIN_SRC java
public void connect(TreeLinkNode root) {
    while (root != null) {
        TreeLinkNode next = null;
        TreeLinkNode prev = null;
        for (; root != null;
             root = root.next) {
            if (next == null) 
                next = root.left != null ? root.left : root.right;
            if (root.left != null) {
                if (prev != null)
                    prev.next = root.left;
                prev = root.left;
            }
            if (root.right != null) {
                if (prev != null)
                    prev.next = root.right;
                prev = root.right;
            }
        }
        root = next;
    }
}
#+END_SRC
    
二叉树的构建
*** Construct Binary Tree from Preorder and Inorder Traversal
    Given preorder and inorder traversal of a tree, construct the binary tree.

    Note:
    
    You may assume that duplicates do not exist in the tree.

**** 递归,时间复杂度 O(n), 空间复杂度 O(logn)    

c++版别人写得比较精致的代码 ： 

#+BEGIN_SRC java
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return buildTree(begin(preorder), end(preorder),
                         begin(inorder), end(inorder));
    }
    template<typename InputIterator>
    TreeNode* buildTree(InputIterator pre_first, InputIterator pre_last,
                        InputIterator in_first, InputIterator in_last) {
        if (pre_first == pre_last) return nullptr;
        if (in_first == in_last) return nullptr;
        auto root = new TreeNode(*pre_first);
        auto inRootPos = find(in_first, in_last, *pre_first);
        auto leftSize = distance(in_first, inRootPos);
        root->left = buildTree(next(pre_first), next(pre_first, leftSize + 1),
                               in_first, next(in_first, leftSize));
        root->right = buildTree(next(pre_first, leftSize + 1), pre_last,
                                next(inRootPos), in_last);
        return root;
    }
};
#+END_SRC

#+BEGIN_SRC java
public int getIdx(int [] a, int val) {
    int idx = 0;
    for (int i = 0; i < a.length; i++) {
        if (a[i] == val) {
            idx = i;
            break;
        }
    }
    return idx;
}
        
public TreeNode helper(int [] pre, int [] in, int idx, int bgn, int end) {
    if (bgn > end) return null;
    TreeNode root = new TreeNode(pre[idx]);
    if (bgn == end) return root;

    int inEnd = getIdx(in, pre[idx]);
    root.left = helper(pre, in, idx + 1, bgn, inEnd - 1);
    root.right = helper(pre, in, idx + (inEnd - bgn) + 1, inEnd + 1, end);
    return root;
}

public TreeNode buildTree(int[] preorder, int[] inorder) {
    return helper(preorder, inorder, 0, 0, inorder.length - 1);
}
#+END_SRC

*** Construct Binary Tree from Inorder and Postorder Traversal
    Given inorder and postorder traversal of a tree, construct the binary tree.
    
    Note:

    You may assume that duplicates do not exist in the tree.

**** 递归,时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return buildTree(begin(inorder), end(inorder),
                         begin(postorder), end(postorder));
    }
    template<typename BidiIt>
    TreeNode* buildTree(BidiIt in_first, BidiIt in_last,
                        BidiIt post_first, BidiIt post_last) {
        if (in_first ==in_last) return nullptr;
        if (post_first == post_last) return nullptr;
        const auto val = *prev(post_last);
        TreeNode* root = new TreeNode(val);
        auto in_root_pos = find(in_first, in_last, val);
        auto left_size = distance(in_first, in_root_pos);
        auto post_left_last = next(post_first, left_size);
        root->left = buildTree(in_first, in_root_pos, post_first, post_left_last);
        root->right = buildTree(next(in_root_pos), in_last,
                                post_left_last, prev(post_last));
        return root;
    }
};
#+END_SRC

#+BEGIN_SRC java
public int getIdx(int [] a, int val) {
    int idx = 0;
    for (int i = 0; i < a.length; i++) {
        if (a[i] == val) {
            idx = i;
            break;
        }
    }
    return idx;
}
        
public TreeNode helper(int [] in, int [] post, int idx, int bgn, int end) {
    if (bgn > end) return null;
    TreeNode root = new TreeNode(post[idx]);
    if (bgn == end) return root;
    int inEnd = getIdx(in, post[idx]);
    root.left = helper(in, post, idx - (end - inEnd) - 1, bgn, inEnd - 1);
    root.right = helper(in, post, idx - 1, inEnd + 1, end);
    return root;
}
        
public TreeNode buildTree(int[] inorder, int[] postorder) {
    return helper(inorder, postorder, postorder.length - 1, 0, inorder.length - 1);
}
#+END_SRC

二叉树查找

*** Validate Binary Search Tree	
    Given a binary tree, determine if it is a valid binary search tree (BST).
    
    Assume a BST is defined as follows:
- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than the node's key.
- Both the left and right subtrees must also be binary search trees.
 
    时间复杂度 O(n),空间复杂度 O( log(n) )

c++版:
#+BEGIN_SRC java
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST(root, INT_MIN, INT_MAX);
    }
    bool isValidBST(TreeNode* root, int lower, int upper) {
        if (root == nullptr) return true;
        if (root->val == INT_MIN && root->left)
            return false;
        if(root->val == INT_MAX && root->right)
            return false;
        return root->val >= lower && root->val <= upper
            && isValidBST(root->left, lower, root->val -1)
            && isValidBST(root->right, root->val + 1, upper);
    }
};

#+END_SRC

Java版：
#+BEGIN_SRC java
private boolean isValidBST(TreeNode root, int lower, int upper) {
    if (root == null) return true;
    if (root.val == Integer.MIN_VALUE && root.left != null)
        return false;
    if(root.val == Integer.MAX_VALUE && root.right != null)
        return false;
    return root.val >= lower && root.val <= upper
        && isValidBST(root.left, lower, root.val - 1)
        && isValidBST(root.right, root.val + 1, upper);
}
        
public boolean isValidBST(TreeNode root) {
    return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
}
#+END_SRC

自已写的繁琐版的代码 ： inorder traversal的
#+BEGIN_SRC java
public void inOrderTraversal(TreeNode root, List<Integer> res) {
    if (root == null) return;
    if (root.left != null)
        inOrderTraversal(root.left, res);
    res.add(root.val);
    if (root.right != null)
        inOrderTraversal(root.right, res);
}
        
public boolean isValidBST(TreeNode root) {
    if (root == null || (root.left == null && root.right == null)) return true;
    List<Integer> res = new ArrayList<Integer>();
    inOrderTraversal(root, res);
    for (int i = 1; i < res.size(); i++) {
        if (res.get(i) <= res.get(i - 1)) return false;
    }
    return true;
}
#+END_SRC

*** Convert Sorted Array to Binary Search Tree
    Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

    二分法。

**** 分治法, 时间复杂度 O(n), 空间复杂度 O(logn)

#+BEGIN_SRC java
class Solution {
public:
    TreeNode* sortedArrayToBST (vector<int>& num) {
        return sortedArrayToBST(num.begin(), num.end());
    }
    template<typename RandomAccessIterator>
    TreeNode* sortedArrayToBST (RandomAccessIterator first,
                                RandomAccessIterator last) {
        const auto length = distance(first, last);
        if (length <= 0) return nullptr;    // 终止条件
        // 三方合并
        auto mid = first + length / 2;
        TreeNode* root = new TreeNode (*mid);
        root->left = sortedArrayToBST(first, mid);
        root->right = sortedArrayToBST(mid + 1, last);
        return root;
    }
};
#+END_SRC

Java版：

#+BEGIN_SRC java
public TreeNode createMyTree(int [] num, int bgn, int end) {
    TreeNode root = null;
    if (bgn == end) {
        root = new TreeNode(num[end]);
        return root;
    }
    if (bgn < end) {
        int mid = bgn + (end - bgn) / 2;
        root = new TreeNode(num[mid]);
        root.left = createMyTree(num, bgn, mid - 1);
        root.right = createMyTree(num, mid + 1, end);
        return root;
    }
    return null;
}
        
public TreeNode sortedArrayToBST(int[] num) {
    if (num == null || num.length == 0) return null;
    TreeNode root = createMyTree(num, 0, num.length - 1);
    return root;
}
#+END_SRC

*** Convert Sorted List to Binary Search Tree: bug.....
    Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

    这题与上一题类似,但是单链表不能随机访问,而自顶向下的二分法必须需要 RandomAccessIt-erator,因此前面的方法不适用本题。

    存在一种自底向上(bottom-up)的方法, 见 

    http://leetcode.com/2010/11/convert-sorted-list-to-balanced-binary.html

**** 分治法： 自项向下

分治法, 类似于 Convert Sorted Array to Binary Search Tree, 自顶向下, 复杂度 O(n log n)。

自顶向下, 时间复杂度 O(n^2), 空间复杂度 O(logn)

#+BEGIN_SRC java
class Solution {
public:
    int listLength (ListNode* node) {
        int n = 0;
        while(node) {
            ++n;
            node = node->next;
        }
        return n;
    }
    ListNode* nth_node (ListNode* node, int n) {
        while (--n)
            node = node->next;
        return node;
    }
    TreeNode* sortedListToBST (ListNode* head) {
        return sortedListToBST (head, listLength(head));
    }
    TreeNode* sortedListToBST (ListNode* head, int len) {
        if (len == 0) return nullptr;
        if (len == 1) return new TreeNode (head->val);
        TreeNode* root = new TreeNode(nth_node (head, len / 2 + 1)->val);
        root->left = sortedListToBST(head, len / 2);
        root->right = sortedListToBST(nth_node (head, len / 2 + 2),
                                       (len - 1) / 2);
        return root;
    }
};
#+END_SRC

Java: 
#+BEGIN_SRC java
public int listLength(ListNode head) {
    int n = 0;
    while (head != null) {
        ++n;
        head = head.next;
    }
    return n;
}

ListNode nth_node(ListNode node, int n) {
    while (--n > 0) 
        node = node.next;
    return node;
}
        
public TreeNode sortListToBST(ListNode head, int len) {
    if (len == 0) return null;
    if (len == 1) return new TreeNode(head.val);
    TreeNode root = new TreeNode(nth_node(head, len / 2 + 1).val);
    root.left = sortListToBST(head, len / 2);
    root.right = sortListToBST(nth_node(head, len / 2 + 2), (len - 1) / 2);
    return root;
}
        
public TreeNode sortedListToBST(ListNode head) {
    return sortListToBST(head, listLength(head));
}
#+END_SRC

换一种方式，如果我只走一遍 list,那可以把数据存在一个数组中，方便O（1）
时间获得数据。自已写的乱代码。

#+BEGIN_SRC java
public TreeNode createMyTree(ListNode [] num, int bgn, int end) {
    TreeNode root = null;
    if (bgn == end) {
        root = new TreeNode(num[end].val);
        return root;
    }
    if (bgn < end) {
        int mid = bgn + (end - bgn) / 2;
        root = new TreeNode(num[mid].val);
        root.left = createMyTree(num, bgn, mid - 1);
        root.right = createMyTree(num, mid + 1, end);
        return root;
    }
    return null;
}

public TreeNode sortedListToBST(ListNode head) {
    TreeNode root = null;
    if (head == null) return null;
    else if (head.next == null) {
        root = new TreeNode(head.val);
        return root;   
    }
    ListNode [] num = new ListNode[100000]; // 10,0000 works, 50000 doesn't
    ListNode curr = head;
    int idx = 0;
    while (curr != null) {
        num[idx++] = curr;
        curr = curr.next;
    }
    root = createMyTree(num, 0, idx - 1);
    return root;
}
#+END_SRC

**** 自底向上: bottom-up, 时间复杂度 O(n), 空间复杂度 O(logn), bug.....

c++版:
#+BEGIN_SRC java
class Solution {
public:
    TreeNode *sortedListToBST(ListNode *head) {
        int len = 0;
        ListNode *p = head;
        while (p) {
            len++;
            p = p->next;
        }
        return sortedListToBST(head, 0, len - 1);
    }
private:
    TreeNode* sortedListToBST(ListNode*& list, int start, int end) {
        if (start > end) return nullptr;
        int mid = start + (end - start) / 2;
        TreeNode *leftChild = sortedListToBST(list, start, mid - 1);
        TreeNode *parent = new TreeNode(list->val);
        parent->left = leftChild;
        list = list->next;
        parent->right = sortedListToBST(list, mid + 1, end);
        return parent;
    }
};
#+END_SRC

Java版：

#+BEGIN_SRC java
// I don't understand where I got wrong yet....
public TreeNode sortListToBST(ListNode head, int bgn ,int end) {
    if (bgn > end) return null;
    int mid = bgn + (end - bgn) / 2;
    TreeNode left = sortListToBST(head, bgn, mid - 1);
    TreeNode root = new TreeNode(head.val);
    root.left = left;
    head = head.next;     // attention !
    root.right = sortListToBST(head, mid + 1, end);
    return root;
}
        
public TreeNode sortedListToBST(ListNode head) {
    int len = 0;
    ListNode p = head;
    while (p != null) {
        len++;
        p = p.next;
    }
    return sortListToBST(head, 0, len - 1);
}
#+END_SRC

二叉树递归
   二叉树是一个递归的数据结构,因此是一个用来考察递归思维能力的绝佳数据结构。递归一定是深搜(见“深搜与递归的区别”),由于在二叉树上,递归的味道更浓些,因此本节用“二叉树的递归”作为标题,而不是“二叉树的深搜”,尽管本节所有的算法都属于深搜。

二叉树的先序、中序、后序遍历都可以看做是 DFS,此外还有其他顺序的深度优先遍历,共有3! = 6 种。其他 3 种顺序是 root -> right -> left,right -> root -> left, right -> left -> root。
*** Minimum Depth of Binary Tree	
    Given a binary tree, find its minimum depth.

    The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
**** 递归版: 时间复杂度 O(n), 空间复杂度 O( log(n) )

#+BEGIN_SRC java
public int minDepth(TreeNode root, boolean hasBrother) {
    if (root == null) return hasBrother ? Integer.MAX_VALUE : 0;
    return 1 + Math.min(minDepth(root.left, root.right != null),
                        minDepth(root.right, root.left != null));
}
        
public int minDepth(TreeNode root) {
    return minDepth(root, false);
}
#+END_SRC

**** 迭代版: 时间复杂度 O(n), 空间复杂度 O( log(n) )

#+BEGIN_SRC java
public class Tnd {
    TreeNode tn;
    int dep;
    public Tnd() {
        tn = null;
        dep = 0;
    }
    public Tnd(TreeNode x, int y) {
        tn = x;
        dep = y;
    }
}

public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int res = Integer.MAX_VALUE;
    Stack<Tnd> s = new Stack<Tnd>();
    s.push(new Tnd(root, 1));
    while (!s.isEmpty()) {
        Tnd tmp = s.pop();
        TreeNode curr = tmp.tn;
        int depth = tmp.dep;
        if (curr.left == null && curr.right == null)
            res = Math.min(res, depth);
        if (curr.left != null && res > depth) // 深度控制,剪枝
            s.push(new Tnd(curr.left, depth + 1));
        if (curr.right != null && res > depth) // 深度控制,剪枝
            s.push(new Tnd(curr.right, depth + 1));
    }
    return res;
}
#+END_SRC

*** Maximum Depth of Binary Tree	
    Given a binary tree, find its maximum depth.
    
    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

时间复杂度 O(n), 空间复杂度 O(logn). 

#+BEGIN_SRC java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
#+END_SRC

*** Path Sum
    Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
    
    For example:
    
    Given the below binary tree and sum = 22,
    #+BEGIN_SRC java
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
    #+END_SRC

    return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

    题目只要求返回 true 或者 false,因此不需要记录路径。

    由于只需要求出一个结果,因此,当左、右任意一棵子树求到了满意结果,都可以及时 return。

    由于题目没有说节点的数据一定是正整数,必须要走到叶子节点才能判断,因此中途没法剪枝,只能进行朴素深搜。

    时间复杂度 O(n), 空间复杂度 O( log(n) )

#+BEGIN_SRC java
public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) return false;
    if (root.left == null && root.right == null)
        return sum == root.val;
    return hasPathSum(root.left, sum - root.val)
        || hasPathSum(root.right, sum - root.val);
}
#+END_SRC

*** Path Sum II
    Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
    
    For example:
    
    Given the below binary tree and sum = 22,
    #+BEGIN_SRC java
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
    #+END_SRC

    return
    #+BEGIN_SRC java
[
   [5,4,11,2],
   [5,8,4,5]
]
    #+END_SRC

    跟上一题相比,本题是求路径本身。且要求出所有结果,左子树求到了满意结果,不能 return, 要接着求右子树。

    时间复杂度 O(n), 空间复杂度 O( log(n) )

#+BEGIN_SRC java
public void pathSum(TreeNode root, int gap, List<Integer> curr,
                    List<List<Integer>> res) {
    if (root == null) return;
    curr.add(root.val);
    if (root.left == null && root.right == null) 
        if (root.val == gap) 
            res.add(curr);
    pathSum(root.left, gap - root.val, new ArrayList<Integer>(curr), res);
    pathSum(root.right, gap - root.val, new ArrayList<Integer>(curr), res);
}
        
public List<List<Integer>> pathSum(TreeNode root, int sum) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    List<Integer> curr = new ArrayList<Integer>();
    pathSum(root, sum, curr, res);
    return res;
}
#+END_SRC

c++版：
#+BEGIN_SRC java
class Solution {
public:
    vector<vector<int> > pathSum(TreeNode *root, int sum) {
        vector<vector<int> > result;
        vector<int> cur; // 中间结果
        pathSum(root, sum, cur, result);
        return result;
    }
private:
    void pathSum(TreeNode *root, int gap, vector<int> &cur,
                 vector<vector<int> > &result) {
        if (root == nullptr) return;
        cur.push_back(root->val);
        if (root->left == nullptr && root->right == nullptr) { // leaf
            if (gap == root->val)
                result.push_back(cur);
        }
        pathSum(root->left, gap - root->val, cur, result);
        pathSum(root->right, gap - root->val, cur, result);
        cur.pop_back();
    }
};
#+END_SRC

两个版本对于取不取当前值的控制略为不同。

*** Populating Next Right Pointers in Each Node
    Given a binary tree
    #+BEGIN_SRC java
public class TreeLinkNode {
    int val;
    TreeLinkNode left, right, next;
    TreeLinkNode(int x) {
        val = x;
    }
}
    #+END_SRC

    Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

    Initially, all next pointers are set to NULL.
    
    Note:
    
    You may only use constant extra space.

    You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

    For example,

    Given the following perfect binary tree,
    #+BEGIN_SRC java
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
    #+END_SRC

    After calling your function, the tree should look like:
    #+BEGIN_SRC java
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL
    #+END_SRC

    时间复杂度 O(n), 空间复杂度 O( log(n) )

#+BEGIN_SRC java
public void connect(TreeLinkNode root, TreeLinkNode sibling) {
    if (root == null) return;
    else root.next = sibling;
    connect(root.left, root.right);
    if (sibling != null)
        connect(root.right, sibling.left);
    else
        connect(root.right, null);
}

public void connect(TreeLinkNode root) {
    connect(root, null);
}
#+END_SRC    

*** Sum Root to Leaf Numbers
    Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
    
    An example is the root-to-leaf path 1->2->3 which represents the number 123.
    
    Find the total sum of all root-to-leaf numbers.
    
    For example,
    #+BEGIN_SRC java
    1
   / \
  2   3
    #+END_SRC

    The root-to-leaf path 1->2 represents the number 12.
    
    The root-to-leaf path 1->3 represents the number 13.
    
    Return the sum = 12 + 13 = 25.

    时间复杂度 O(n), 空间复杂度 O( log(n) )

#+BEGIN_SRC java
public int dfs(TreeNode root, int sum) {
    if (root == null) return 0;
    if (root.left == null && root.right == null)
        return sum * 10 + root.val;
    return dfs(root.left, sum * 10 + root.val)
        + dfs(root.right, sum * 10 + root.val);
}
        
public int sumNumbers(TreeNode root) {
    return dfs(root, 0);
}
#+END_SRC

*** Binary Tree Upside Down
    Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

    For example:

    Given a binary tree {1, 2, 3, 4, 5},
    #+BEGIN_SRC java
    1
   / \
  2   3
 / \
4   5
    #+END_SRC
    
    return the root of the binary tree [4, 5, 2, #, #, 3, 1].
    #+BEGIN_SRC java
   4
  / \
 5   2
    / \
   3   1  
    #+END_SRC

**** Recursive: 

#+BEGIN_SRC java
TreeNode* newRoot = NULL;
bool found = false;

void recursive(TreeNode* root) {
    if (root->left == NULL) return;
    recursive(root->left);
    if (root->left->left == NULL) {
        if (!found) {
            newRoot = root->left;
            found = true;
        }
        root->left->left = root->right;
        root->right = NULL;
        root->left->right = root;
        root->left = NULL;
    }
}

TreeNode *upsideDownBinaryTree(TreeNode *root) {
    if (root == NULL) return NULL;
    if (root->left == NULL) return root;
    recursive(root);
    return newRoot;
}
#+END_SRC

didn't realize it's c++, java later....
**** Iterative: 

#+BEGIN_SRC java
#+END_SRC

*** Binary Search Tree Iterator	
    Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
    
    Calling next() will return the next smallest number in the BST.
    
    Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

#+BEGIN_SRC java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class BSTIterator {
    private Stack<TreeNode> stack = new Stack<TreeNode>();
    public BSTIterator(TreeNode root) {
        pushAll(root);
    }
    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    /** @return the next smallest number */
    public int next() {
        TreeNode tmpNode = stack.pop();
        pushAll(tmpNode.right);
        return tmpNode.val;
    }
    private void pushAll(TreeNode node) {
        for(; node != null; stack.push(node), node = node.left);
    }
}
/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
#+END_SRC

*** Binary Tree Maximum Path Sum	
    Given a binary tree, find the maximum path sum.
    
    The path may start and end at any node in the tree.
    
    For example:

    Given the below binary tree,
    #+BEGIN_SRC java
       1
      / \
     2   3
    #+END_SRC

    Return 6.

    这题很难,路径可以从任意节点开始,到任意节点结束。

    可以利用“最大连续子序列和”问题的思路,见第 Maximum Sum SubArray [[Maximum Sum SubArray]]。如果说 Array只有一个方向的话, 那么 Binary Tree 其实只是左、右两个方向而已,我们需要比较两个方向上的值。

    不过,Array 可以从头到尾遍历,那么 Binary Tree 怎么办呢,我们可以采用 Binary Tree 最常用的 dfs 来进行遍历。先算出左右子树的结果 L 和 R,如果 L 大于 0,那么对后续结果是有利的,我们加上 L,如果 R 大于 0,对后续结果也是有利的,继续加上 R。

    时间复杂度 O(n), 空间复杂度 O( log(n) )

#+BEGIN_SRC java
private int res;

public int dfs(TreeNode root) {
    if (root == null) return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    int sum = root.val;
    if (left > 0) sum += left;
    if (right > 0) sum += right;
    res = Math.max(res, sum);
    return Math.max(right, left) > 0 ? Math.max(right, left) + root.val : root.val;
}
        
public int maxPathSum(TreeNode root) {
    res = Integer.MIN_VALUE;
    dfs(root);
    return res;
}
#+END_SRC

注意, 最后 return 的时候, 只返回一个方向上的值, 为什么?这是因为在递归中, 只能向父节
点返回, 不可能存在 L -> root -> R 的路径, 只可能是 L -> root 或 R -> root。

*** others Covered
- Unique Binary Search Tree
  [[Unique Binary Search Tree]]
- Unique Binary Search Tree II
  [[Unique Binary Search Tree II]]


** 栈 Stack
*** Valid Parentheses
    Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

    The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

    时间复杂度 O(n), 空间复杂度 O(n)。

*** Evaluate Reverse Polish Notation
    Evaluate the value of an arithmetic expression in Reverse Polish Notation.
    
    Valid operators are +, -, *, /. Each operand may be an integer or another expression.
    
    Some examples:
    #+BEGIN_SRC java
  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
    #+END_SRC

*** Simplify Path
    Given an absolute path for a file (Unix-style), simplify it.
    
    For example,
    #+BEGIN_SRC java
    path = "/home/", => "/home"
    path = "/a/./b/../../c/", => "/c"
    #+END_SRC
    
    click to show corner cases.
    
    Corner Cases:
    #+BEGIN_SRC java
    Did you consider the case where path = "/../"?
    In this case, you should return "/".
    Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
    In this case, you should ignore redundant slashes and return "/home/foo".
    #+END_SRC

Hard
*** Longest Valid Parentheses
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

For "(()", the longest valid parentheses substring is "()", which has length = 2.

Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.
**** 使用栈: 时间复杂度 O(n), 空间复杂度 O(n)

这个问题有点不一样的地方是，输入很可能不合理，也就是括号很可能不匹配，这怎么做？我的做法是用一个数组来做标记，依然是左括号入栈（入栈的是他的位置）。右括号出栈，当一对括号成功匹配的时候，把标记数组中他们相对应的位置标记为1。这样过一遍之后，扫描一下整个标记数组，有多少个连续的1，就是有多少个连续的匹配，输出一下个数就行了。
#+BEGIN_SRC java
public int longestValidParentheses(String s) {
    Stack<Integer> k = new Stack<Integer>();
    int [] res = new int[s.length()];
    char j;
    int tmp = 0;
    for (int i = 0; i < s.length(); i++) {
        j = s.charAt(i);
        if (j == '(') 
            k.push(i);
        else if (j == ')'){
            if (!k.isEmpty()) {
                res[i] = 1;
                tmp = k.pop();
                res[tmp] = 1;
            }
        }
    }
    int max = 0;
    int i = 0;
    while (i < s.length()) {
        tmp = 0;  // reset value
        while (i < s.length() && res[i] == 0) i++;
        while (i < s.length() && res[i] == 1) {
            tmp++;
            i++;
        }
        max = Math.max(max, tmp);
    }
    return max;
}
#+END_SRC

不用数组的思路： 

在处理括号匹配问题上，我们一般使用栈来解决。这一题也可以。

顺序扫描字符串：

初始化：在栈中压入-1

一、若碰到'('，则把当前位置压入栈中

二、若碰到')'：

     (1)、如果栈顶元素不是'('，则把当前位置压入栈中；

     (2)、如果栈顶元素时'('：栈顶元素出栈，当前的合法子串长度 = 当前字符索引 - 新的栈顶元素；更新最大子串长度
#+BEGIN_SRC java
public int longestValidParentheses1(String s) {
    Stack<Integer> k = new Stack<Integer>();
    int res = 0;
    int tmp = 0;
    k.push(-1); // 
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(')
            k.push(i);
        else { // ')'
            if (k.isEmpty())
                k.push(i);
            else {
                tmp = k.peek();
                if (tmp >= 0 && s.charAt(tmp) == '(') {
                    k.pop();
                    res = Math.max(res, i - k.peek());
                } else k.push(i);
            }
        }
    }
    return res;
}
#+END_SRC
**** 动态规划： 

这种括号匹配的问题一般使用动态规划进行解决。使用 dp[i] 表示从位置 i 开始的最长合法括号序列的长度。

考虑第 i 个位置的括号：
- 如果是右括号，则 dp[i] = 0， 因为第一个是右括号是没有合法匹配
- 如果是左括号，则考虑下一个位置 i+1 的情况，事实上，这是dp[i+1]的问题，可以以同样方法解决。之后可以知道第i位该匹配的位置为 i + dp[i+1] + 1 的位置，直接判断其是否匹配即可。
注意做括号匹配到其对应的右括号时，后面可能还有左括号以继续匹配。
#+BEGIN_SRC java
public int longestValidParentheses(String s) {
    int n = s.length();
    int res = 0;
    int [] dp = new int[n]; // dp[i] 表示从 i 开始的最长合法括号序列
    int j = 0;
    for (int i = n - 2; i >= 0; i--) {
        if (s.charAt(i) == '(') {  // 第一个括号必须为左括号
            j = dp[i + 1] + i + 1; // 匹配该左括号的位置
            if (j < n && s.charAt(j) == ')') { // 满足匹配
                dp[i] = dp[i + 1] + 2;
                if (j + 1 < n)
                    dp[i] += dp[j + 1];     // 后面可能还有
                res = Math.max(res, dp[i]);
            }
        }
    }
    return res;
}
#+END_SRC

*** Trapping Rain Water
    Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

    For example, 

    Given [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], return 6.
    
    #+CAPTION: Trapping Rain Water
    [[./pic/rainwatertrap.png]]
    
    The above elevation map is represented by array [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
    
    *Tags:* Array, Stack, Two Pointers

    对于每个柱 子,找到其左右两边最 高的柱子, 该柱子能容纳的面积就是 min(max\textunderscore left, max\textunderscore right) - height。所以,
    
1. 从左往右扫描一遍,对于每个柱子,求取左边最大值;
2. 从右往左扫描一遍,对于每个柱子,求最大右值;
3. 再扫描一遍,把每个柱子的面积并累加。
也可以,
1. 扫描一遍,找到最高的柱子,这个柱子将数组分为两半;
2. 处理左边一半;
3. 处理右边一半。
**** 思路 1, 时间复杂度 O(n), 空间复杂度 O(n)
**** 思路 2, 时间复杂度 O(n), 空间复杂度 O(1)
**** 思路 3, 时间复杂度 O(n), 空间复杂度 O(n)
**** 
*** Largest Rectangle in Histogram
    Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
    
    #+CAPTION: Largest Rectangle in Histogram 1
    [[./pic/rectangle1.png]]

    Above is a histogram where width of each bar is 1, given height = [2, 1, 5, 6, 2, 3].

    #+CAPTION: Largest Rectangle in Histogram 2
    [[./pic/rectangle2.png]]
    
    The largest rectangle is shown in the shaded area, which has area = 10 unit.
    
    For example,

    Given height = [2, 1, 5, 6, 2, 3],

    return 10.

    简单的, 类似于 Container With Most Water(), 对每个柱子, 左右扩展, 直到碰到比自己矮的, 计算这个矩形的面积, 用一个变量记录最大的面积, 复杂度 O(n^2 ), 会超时。

    如图所示, 从左到右处理直方, 当 i = 4 时, 小于当前栈顶(即直方 3),  对于直方 3, 无论后面还是前面的直方, 都不可能得到比目前栈顶元素更高的高度了, 处理掉直方 3(计算从直方 3到直方 4 之间的矩形的面积, 然后从栈里弹出); 对于直方 2 也是如此; 直到碰到比直方 4 更矮的直方 1。

    这就意味着, 可以维护一个递增的栈, 每次比较栈顶与当前元素。如果当前元素小于栈顶元素, 则入栈, 否则合并现有栈, 直至栈顶元素小于当前元素。结尾时入栈元素 0, 重复合并一次。
**** O (n^2)

最暴力的方法就是枚举所有区间的最大矩形值，然后选择最大的。可以通过分别枚举区间右边界和区间左边界，时间复杂度O(n^2)这样做大数据会超时。

枚举的过程中可以优化一下： 如果 height[i+1] > height[i], 那么区间 [k...i] 内的最大矩形肯定不会超过区间 [k...i+1] 内的最大矩形， 比如上例中的区间 [0...3] 内的矩形要大于 [0...2] 内的矩形， 因为 height[ 3 ] > height[ 2 ]。因此我们在枚举区间右边界时，只选择那些 height 上升区间的最大值处作为右边界（比如例子中的2 、6 、3）。优化后可以通过leetcode的大数据，虽然做了优化，但是时间复杂度还是O(n^2)。

#+BEGIN_SRC java
public int largestRectangleArea(int[] height) {
    int n = height.length;
    int res = 0;
    int right = 0;
    int local = 0;
    int minVal = 0;
    while (right < n) {
        if (right + 1 < n && height[right + 1] >= height[right])
            right++;
        else { // found right border
            minVal = height[right];
            for (int left = right; left >= 0; left--) {
                minVal = Math.min(minVal, height[left]);
                local = minVal * (right - left + 1);
                res = Math.max(res, local);
            }
            right++;
            local = 0;
            minVal = 0;
        }
    }
    return res;
}
#+END_SRC

**** 栈： 时间复杂度 O(n), 空间复杂度 O(n)。

主要思路：

我们知道，每个木板将对应多个包含自身的直方图面积，我们从中选取最大的一个面积。

以上题为例，height[ 1 ]对应的包含自身直方图面积集合为 {1, 2, 3, 4, 5, 6 } ，我们只需要知道最大的面积 6 即可，其它的面积就不用考虑。

我们就比较所有height[i] 对应最大直方图面积，把整体最大的直方图面积记为maxArea。

分析到这，我们很明显的可以知道时间复杂度为 O(n)。

现在关键问题就变为如何得到 height[i] 对应的最大直方图面积。

这里用一个栈s来保存之前的元素索引。

s为空时，直接让 i 栈: 以下取 i 从 0 到 n-1 。

- 当 height[i] < height[s.top()] 时，说明 height[s.top()] 对应的直方图面积不会再增加了，此时达到最大，可以出栈了；

- 当 height[i] >= height[s.top()] 时，说明 height[s.top()] 对应的直方图面积还是有潜力增加的哈，此时，i 入栈，++i 。

当 i 达到 n 时，而栈不为空，说明还有部分height中元素对应的最大直方图面积没有求出来.

于是，当栈不为空时，求 height[s.top()] 对应最大直方图面积。

#+BEGIN_SRC java
public int largestRectangleArea(int[] height) {
    Stack<Integer> s = new Stack<Integer>();
    int [] hnew = new int[height.length + 1];// 数组末尾插入 dummy 元素 0
    hnew = Arrays.copyOf(height, height.length + 1);
    int res = 0; 
    int tmp;     
    int left;
    for (int i = 0; i <= height.length; i++) {
        if (s.isEmpty() || hnew[i] > hnew[s.peek()])
            s.push(i); // 栈内保存的是数组 height 的下标索引
        else {
            tmp = s.pop();
            res = Math.max(res, hnew[tmp] * 
                           (s.isEmpty() ? i : i - s.peek() - 1));
            i--;
        }
    }
    return res;
}
#+END_SRC

这题应该还有很多很巧妙的解法，念天脑袋不太转，暂时留在这里吧，改天再回来修改~~

http://www.cnblogs.com/felixfang/p/3676193.html

*** others Covered
- Binary Tree Preorder Traversal
  [[Binary Tree Preorder Traversal]]
- Binary Tree Inorder Traversal
  [[Binary Tree Inorder Traversal]]
- Binary Tree Postorder Traversal
  [[Binary Tree Postorder Traversal]]
- Binary Search Tree Iterator	
  [[Binary Search Tree Iterator	]]
- Binary Tree Zigzag Level Order Traversal
  [[Binary Tree Zigzag Level Order Traversal]]
- Maximal Rectangle
  [[Maximal Rectangle]]
- Min Stack
  [[Min Stack]]

** Hash Table
*** Valid Sudoku
*** Two Sum III
*** Two Sum
*** 4Sum
*** Binary Tree Inorder Traversal
*** Fraction to Recurring Decimal
*** Single Number
*** Anagrams
*** Longest Substring Without Repeating Characters	
*** Minimum Window Substring
*** Copy List with Random Pointer
*** Sudoku Solver
*** Max Points on a Line
*** Substring with Concatenation of All Words
*** Longest Substring with At Most Two Distinct Characters
other Covered
- Maximal Rectangle
  [[Maximal Rectangle]]
