\chapter{Networking}

\begin{description}
\item[17.1] Explain what happens, step by step, after you type a URL into a browser. Use as much detail as possible.



一步一步地解释一下，在你往浏览器中输入一个URL后都发生了什么。要尽可能详细。

  Solution:

  这道题目没有所谓的完全的正确答案，这个题目可以让你在任意的一个点深入下去， 只要你对这个点是熟悉的。以下是一个大概流程：
  \begin{enumerate}
  \item 浏览器向DNS服务器查找输入URL对应的IP地址。
  \item DNS服务器返回网站的IP地址。
  \item 浏览器根据IP地址与目标web服务器在80端口上建立TCP连接
  \item 浏览器获取请求页面的html代码。
  \item 浏览器在显示窗口内渲染HTML。
  \item 窗口关闭时，浏览器终止与服务器的连接。
  \end{enumerate}
  这其中最有趣的是第1步和第2步(域名解析)。我们输入的网址(域名)是IP地址的一个别名， 在一个DNS内，一个域名对应一个IP地址。域名系统(DNS) 的工作就是将域名与它的IP地址对应起来。DNS是分布式的，同时也是具有层级关系的。

  一个域名服务器虽然只记录一个小的子网内的主机名和IP地址， 但所有的域名服务器联合起来工作，就能将全网内的域名与它们的IP地址对应起来。 这也就意味着，如果一个域名服务器无法找到某个请求域名所对应的IP地址， 它就会向其它的域名服务器发出请求进行寻找。

  关于这个问题，推荐阅读以下文章：

  原文： What really happens when you navigate to a URL

  http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/

  译文： 当你在浏览器地址栏输入一个URL后回车，将会发生的事情

  http://www.cnblogs.com/panxueji/archive/2013/05/12/3073924.html




\item[17.2] Explain any common routing protocol in detail. For example: BGP, OSPF, RIP.	

  介绍常用路由协议。例如：BGP，OSPF，RIP

  Solution:

  这个可以根据具体以后从事职位与其的相关度做不同程度的了解。这里只做一个简单介绍。
  \begin{description}
  \item[BGP]: Border Gateway Protocol (边界网关协议)

    BGP是互联网上的一个核心路由协议。当BGP路由器第一次出现在互联网上时， 它会与那些和它能直接通信的其它BGP路由器建立连接。建立连接后的第一件事， 是从它相邻的路由器下载整个路由表。做完这件事后， 它与其它路由器就只需要交换少量更新信息即可。

    BGP路由器通过发送和更新消息来表示到达给定IP地址的计算机的首选路径的变化。 如果一个BGP路由器发现一条新的更好的路径，它将更新自己的路由表， 并向与它直接连接的BGP路由器传播这个信息。 这些BGP路由器将依次决定是否更新自己的路由表及传播这个信息。

    参考资料：http://www.livinginternet.com/i/iw\_route\_egp\_bgp.htm

  \item[RIP]: Routing Information Protocol (路由信息协议)

    RIP为局域网提供一个标准的IGP(内部网关协议)协议，它提供了非常好的网络稳定性， 可以保证当一个网络连接断开时，能快速地由另一个网络连接进行包的发送。

    RIP的工作倚仗于一个路由数据库，其中保存了计算机之间的快速路由信息。 每次更新中，每一个路由器会去告诉其它路由器它认为哪条路由是最快的。 更新算法将保证每个路由会用与相邻路由通信得到的最快路由去更新它的数据库。

    参考资料：http://www.livinginternet.com/i/iw\_route\_igp\_rip.htm

  \item[OSPF]: Open Shortest Path First (开放式最短路径优先协议)

    OSPF是一个特别高效的IGP路由协议。它比RIP要快，但也更复杂。

    OSPF和RIP的主要区别是：RIP只保存到达目标地址的下一跳路由的信息； 而OSPF保存了局域网内所有连接的拓扑结构。OSPF算法描述如下：
    \begin{enumerate}
    \item 开始。当一个路由被打开，它向所有的邻居发送"hello"的数据包， 然后接收它们返回的"hello"包。如果它的邻接路由同意同步， 那么它们将建立连接并同步数据库。
    \item 更新。每隔一定的时间间隔，每个路由发送一个更新信息给其它路由。 这个更新信息叫“连接状态”，用于向其它路由描述当前路由的数据库信息。 这样一来，所有的路由都将保存相同的局域网拓扑描述。
    \item 最短路径树。每个路由会计算一个数据结构叫“最短路径树” 用于描述到达目标地址的最短路径。这样一来，在每次通信中就知道哪个路由是最近的。
    \end{enumerate}
  \end{description}
  参考资料：http://www.livinginternet.com/i/iw\_route\_igp\_ospf.htm


\item[17.3] Compare and contrast the IPv4 and IPv6 protocols.

  比较IPv4和IPv6协议。

  Solution:

  IPv4和IPv6是因特网协议，应用于网络层。IPv4是现在应用得最广泛的协议， 而IPv6是因特网的下一代协议。
  \begin{itemize}
  \item IPv4是因特网协议的第4个版本，它使用32位寻址技术。IPv6是下一代因特网协议， 用的是128位寻址。
  \item IPv4最多允许4,294,967,296个独立IP地址，而IPv6可以允许34, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000个IP地址。 (34后面带36个0)
  \item IPv4中，IP地址分为以下几类：A，B，C，D和E。 A，B，C是3类实际在网络中使用的IP地址。D类地址为组播保留。E类地址是保留地址， 意味着它们不应该在IP网络上使用。(除非是一些研究机构出于实验目的才会使用)
  \item IPv6地址大致可分为3类：
    \begin{enumerate}
    \item 单播地址。一个单播地址就是一个单一接口的标识符。 一个发送到单播地址的IPv6报文会被传送到该地址所标识的接口。
    \item 组播地址。组播地址就是一组接口的标识符，这些接口可能属于不同的节点。 一个发送到组播地址的IPv6报文会被传送到多个接口。
    \item 任播地址(任一广播地址)。任播地址是一组接口的标识符， 这些接口可能属于不同节点(这点和组播地址相同)。一个发送到任播地址的IPv6 报文会被传送到这组接口中的其中一个。
    \end{enumerate}
  \item IPv4地址表示：239.255.255.255, 255.255.255.0
  \item IPv6地址用分号“:”分成8段，用16进制表示。比如： 2001:cdba:0000:0000:0000:0000:3257:9652
  \end{itemize} 
  由于人口数量的增加(对IP地址的需求增加)，IPv6的需求日益明显，它能带来以下好处：
  \begin{enumerate}
  \item  增加地址空间
  \item  更高效的路由
  \item  降低管理要求
  \item  改善更换ISP的方法
  \item  更好的移动支持
  \item  多宿主
  \item  安全
  \item  作用域地址：本地链路，本地站点和全局地址空间
  \end{enumerate}


\item[17.4] What is a network / subnet mask? Explain how host A sends a message / packet to host B when: (a) both are on same network and (b) both are on different networks. Explain which layer makes the routing decision and how.

  网络/子网掩码是什么？解释主机A是如何发送消息/包给主机B的当：(a) A，B在同一网络上。 (b) A，B在不同网络上。解释哪一层做出路由决定，是怎么做的？

  Solution:

  掩码是一个用于识别网络/子网地址的位模式。IP地址由两部分组成：网络地址和主机地址。

  IP地址被分为不同的类，这些类标识了它的网络地址。

  例如：IP地址：152.210.011.002，它属于B类地址。那么：
\begin{itemize}
\item 网络掩码：11111111.11111111.00000000.00000000
\item IP 地址：10011000.11010101.00001011.00000010
\end{itemize}
  对网络掩码和IP地址做与操作，我们得到以下网络地址和主机地址：
  \begin{itemize}
\item     网络地址：10011000.11010101.00000000.00000000 (152.213.0.0)
\item     主机地址：00001011.00000010
  \end{itemize}
  同样地，网络管理员可以用子网掩码将任何网络划分成子网。要做到这一点， 我们可以进一步将主机地址划分成更多子网。

  例如，如果要将上述网络划分成18个子网(至少需要5位二进制位25 > 18)， 我们可以将主机地址的前5位用于标识子网地址。
  \begin{itemize}
\item     子网掩码：11111111.11111111.11111000.00000000 (255.255.248.0)
\item     IP 地址：10011000.11010101.00001011.00000010
  \end{itemize}
  对子网掩码和IP地址做与操作，我们得到以下的子网地址：
  \begin{itemize}
\item     10011000.11010101.00001000.00000000 (152.213.8.0)
  \end{itemize}
  主机A是如何发送消息/包给主机B

  当两台主机在同一网络上时，通过主机地址的二进制位识别其它主机。

  当两台主机不在同一网络时，路由器通过网络掩码来识别网络并路由数据包。 每台主机可以通过网络主机地址来识别。

  网络层负责进行路由决策。路由表存储路径信息及其对应的开销， 路由算法使用路由表来决定路由这些数据包的路径。

  路由一般分为静态路由和动态路由。划分依据是： 路由表是固定的还是会根据当前网络状况而改变。


\item[17.5] What are the differences between TCP and UDP? Explain how TCP handles reliable delivery (explain ACK mechanism), flow control (explain TCP sender / receiver window) and congestion control.	

  TCP和UDP之间有什么区别？解释TCP如何处理可靠交付(解释ACK机制)，流量控制 (解释TCP发送器/接收器窗口)及拥塞控制。

  Solution:
  \begin{description}
  \item[TCP](传输控制协议)：TCP是一个面向连接的协议。从客户端到服务器可以建立一个连接， 然后数据通过这个连接进行传输。TCP协议具有以下特点：
    \begin{itemize}
    \item 可靠的。当你沿着一个TCP套接字发送消息，只要连接没有完全中断， 你就有把握它会到达目的地。如果数据包在传输过程中丢失了， 服务器将重新请求丢失的数据包。这意味着服务器将接收到完整而没有损坏的数据。
    \item 有序的。TCP数据包中包括序号和确认，所以未按照顺序收到的包可以被排序。 你不必为数据包的到达顺序而担心。
    \item 重量级的。当TCP字节流以错误的顺序到达，计算机将发出重新发送请求。 序列中已经发出的部分必须一起放回，这个需要一些工作量。
    \end{itemize}
  \item[UDP](用户数据报协议)：UDP是无连接的协议。UDP以数据块的形式在网络中发送消息/数据包。 UDP协议的特点如下：
    \begin{itemize}
    \item 不可靠的。当你发送一个消息，你并不能确保它会到达。它有可能在传输中丢失。
    \item 无序的。当你发送出两个消息。你无法确保哪一个会先到达。
    \item 轻量的。不会考虑发送消息的顺序，没有连接跟踪，仅仅是发送出去，然后就不管它了。 这也意味着它非常快速，网卡和操作系统只需要做很少的工作来数据包中的数据。
    \end{itemize}
  \item[C.] 解释TCP如何处理可靠交付(解释ACK机制)和流量控制(解释TCP发送器/接收器窗口)

    对于每个TCP数据包，如果接收者收到了数据包，那么它必须发出确认。 发送方如果没有收到确认，会重新发送数据包。这个机制保证每个数据包都被传送到接收方。 ACK是TCP协议中用于确认收到数据包的数据包。TCP窗口是发送方在得到接收方的确认前， 在特定连接上能够发送的数据量。

    例如，一对主机在TCP连接上进行通信，其中TCP窗口大小是64KB。那么， 发送方发送完64KB的数据后就必须等待接收方的确认， 接收方发送确认时可能已经收到了全部数据，也可能只收到了部分数据。 如果接收方发出确认所有的数据都已经接收到，那么发送方就会发送另外64KB的数据。 如果发送方收到的确认中表明接收方只收到了32KB的数据(另外32KB的数据可能还在传输， 或者已经丢失)，那么发送方最多只能再发送32KB数据，因为同一时刻不能有超过64KB 的未确认数据。(第二个32KB和此次发送的32KB都未确认)

  \item[D.] 拥塞控制: TCP使用网络拥塞避免算法进行拥塞控制。有许多不同的算法可以解决这个问题。其中， Tahoe和Reno算法是最有名。为了避免拥塞，TCP使用多方位的拥塞控制策略。 对于每个连接，TCP维护一个拥塞窗口，控制未确认数据包的总大小， 这有点类似于TCP中用于流量控制的滑动窗口。TCP使用一种称为“慢启动” 的机制来增加连接初始化后及超时后的拥塞窗口大小。一开始， 拥塞窗口的大小是最大段大小(MSS)的2倍。尽管初始速率很低，但它增加得很快。 每收到一个确认，拥塞窗口就增加1个MSS。这样，经过一个往返时间(RTT)， 拥塞窗口就增加了一倍。当拥塞窗口的大小超过一个阈值，算法就进入一个新的状态， 叫拥塞避免。

    补充阅读： TCP拥塞控制算法 http://www.cnblogs.com/fll/archive/2008/06/10/1217013.html
  \end{description}
  \end{description}
